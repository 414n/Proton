From 32d6ac6c383d710b07fb75668ab6ccc6a8644238 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <joseph.kucia@gmail.com>
Date: Tue, 18 Sep 2018 22:04:21 +0200
Subject: [PATCH] wined3d: Implement synchronous texture access.

For vrclient.
---
 dlls/d3d11/texture.c             |  15 ++++
 dlls/wined3d/cs.c                |  48 ++++++++++++
 dlls/wined3d/device.c            |   2 +
 dlls/wined3d/texture.c           | 123 +++++++++++++++++++++++++++++++
 dlls/wined3d/wined3d.spec        |   1 +
 dlls/wined3d/wined3d_private.h   |  14 ++++
 include/wine/wined3d-interop.idl |   2 +
 include/wine/wined3d.h           |   2 +
 8 files changed, 207 insertions(+)

diff --git a/dlls/d3d11/texture.c b/dlls/d3d11/texture.c
index 58a7633f78c..95328043789 100644
--- a/dlls/d3d11/texture.c
+++ b/dlls/d3d11/texture.c
@@ -744,6 +744,20 @@ static void STDMETHODCALLTYPE d3d11_texture2d_access_gl_texture(IWineD3D11Textur
     wined3d_mutex_unlock();
 }
 
+static unsigned int STDMETHODCALLTYPE d3d11_texture2d_get_gl_texture(IWineD3D11Texture2D *iface)
+{
+    struct d3d_texture2d *texture = impl_from_IWineD3D11Texture2D(iface);
+    unsigned int id;
+
+    TRACE("iface %p.\n", iface);
+
+    wined3d_mutex_lock();
+    id = wined3d_get_gl_texture(texture->wined3d_texture);
+    wined3d_mutex_unlock();
+
+    return id;
+}
+
 static const struct IWineD3D11Texture2DVtbl d3d11_texture2d_vtbl =
 {
     /* IUnknown methods */
@@ -763,6 +777,7 @@ static const struct IWineD3D11Texture2DVtbl d3d11_texture2d_vtbl =
     d3d11_texture2d_GetDesc,
     /* IWineD3D11Texture methods */
     d3d11_texture2d_access_gl_texture,
+    d3d11_texture2d_get_gl_texture,
 };
 
 struct d3d_texture2d *unsafe_impl_from_ID3D11Texture2D(ID3D11Texture2D *iface)
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index da802ee2e49..1f1883cafea 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -75,6 +75,7 @@ enum wined3d_cs_op
     WINED3D_CS_OP_GENERATE_MIPMAPS,
     WINED3D_CS_OP_GL_TEXTURE_CALLBACK,
     WINED3D_CS_OP_USER_CALLBACK,
+    WINED3D_CS_OP_FENCE,
     WINED3D_CS_OP_STOP,
 };
 
@@ -464,6 +465,12 @@ struct wined3d_cs_wait_idle
     enum wined3d_cs_op opcode;
 };
 
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    GLsync *fence;
+};
+
 struct wined3d_cs_stop
 {
     enum wined3d_cs_op opcode;
@@ -2601,6 +2608,46 @@ void wined3d_cs_emit_user_callback(struct wined3d_cs *cs,
     cs->ops->submit(cs, WINED3D_CS_QUEUE_DEFAULT);
 }
 
+static void wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_fence *op = data;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    GLsync fence;
+
+    context = context_acquire(cs->device, NULL, 0);
+    gl_info = context->gl_info;
+
+    fence = GL_EXTCALL(glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0));
+    context->gl_info->gl_ops.gl.p_glFlush();
+
+    *op->fence = fence;
+
+    checkGLcall("fence");
+
+    context_release(context);
+}
+
+static GLsync wined3d_cs_emit_fence(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_fence *op;
+    GLsync fence;
+
+    op = cs->ops->require_space(cs, sizeof(*op), WINED3D_CS_QUEUE_DEFAULT);
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->fence = &fence;
+
+    cs->ops->submit(cs, WINED3D_CS_QUEUE_DEFAULT);
+    cs->ops->finish(cs, WINED3D_CS_QUEUE_DEFAULT);
+
+    return fence;
+}
+
+GLsync wined3d_cs_synchronize(struct wined3d_cs *cs)
+{
+    return wined3d_cs_emit_fence(cs);
+}
+
 static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
 {
     struct wined3d_cs_stop *op;
@@ -2663,6 +2710,7 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_GENERATE_MIPMAPS            */ wined3d_cs_exec_generate_mipmaps,
     /* WINED3D_CS_OP_GL_TEXTURE_CALLBACK         */ wined3d_cs_exec_gl_texture_callback,
     /* WINED3D_CS_OP_USER_CALLBACK               */ wined3d_cs_exec_user_callback,
+    /* WINED3D_CS_OP_FENCE                       */ wined3d_cs_exec_fence,
 };
 
 static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size, enum wined3d_cs_queue_id queue_id)
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 0c48e5fcc82..7102b7c3dff 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -488,6 +488,8 @@ ULONG CDECL wined3d_device_decref(struct wined3d_device *device)
 
         wined3d_stateblock_state_cleanup(&device->stateblock_state);
 
+        wined3d_destroy_gl_vr_context(&device->vr_context);
+
         wined3d_cs_destroy(device->cs);
 
         if (device->recording && wined3d_stateblock_decref(device->recording))
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 7ecaed1a038..bb2a557c972 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -3875,3 +3875,126 @@ void CDECL wined3d_access_gl_texture(struct wined3d_texture *texture,
 
     wined3d_cs_emit_gl_texture_callback(device->cs, texture, callback, depth_texture, data, size);
 }
+
+static const struct wined3d_gl_info *wined3d_prepare_vr_gl_context(struct wined3d_device *device)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+    struct wined3d_vr_gl_context *ctx = &device->vr_context;
+    PIXELFORMATDESCRIPTOR pfd;
+    int pixel_format;
+    HGLRC share_ctx;
+
+    if (ctx->gl_info)
+        return gl_info;
+
+    TRACE("Creating GL context.\n");
+
+    if (!gl_info->p_wglCreateContextAttribsARB)
+    {
+        ERR("wglCreateContextAttribsARB is not supported.\n");
+        return NULL;
+    }
+
+    if (!gl_info->supported[ARB_SYNC])
+    {
+        FIXME("ARB_sync is not supported.\n");
+        return NULL;
+    }
+
+    ctx->window = CreateWindowA(WINED3D_OPENGL_WINDOW_CLASS_NAME, "WineD3D VR window",
+            WS_OVERLAPPEDWINDOW, 10, 10, 10, 10, NULL, NULL, NULL, NULL);
+    if (!ctx->window)
+    {
+        ERR("Failed to create a window.\n");
+        return NULL;
+    }
+
+    ctx->dc = GetDC(ctx->window);
+    if (!ctx->dc)
+    {
+        ERR("Failed to get a DC.\n");
+        goto fail;
+    }
+
+    memset(&pfd, 0, sizeof(pfd));
+    pfd.nSize = sizeof(pfd);
+    pfd.nVersion = 1;
+    pfd.dwFlags = PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW;
+    pfd.iPixelType = PFD_TYPE_RGBA;
+    pfd.cColorBits = 32;
+    pfd.iLayerType = PFD_MAIN_PLANE;
+
+    if (!(pixel_format = ChoosePixelFormat(ctx->dc, &pfd)))
+    {
+        ERR("Failed to find a suitable pixel format.\n");
+        goto fail;
+    }
+    DescribePixelFormat(ctx->dc, pixel_format, sizeof(pfd), &pfd);
+    SetPixelFormat(ctx->dc, pixel_format, &pfd);
+
+    share_ctx = device->context_count ? device->contexts[0]->glCtx : NULL;
+    if (!(ctx->gl_ctx = context_create_wgl_attribs(gl_info, ctx->dc, share_ctx)))
+    {
+        WARN("Failed to create GL context for VR.\n");
+        goto fail;
+    }
+
+    if (!wglMakeCurrent(ctx->dc, ctx->gl_ctx))
+    {
+        ERR("Failed to make GL context current.\n");
+        goto fail;
+    }
+
+    checkGLcall("create context");
+
+    ctx->gl_info = gl_info;
+    return gl_info;
+
+fail:
+    if (ctx->gl_ctx)
+        wglDeleteContext(ctx->gl_ctx);
+    ctx->gl_ctx = NULL;
+    if (ctx->dc)
+        ReleaseDC(ctx->window, ctx->dc);
+    ctx->dc = NULL;
+    if (ctx->window)
+        DestroyWindow(ctx->window);
+    ctx->window = NULL;
+    return NULL;
+}
+
+void wined3d_destroy_gl_vr_context(struct wined3d_vr_gl_context *ctx)
+{
+    if (!ctx->gl_info)
+        return;
+
+    TRACE("Destroying GL context.\n");
+
+    wglMakeCurrent(NULL, NULL);
+    wglDeleteContext(ctx->gl_ctx);
+    ReleaseDC(ctx->window, ctx->dc);
+    DestroyWindow(ctx->window);
+}
+
+unsigned int CDECL wined3d_get_gl_texture(struct wined3d_texture *texture)
+{
+    struct wined3d_device *device = texture->resource.device;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_texture_gl *gl_texture;
+    GLsync fence;
+
+    TRACE("texture %p.\n", texture);
+
+    if (!(gl_info = wined3d_prepare_vr_gl_context(device)))
+        return 0;
+
+    fence = wined3d_cs_synchronize(device->cs);
+    GL_EXTCALL(glWaitSync(fence, 0, GL_TIMEOUT_IGNORED));
+    GL_EXTCALL(glDeleteSync(fence));
+
+    checkGLcall("synchronize CS");
+
+    gl_texture = wined3d_texture_gl(texture);
+    return gl_texture->texture_rgb.name;
+}
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index 4a7708fd797..56a0593bb87 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -321,3 +321,4 @@
 @ cdecl wined3d_access_gl_texture(ptr ptr ptr long)
 @ cdecl wined3d_device_run_cs_callback(ptr ptr ptr long)
 @ cdecl wined3d_device_wait_idle(ptr)
+@ cdecl wined3d_get_gl_texture(ptr)
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 519b0292483..7ded39f9db8 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -3011,6 +3011,14 @@ struct wined3d_stateblock_state
     struct wined3d_light_state light_state;
 };
 
+struct wined3d_vr_gl_context
+{
+    HWND window;
+    HDC dc;
+    HGLRC gl_ctx;
+    const struct wined3d_gl_info *gl_info;
+};
+
 struct wined3d_device
 {
     LONG ref;
@@ -3090,6 +3098,8 @@ struct wined3d_device
     /* Context management */
     struct wined3d_context **contexts;
     UINT context_count;
+
+    struct wined3d_vr_gl_context vr_context;
 };
 
 void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, const struct wined3d_fb_state *fb,
@@ -3809,6 +3819,10 @@ void wined3d_cs_emit_gl_texture_callback(struct wined3d_cs *cs, struct wined3d_t
 void wined3d_cs_emit_user_callback(struct wined3d_cs *cs,
         wined3d_cs_callback callback, const void *data, unsigned int size) DECLSPEC_HIDDEN;
 
+GLsync wined3d_cs_synchronize(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+
+void wined3d_destroy_gl_vr_context(struct wined3d_vr_gl_context *ctx) DECLSPEC_HIDDEN;
+
 static inline void wined3d_cs_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
         unsigned int start_idx, unsigned int count, const void *constants)
 {
diff --git a/include/wine/wined3d-interop.idl b/include/wine/wined3d-interop.idl
index c5395ccc0ed..b1bda8ada76 100644
--- a/include/wine/wined3d-interop.idl
+++ b/include/wine/wined3d-interop.idl
@@ -28,6 +28,8 @@ import "d3d11.idl";
 interface IWineD3D11Texture2D : ID3D11Texture2D
 {
     void access_gl_texture(gl_texture_callback callback, IUnknown *depth_texture, const void *data, unsigned int data_size);
+
+    unsigned int get_gl_texture();
 }
 
 typedef void (__cdecl *user_cs_callback)(const void *data, unsigned int data_size);
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index 4754901265f..9bafa8b0f46 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -2758,6 +2758,8 @@ typedef void (__cdecl *wined3d_gl_texture_callback)(unsigned int gl_texture, uns
 void __cdecl wined3d_access_gl_texture(struct wined3d_texture *texture,
         wined3d_gl_texture_callback callback, struct wined3d_texture *depth_texture, const void *data, unsigned int size);
 
+unsigned int __cdecl wined3d_get_gl_texture(struct wined3d_texture *texture);
+
 typedef void (__cdecl *wined3d_cs_callback)(const void *data, unsigned int size);
 
 void __cdecl wined3d_device_run_cs_callback(struct wined3d_device *device,
