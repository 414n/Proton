From: Brendan Shanks <bshanks@codeweavers.com>
Subject: [PATCH v4 1/4] kernel32/tests: Add tests for named pipes in PIPE_NOWAIT mode.
Message-Id: <20191004184159.23229-1-bshanks@codeweavers.com>
Date: Fri,  4 Oct 2019 11:41:56 -0700

Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
---
 dlls/kernel32/tests/pipe.c | 165 +++++++++++++++++++++++++++++++++++++
 1 file changed, 165 insertions(+)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index f61d441303..dbc4642b82 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -3887,6 +3887,170 @@ static void test_wait_pipe(void)
     CloseHandle(ov.hEvent);
 }
 
+static void test_nowait(void)
+{
+    HANDLE piperead, pipewrite, hFile;
+    OVERLAPPED ol, ol2;
+    DWORD read, write;
+    char readbuf[32768];
+    static const char teststring[] = "bits";
+
+    /* CreateNamedPipe with PIPE_NOWAIT, and read from empty pipe */
+    piperead = CreateNamedPipeA(PIPENAME, FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
+        /* dwPipeMode */ PIPE_TYPE_BYTE | PIPE_NOWAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 512,
+        /* nInBufSize */ 512,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(piperead != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+    pipewrite = CreateFileA(PIPENAME, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(pipewrite != INVALID_HANDLE_VALUE, "CreateFileA failed\n");
+    memset(&ol, 0, sizeof(ol));
+    ol.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
+    SetLastError(0xdeadbeef);
+    ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol) == FALSE, "ReadFile should fail\n");
+    todo_wine ok(GetLastError() == ERROR_NO_DATA, "got %d should be ERROR_NO_DATA\n", GetLastError());
+    if (GetLastError() == ERROR_IO_PENDING)
+        CancelIo(piperead);
+
+    /* test a small write/read */
+    ok(WriteFile(pipewrite, teststring, sizeof(teststring), &write, NULL), "WriteFile should succeed\n");
+    ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol), "ReadFile should succeed\n");
+    ok(read == write, "read/write bytes should match\n");
+    ok(CloseHandle(ol.hEvent), "CloseHandle for the event failed\n");
+    ok(CloseHandle(pipewrite), "CloseHandle for the write pipe failed\n");
+    ok(CloseHandle(piperead), "CloseHandle for the read pipe failed\n");
+
+
+    /* create write side with PIPE_NOWAIT, read side PIPE_WAIT, and test writes */
+    pipewrite = CreateNamedPipeA(PIPENAME, FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
+        /* dwPipeMode */ PIPE_TYPE_BYTE | PIPE_NOWAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 512,
+        /* nInBufSize */ 512,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(pipewrite != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+    piperead = CreateFileA(PIPENAME, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
+    ok(piperead != INVALID_HANDLE_VALUE, "CreateFileA failed\n");
+    memset(&ol, 0, sizeof(ol));
+    ol.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
+    memset(&ol2, 0, sizeof(ol2));
+    ol2.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
+
+    /* write one byte larger than the buffer size, should fail */
+    SetLastError(0xdeadbeef);
+    todo_wine ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
+    /* WriteFile only documents that 'write < sizeof(readbuf)' for this case, but Windows
+     * doesn't seem to do partial writes ('write == 0' always)
+     */
+    ok(write < sizeof(readbuf), "WriteFile should fail to write the whole buffer\n");
+    ok(write == 0, "WriteFile doesn't do partial writes here\n");
+    if (GetLastError() == ERROR_IO_PENDING)
+        CancelIo(piperead);
+
+    /* overlapped read of 32768, non-blocking write of 512 */
+    SetLastError(0xdeadbeef);
+    todo_wine ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2) == FALSE, "ReadFile should fail\n");
+    todo_wine ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    ok(WriteFile(pipewrite, teststring, sizeof(teststring), &write, &ol), "WriteFile should succeed\n");
+    ok(write == sizeof(teststring), "got %d, write should be %d\n", write, sizeof(teststring));
+    ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
+    todo_wine ok(read == sizeof(teststring), "got %d, read should be %d\n", read, sizeof(teststring));
+    if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
+        CancelIo(piperead);
+
+    /* overlapped read of 32768, non-blocking write of 513 */
+    SetLastError(0xdeadbeef);
+    todo_wine ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2) == FALSE, "ReadFile should fail\n");
+    todo_wine ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    todo_wine ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
+    todo_wine ok(write == 513, "got %d, write should be %d\n", write, 513);
+    ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
+    todo_wine ok(read == 513, "got %d, read should be %d\n", read, 513);
+    if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
+        CancelIo(piperead);
+
+    /* overlapped read of 1 byte, non-blocking write of 513 bytes */
+    SetLastError(0xdeadbeef);
+    todo_wine ok(ReadFile(piperead, readbuf, 1, &read, &ol2) == FALSE, "ReadFile should fail\n");
+    todo_wine ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    todo_wine ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
+    todo_wine ok(write == 513, "got %d, write should be %d\n", write, 513);
+    ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
+    ok(read == 1, "got %d, read should be %d\n", read, 1);
+    if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
+        CancelIo(piperead);
+    /* read the remaining 512 bytes */
+    SetLastError(0xdeadbeef);
+    ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2), "ReadFile should succeed\n");
+    todo_wine ok(read == 512, "got %d, write should be %d\n", write, 512);
+    if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
+        CancelIo(piperead);
+
+    /* overlapped read of 1 byte, non-blocking write of 514 bytes */
+    SetLastError(0xdeadbeef);
+    ok(ReadFile(piperead, readbuf, 1, &read, &ol2) == FALSE, "ReadFile should fail\n");
+    ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    todo_wine ok(WriteFile(pipewrite, readbuf, 514, &write, &ol), "WriteFile should succeed\n");
+    todo_wine ok(write == 1, "got %d, write should be %d\n", write, 1);
+    ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
+    ok(read == 1, "got %d, read should be %d\n", read, 1);
+    if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
+        CancelIo(piperead);
+
+    /* write the exact buffer size, should succeed */
+    SetLastError(0xdeadbeef);
+    todo_wine ok(WriteFile(pipewrite, readbuf, 512, &write, &ol), "WriteFile should succeed\n");
+    todo_wine ok(write == 512, "WriteFile should write the whole buffer\n");
+    if (GetLastError() == ERROR_IO_PENDING)
+        CancelIo(piperead);
+
+    ok(CloseHandle(ol.hEvent), "CloseHandle for the event failed\n");
+    ok(CloseHandle(ol2.hEvent), "CloseHandle for the event failed\n");
+    ok(CloseHandle(pipewrite), "CloseHandle for the write pipe failed\n");
+    ok(CloseHandle(piperead), "CloseHandle for the read pipe failed\n");
+
+
+    /* CreateNamedPipe with PIPE_NOWAIT, test ConnectNamedPipe */
+    pipewrite = CreateNamedPipeA(PIPENAME, FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
+        /* dwPipeMode */ PIPE_TYPE_BYTE | PIPE_NOWAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 512,
+        /* nInBufSize */ 512,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(pipewrite != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+    memset(&ol, 0, sizeof(ol));
+    ol.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
+    SetLastError(0xdeadbeef);
+    ok(ConnectNamedPipe(pipewrite, &ol) == FALSE, "ConnectNamedPipe should fail\n");
+    todo_wine ok(GetLastError() == ERROR_PIPE_LISTENING, "got %d should be ERROR_PIPE_LISTENING\n", GetLastError());
+    if (GetLastError() == ERROR_IO_PENDING)
+        CancelIo(pipewrite);
+
+    /* connect and disconnect, then test ConnectNamedPipe again */
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFileA failed\n");
+    ok(CloseHandle(hFile), "CloseHandle failed\n");
+    SetLastError(0xdeadbeef);
+    ok(ConnectNamedPipe(pipewrite,&ol) == FALSE, "ConnectNamedPipe should fail\n");
+    ok(GetLastError() == ERROR_NO_DATA, "got %d should be ERROR_NO_DATA\n", GetLastError());
+    if (GetLastError() == ERROR_IO_PENDING)
+        CancelIo(pipewrite);
+
+    /* call DisconnectNamedPipe and test ConnectNamedPipe again */
+    ok(DisconnectNamedPipe(pipewrite) == TRUE, "DisconnectNamedPipe should succeed\n");
+    SetLastError(0xdeadbeef);
+    ok(ConnectNamedPipe(pipewrite,&ol) == FALSE, "ConnectNamedPipe should fail\n");
+    todo_wine ok(GetLastError() == ERROR_PIPE_LISTENING, "got %d should be ERROR_PIPE_LISTENING\n", GetLastError());
+    if (GetLastError() == ERROR_IO_PENDING)
+        CancelIo(pipewrite);
+    ok(CloseHandle(ol.hEvent), "CloseHandle for the event failed\n");
+    ok(CloseHandle(pipewrite), "CloseHandle for the write pipe failed\n");
+}
+
 START_TEST(pipe)
 {
     char **argv;
@@ -3954,4 +4118,5 @@ START_TEST(pipe)
     test_namedpipe_session_id();
     test_multiple_instances();
     test_wait_pipe();
+    test_nowait();
 }

-- 
2.17.1

From: Brendan Shanks <bshanks@codeweavers.com>
Subject: [PATCH v4 2/4] server: Don't block when reading from named pipes in PIPE_NOWAIT mode.
Message-Id: <20191004184159.23229-2-bshanks@codeweavers.com>
Date: Fri,  4 Oct 2019 11:41:57 -0700
In-Reply-To: <20191004184159.23229-1-bshanks@codeweavers.com>
References: <20191004184159.23229-1-bshanks@codeweavers.com>

Fixes Rockstar Games Launcher hanging for some users.

Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
---
 dlls/kernel32/tests/pipe.c | 2 +-
 server/named_pipe.c        | 5 +++++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index dbc4642b82..59f1684c2a 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -3910,7 +3910,7 @@ static void test_nowait(void)
     ol.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
     SetLastError(0xdeadbeef);
     ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol) == FALSE, "ReadFile should fail\n");
-    todo_wine ok(GetLastError() == ERROR_NO_DATA, "got %d should be ERROR_NO_DATA\n", GetLastError());
+    ok(GetLastError() == ERROR_NO_DATA, "got %d should be ERROR_NO_DATA\n", GetLastError());
     if (GetLastError() == ERROR_IO_PENDING)
         CancelIo(piperead);
 
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 8e0380d060..6926712b8c 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -851,6 +851,11 @@ static int pipe_end_read( struct fd *fd, struct async *async, file_pos_t pos )
     switch (pipe_end->state)
     {
     case FILE_PIPE_CONNECTED_STATE:
+        if ((pipe_end->flags & NAMED_PIPE_NONBLOCKING_MODE) && list_empty( &pipe_end->message_queue ))
+        {
+            set_error( STATUS_PIPE_EMPTY );
+            return 0;
+        }
         break;
     case FILE_PIPE_DISCONNECTED_STATE:
         set_error( STATUS_PIPE_DISCONNECTED );

-- 
2.17.1

From: Brendan Shanks <bshanks@codeweavers.com>
Subject: [PATCH v4 3/4] server: Don't block when writing to named pipes in PIPE_NOWAIT mode.
Message-Id: <20191004184159.23229-3-bshanks@codeweavers.com>
Date: Fri,  4 Oct 2019 11:41:58 -0700
In-Reply-To: <20191004184159.23229-1-bshanks@codeweavers.com>
References: <20191004184159.23229-1-bshanks@codeweavers.com>

Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
---
v4: async_waiting() only checks the head of the queue, use
find_pending_async() instead

 dlls/kernel32/tests/pipe.c | 36 ++++++++++++++++++------------------
 server/named_pipe.c        | 25 ++++++++++++++++++++-----
 2 files changed, 38 insertions(+), 23 deletions(-)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index 59f1684c2a..46b9e1c667 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -3941,7 +3941,7 @@ static void test_nowait(void)
 
     /* write one byte larger than the buffer size, should fail */
     SetLastError(0xdeadbeef);
-    todo_wine ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
+    ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
     /* WriteFile only documents that 'write < sizeof(readbuf)' for this case, but Windows
      * doesn't seem to do partial writes ('write == 0' always)
      */
@@ -3952,32 +3952,32 @@ static void test_nowait(void)
 
     /* overlapped read of 32768, non-blocking write of 512 */
     SetLastError(0xdeadbeef);
-    todo_wine ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2) == FALSE, "ReadFile should fail\n");
-    todo_wine ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2) == FALSE, "ReadFile should fail\n");
+    ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
     ok(WriteFile(pipewrite, teststring, sizeof(teststring), &write, &ol), "WriteFile should succeed\n");
     ok(write == sizeof(teststring), "got %d, write should be %d\n", write, sizeof(teststring));
     ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
-    todo_wine ok(read == sizeof(teststring), "got %d, read should be %d\n", read, sizeof(teststring));
+    ok(read == sizeof(teststring), "got %d, read should be %d\n", read, sizeof(teststring));
     if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
         CancelIo(piperead);
 
     /* overlapped read of 32768, non-blocking write of 513 */
     SetLastError(0xdeadbeef);
-    todo_wine ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2) == FALSE, "ReadFile should fail\n");
-    todo_wine ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
-    todo_wine ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
-    todo_wine ok(write == 513, "got %d, write should be %d\n", write, 513);
+    ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2) == FALSE, "ReadFile should fail\n");
+    ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
+    ok(write == 513, "got %d, write should be %d\n", write, 513);
     ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
-    todo_wine ok(read == 513, "got %d, read should be %d\n", read, 513);
+    ok(read == 513, "got %d, read should be %d\n", read, 513);
     if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
         CancelIo(piperead);
 
     /* overlapped read of 1 byte, non-blocking write of 513 bytes */
     SetLastError(0xdeadbeef);
-    todo_wine ok(ReadFile(piperead, readbuf, 1, &read, &ol2) == FALSE, "ReadFile should fail\n");
-    todo_wine ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
-    todo_wine ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
-    todo_wine ok(write == 513, "got %d, write should be %d\n", write, 513);
+    ok(ReadFile(piperead, readbuf, 1, &read, &ol2) == FALSE, "ReadFile should fail\n");
+    ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
+    ok(WriteFile(pipewrite, readbuf, 513, &write, &ol), "WriteFile should succeed\n");
+    ok(write == 513, "got %d, write should be %d\n", write, 513);
     ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
     ok(read == 1, "got %d, read should be %d\n", read, 1);
     if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
@@ -3985,7 +3985,7 @@ static void test_nowait(void)
     /* read the remaining 512 bytes */
     SetLastError(0xdeadbeef);
     ok(ReadFile(piperead, readbuf, sizeof(readbuf), &read, &ol2), "ReadFile should succeed\n");
-    todo_wine ok(read == 512, "got %d, write should be %d\n", write, 512);
+    ok(read == 512, "got %d, write should be %d\n", write, 512);
     if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
         CancelIo(piperead);
 
@@ -3993,8 +3993,8 @@ static void test_nowait(void)
     SetLastError(0xdeadbeef);
     ok(ReadFile(piperead, readbuf, 1, &read, &ol2) == FALSE, "ReadFile should fail\n");
     ok(GetLastError() == ERROR_IO_PENDING, "got %d should be ERROR_IO_PENDING\n", GetLastError());
-    todo_wine ok(WriteFile(pipewrite, readbuf, 514, &write, &ol), "WriteFile should succeed\n");
-    todo_wine ok(write == 1, "got %d, write should be %d\n", write, 1);
+    ok(WriteFile(pipewrite, readbuf, 514, &write, &ol), "WriteFile should succeed\n");
+    ok(write == 1, "got %d, write should be %d\n", write, 1);
     ok(GetOverlappedResult(piperead, &ol2, &read, FALSE), "GetOverlappedResult should succeed\n");
     ok(read == 1, "got %d, read should be %d\n", read, 1);
     if (GetOverlappedResult(piperead, &ol2, &read, FALSE) == FALSE)
@@ -4002,8 +4002,8 @@ static void test_nowait(void)
 
     /* write the exact buffer size, should succeed */
     SetLastError(0xdeadbeef);
-    todo_wine ok(WriteFile(pipewrite, readbuf, 512, &write, &ol), "WriteFile should succeed\n");
-    todo_wine ok(write == 512, "WriteFile should write the whole buffer\n");
+    ok(WriteFile(pipewrite, readbuf, 512, &write, &ol), "WriteFile should succeed\n");
+    ok(write == 512, "WriteFile should write the whole buffer\n");
     if (GetLastError() == ERROR_IO_PENDING)
         CancelIo(piperead);
 
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 6926712b8c..a709ad0503 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -363,7 +363,7 @@ static struct pipe_message *queue_message( struct pipe_end *pipe_end, struct ios
     return message;
 }
 
-static void wake_message( struct pipe_message *message )
+static void wake_message( struct pipe_message *message, data_size_t result )
 {
     struct async *async = message->async;
 
@@ -371,7 +371,7 @@ static void wake_message( struct pipe_message *message )
     if (!async) return;
 
     message->iosb->status = STATUS_SUCCESS;
-    message->iosb->result = message->iosb->in_size;
+    message->iosb->result = result;
     async_terminate( async, message->iosb->result ? STATUS_ALERTED : STATUS_SUCCESS );
     release_object( async );
 }
@@ -749,7 +749,7 @@ static void message_queue_read( struct pipe_end *pipe_end, struct iosb *iosb )
     {
         iosb->out_data = message->iosb->in_data;
         message->iosb->in_data = NULL;
-        wake_message( message );
+        wake_message( message, message->iosb->in_size );
         free_message( message );
     }
     else
@@ -773,7 +773,7 @@ static void message_queue_read( struct pipe_end *pipe_end, struct iosb *iosb )
             message->read_pos += writing;
             if (message->read_pos == message->iosb->in_size)
             {
-                wake_message(message);
+                wake_message(message, message->iosb->in_size);
                 free_message(message);
             }
         } while (write_pos < iosb->out_size);
@@ -836,7 +836,22 @@ static void reselect_write_queue( struct pipe_end *pipe_end )
         {
             avail += message->iosb->in_size - message->read_pos;
             if (message->async && (avail <= reader->buffer_size || !message->iosb->in_size))
-                wake_message( message );
+            {
+                wake_message( message, message->iosb->in_size );
+            }
+            else if (message->async && (pipe_end->flags & NAMED_PIPE_NONBLOCKING_MODE))
+            {
+                struct async *async = find_pending_async( &reader->read_q );
+                if (!async)
+                {
+                    wake_message( message, message->read_pos );
+                    free_message( message );
+                }
+                else
+                {
+                    release_object( async );
+                }
+            }
         }
     }
 

-- 
2.17.1

From: Brendan Shanks <bshanks@codeweavers.com>
Subject: [PATCH v4 4/4] server: Don't block ConnectNamedPipe for pipe in PIPE_NOWAIT mode.
Message-Id: <20191004184159.23229-4-bshanks@codeweavers.com>
Date: Fri,  4 Oct 2019 11:41:59 -0700
In-Reply-To: <20191004184159.23229-1-bshanks@codeweavers.com>
References: <20191004184159.23229-1-bshanks@codeweavers.com>

Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
---
 dlls/kernel32/tests/pipe.c | 4 ++--
 server/named_pipe.c        | 6 ++++++
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index 46b9e1c667..f53a59db14 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -4026,7 +4026,7 @@ static void test_nowait(void)
     ol.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
     SetLastError(0xdeadbeef);
     ok(ConnectNamedPipe(pipewrite, &ol) == FALSE, "ConnectNamedPipe should fail\n");
-    todo_wine ok(GetLastError() == ERROR_PIPE_LISTENING, "got %d should be ERROR_PIPE_LISTENING\n", GetLastError());
+    ok(GetLastError() == ERROR_PIPE_LISTENING, "got %d should be ERROR_PIPE_LISTENING\n", GetLastError());
     if (GetLastError() == ERROR_IO_PENDING)
         CancelIo(pipewrite);
 
@@ -4044,7 +4044,7 @@ static void test_nowait(void)
     ok(DisconnectNamedPipe(pipewrite) == TRUE, "DisconnectNamedPipe should succeed\n");
     SetLastError(0xdeadbeef);
     ok(ConnectNamedPipe(pipewrite,&ol) == FALSE, "ConnectNamedPipe should fail\n");
-    todo_wine ok(GetLastError() == ERROR_PIPE_LISTENING, "got %d should be ERROR_PIPE_LISTENING\n", GetLastError());
+    ok(GetLastError() == ERROR_PIPE_LISTENING, "got %d should be ERROR_PIPE_LISTENING\n", GetLastError());
     if (GetLastError() == ERROR_IO_PENDING)
         CancelIo(pipewrite);
     ok(CloseHandle(ol.hEvent), "CloseHandle for the event failed\n");
diff --git a/server/named_pipe.c b/server/named_pipe.c
index a709ad0503..309dd8b0c5 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -1115,6 +1115,12 @@ static int pipe_server_ioctl( struct fd *fd, ioctl_code_t code, struct async *as
             return 0;
         }
 
+        if (server->pipe_end.flags & NAMED_PIPE_NONBLOCKING_MODE)
+        {
+            set_error( STATUS_PIPE_LISTENING );
+            return 0;
+        }
+
         queue_async( &server->listen_q, async );
         async_wake_up( &server->pipe_end.pipe->waiters, STATUS_SUCCESS );
         set_error( STATUS_PENDING );

-- 
2.17.1

From: Brendan Shanks <bshanks@codeweavers.com>
Subject: [PATCH] ntdll: Always add a tail to heap allocations.
Message-Id: <20190919223935.22589-1-bshanks@codeweavers.com>
Date: Thu, 19 Sep 2019 15:39:35 -0700

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47783
Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index e8ac1ffa7a..e7da86e09a 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -110,9 +110,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT
 
 /* There will be a free list bucket for every arena size up to and including this value */
 #define HEAP_MAX_SMALL_FREE_LIST 0x100
@@ -722,7 +721,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;
 
     if (block_size < size) return NULL;  /* overflow */
@@ -1674,7 +1673,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1828,7 +1827,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) RtlEnterCriticalSection( &heapPtr->critSection );
 
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;
 

-- 
2.17.1

From: Brendan Shanks <bshanks@codeweavers.com>
Subject: [PATCH v2] user32: WARN() when WINDOWINFO cbSize is incorrect.
Message-Id: <20190919225120.348-1-bshanks@codeweavers.com>
Date: Thu, 19 Sep 2019 15:51:20 -0700

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47783
Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
---
v2: Fix warning when building for Win64

 dlls/user32/win.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 3582262b7d..0523fc2479 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -3847,6 +3847,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetWindowInfo( HWND hwnd, PWINDOWINFO pwi)
 {
     if (!WIN_GetRectangles( hwnd, COORDS_SCREEN, &pwi->rcWindow, &pwi->rcClient )) return FALSE;
     if (!pwi) return FALSE;
+    if (sizeof(WINDOWINFO) != pwi->cbSize)
+        WARN("Incorrect cbSize %d\n", pwi->cbSize);
 
     pwi->rcWindow = rcWindow;
     pwi->rcClient = rcClient;

-- 
2.17.1
