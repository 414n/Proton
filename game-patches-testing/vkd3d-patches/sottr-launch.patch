Signed-off-by: Derek Lesho <dlesho at codeweavers.com>
---
 libs/vkd3d/resource.c      | 91 ++++++++++++++++++++++++++++++++------
 libs/vkd3d/vkd3d_private.h |  3 ++
 2 files changed, 80 insertions(+), 14 deletions(-)

diff --git a/libs/vkd3d/resource.c b/libs/vkd3d/resource.c
index 463f373..603434d 100644
--- a/libs/vkd3d/resource.c
+++ b/libs/vkd3d/resource.c
@@ -1947,8 +1947,13 @@ static void d3d12_desc_destroy(struct d3d12_desc *descriptor,
 void d3d12_desc_copy(struct d3d12_desc *dst, const struct d3d12_desc *src,
         struct d3d12_device *device)
 {
+    pthread_spinlock_t *resource_lock;
+
     assert(dst != src);
 
+    pthread_spin_lock(dst->lock);
+    resource_lock = dst->lock;
+
     d3d12_desc_destroy(dst, device);
 
     *dst = *src;
@@ -1959,6 +1964,8 @@ void d3d12_desc_copy(struct d3d12_desc *dst, const struct d3d12_desc *src,
     {
         vkd3d_view_incref(src->u.view);
     }
+
+    pthread_spin_unlock(resource_lock);
 }
 
 static VkDeviceSize vkd3d_get_required_texel_buffer_alignment(const struct d3d12_device *device,
@@ -2322,19 +2329,23 @@ void d3d12_desc_create_cbv(struct d3d12_desc *descriptor,
 {
     struct VkDescriptorBufferInfo *buffer_info;
     struct d3d12_resource *resource;
+    pthread_spinlock_t *resource_lock;
+
+    pthread_spin_lock(descriptor->lock);
+    resource_lock = descriptor->lock;
 
     d3d12_desc_destroy(descriptor, device);
 
     if (!desc)
     {
         WARN("Constant buffer desc is NULL.\n");
-        return;
+        goto done;
     }
 
     if (desc->SizeInBytes & (D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT - 1))
     {
         WARN("Size is not %u bytes aligned.\n", D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);
-        return;
+        goto done;
     }
 
     buffer_info = &descriptor->u.vk_cbv_info;
@@ -2355,6 +2366,10 @@ void d3d12_desc_create_cbv(struct d3d12_desc *descriptor,
 
     descriptor->magic = VKD3D_DESCRIPTOR_MAGIC_CBV;
     descriptor->vk_descriptor_type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
+
+    done:
+    descriptor->lock = resource_lock;
+    pthread_spin_unlock(resource_lock);
 }
 
 static unsigned int vkd3d_view_flags_from_d3d12_buffer_srv_flags(D3D12_BUFFER_SRV_FLAGS flags)
@@ -2466,23 +2481,27 @@ void d3d12_desc_create_srv(struct d3d12_desc *descriptor,
 {
     struct vkd3d_texture_view_desc vkd3d_desc;
     struct vkd3d_view *view;
+    pthread_spinlock_t *resource_lock;
+
+    pthread_spin_lock(descriptor->lock);
+    resource_lock = descriptor->lock;
 
     d3d12_desc_destroy(descriptor, device);
 
     if (!resource)
     {
         vkd3d_create_null_srv(descriptor, device, desc);
-        return;
+        goto done;
     }
 
     if (d3d12_resource_is_buffer(resource))
     {
         vkd3d_create_buffer_srv(descriptor, device, resource, desc);
-        return;
+        goto done;
     }
 
     if (!init_default_texture_view_desc(&vkd3d_desc, resource, desc ? desc->Format : 0))
-        return;
+        goto done;
 
     vkd3d_desc.miplevel_count = VK_REMAINING_MIP_LEVELS;
     vkd3d_desc.allowed_swizzle = true;
@@ -2559,11 +2578,15 @@ void d3d12_desc_create_srv(struct d3d12_desc *descriptor,
     }
 
     if (!vkd3d_create_texture_view(device, resource->u.vk_image, &vkd3d_desc, &view))
-        return;
+        goto done;
 
     descriptor->magic = VKD3D_DESCRIPTOR_MAGIC_SRV;
     descriptor->vk_descriptor_type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
     descriptor->u.view = view;
+
+    done:
+    descriptor->lock = resource_lock;
+    pthread_spin_unlock(resource_lock);
 }
 
 static unsigned int vkd3d_view_flags_from_d3d12_buffer_uav_flags(D3D12_BUFFER_UAV_FLAGS flags)
@@ -2761,6 +2784,11 @@ void d3d12_desc_create_uav(struct d3d12_desc *descriptor, struct d3d12_device *d
         struct d3d12_resource *resource, struct d3d12_resource *counter_resource,
         const D3D12_UNORDERED_ACCESS_VIEW_DESC *desc)
 {
+    pthread_spinlock_t *resource_lock;
+
+    pthread_spin_lock(descriptor->lock);
+    resource_lock = descriptor->lock;
+
     d3d12_desc_destroy(descriptor, device);
 
     if (!resource)
@@ -2768,7 +2796,7 @@ void d3d12_desc_create_uav(struct d3d12_desc *descriptor, struct d3d12_device *d
         if (counter_resource)
             FIXME("Ignoring counter resource %p.\n", counter_resource);
         vkd3d_create_null_uav(descriptor, device, desc);
-        return;
+        goto done;
     }
 
     if (d3d12_resource_is_buffer(resource))
@@ -2781,6 +2809,10 @@ void d3d12_desc_create_uav(struct d3d12_desc *descriptor, struct d3d12_device *d
             FIXME("Unexpected counter resource for texture view.\n");
         vkd3d_create_texture_uav(descriptor, device, resource, desc);
     }
+
+    done:
+    descriptor->lock = resource_lock;
+    pthread_spin_unlock(resource_lock);
 }
 
 bool vkd3d_create_raw_buffer_view(struct d3d12_device *device,
@@ -2888,13 +2920,17 @@ void d3d12_desc_create_sampler(struct d3d12_desc *sampler,
         struct d3d12_device *device, const D3D12_SAMPLER_DESC *desc)
 {
     struct vkd3d_view *view;
+    pthread_spinlock_t *resource_lock;
+
+    pthread_spin_lock(sampler->lock);
+    resource_lock = sampler->lock;
 
     d3d12_desc_destroy(sampler, device);
 
     if (!desc)
     {
         WARN("NULL sampler desc.\n");
-        return;
+        goto done;
     }
 
     if (desc->AddressU == D3D12_TEXTURE_ADDRESS_MODE_BORDER
@@ -2904,19 +2940,23 @@ void d3d12_desc_create_sampler(struct d3d12_desc *sampler,
                 desc->BorderColor[0], desc->BorderColor[1], desc->BorderColor[2], desc->BorderColor[3]);
 
     if (!(view = vkd3d_view_create()))
-        return;
+        goto done;
 
     if (d3d12_create_sampler(device, desc->Filter, desc->AddressU,
             desc->AddressV, desc->AddressW, desc->MipLODBias, desc->MaxAnisotropy,
             desc->ComparisonFunc, desc->MinLOD, desc->MaxLOD, &view->u.vk_sampler) < 0)
     {
         vkd3d_free(view);
-        return;
+        goto done;
     }
 
     sampler->magic = VKD3D_DESCRIPTOR_MAGIC_SAMPLER;
     sampler->vk_descriptor_type = VK_DESCRIPTOR_TYPE_SAMPLER;
     sampler->u.view = view;
+
+    done:
+    sampler->lock = resource_lock;
+    pthread_spin_unlock(resource_lock);
 }
 
 HRESULT vkd3d_create_static_sampler(struct d3d12_device *device,
@@ -2950,22 +2990,26 @@ void d3d12_rtv_desc_create_rtv(struct d3d12_rtv_desc *rtv_desc, struct d3d12_dev
 {
     struct vkd3d_texture_view_desc vkd3d_desc;
     struct vkd3d_view *view;
+    pthread_spinlock_t *resource_lock;
+
+    pthread_spin_lock(rtv_desc->lock);
+    resource_lock = rtv_desc->lock;
 
     d3d12_rtv_desc_destroy(rtv_desc, device);
 
     if (!resource)
     {
         FIXME("NULL resource RTV not implemented.\n");
-        return;
+        goto done;
     }
 
     if (!init_default_texture_view_desc(&vkd3d_desc, resource, desc ? desc->Format : 0))
-        return;
+        goto done;
 
     if (vkd3d_desc.format->vk_aspect_mask != VK_IMAGE_ASPECT_COLOR_BIT)
     {
         WARN("Trying to create RTV for depth/stencil format %#x.\n", vkd3d_desc.format->dxgi_format);
-        return;
+        goto done;
     }
 
     if (desc)
@@ -3013,7 +3057,7 @@ void d3d12_rtv_desc_create_rtv(struct d3d12_rtv_desc *rtv_desc, struct d3d12_dev
     assert(d3d12_resource_is_texture(resource));
 
     if (!vkd3d_create_texture_view(device, resource->u.vk_image, &vkd3d_desc, &view))
-        return;
+        goto done;
 
     rtv_desc->magic = VKD3D_DESCRIPTOR_MAGIC_RTV;
     rtv_desc->sample_count = vk_samples_from_dxgi_sample_desc(&resource->desc.SampleDesc);
@@ -3023,6 +3067,10 @@ void d3d12_rtv_desc_create_rtv(struct d3d12_rtv_desc *rtv_desc, struct d3d12_dev
     rtv_desc->layer_count = vkd3d_desc.layer_count;
     rtv_desc->view = view;
     rtv_desc->resource = resource;
+
+    done:
+    rtv_desc->lock = resource_lock;
+    pthread_spin_unlock(resource_lock);
 }
 
 /* DSVs */
@@ -3170,6 +3218,8 @@ static ULONG STDMETHODCALLTYPE d3d12_descriptor_heap_Release(ID3D12DescriptorHea
                 for (i = 0; i < heap->desc.NumDescriptors; ++i)
                 {
                     d3d12_desc_destroy(&descriptors[i], device);
+                    pthread_spin_destroy(descriptors[i].lock);
+                    vkd3d_free((void*)descriptors[i].lock);
                 }
                 break;
             }
@@ -3181,6 +3231,8 @@ static ULONG STDMETHODCALLTYPE d3d12_descriptor_heap_Release(ID3D12DescriptorHea
                 for (i = 0; i < heap->desc.NumDescriptors; ++i)
                 {
                     d3d12_rtv_desc_destroy(&rtvs[i], device);
+                    pthread_spin_destroy(rtvs[i].lock);
+                    vkd3d_free((void*)rtvs[i].lock);
                 }
                 break;
             }
@@ -3192,6 +3244,8 @@ static ULONG STDMETHODCALLTYPE d3d12_descriptor_heap_Release(ID3D12DescriptorHea
                 for (i = 0; i < heap->desc.NumDescriptors; ++i)
                 {
                     d3d12_dsv_desc_destroy(&dsvs[i], device);
+                    pthread_spin_destroy(dsvs[i].lock);
+                    vkd3d_free((void*)dsvs[i].lock);
                 }
                 break;
             }
@@ -3367,6 +3421,15 @@ HRESULT d3d12_descriptor_heap_create(struct d3d12_device *device,
 
     memset(object->descriptors, 0, descriptor_size * desc->NumDescriptors);
 
+    for (unsigned int i = 0; i < desc->NumDescriptors; i++)
+    {
+        struct d3d12_desc *cur_desc = (struct d3d12_desc *) (object->descriptors + (i * descriptor_size));
+        pthread_spinlock_t *lock = vkd3d_malloc(sizeof(pthread_spinlock_t));
+
+        pthread_spin_init(lock, PTHREAD_PROCESS_PRIVATE);
+        cur_desc->lock = lock;
+    }
+
     TRACE("Created descriptor heap %p.\n", object);
 
     *descriptor_heap = object;
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index bd9670e..6f1a957 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -466,6 +466,7 @@ void vkd3d_view_incref(struct vkd3d_view *view) DECLSPEC_HIDDEN;
 struct d3d12_desc
 {
     uint32_t magic;
+    pthread_spinlock_t *lock;
     VkDescriptorType vk_descriptor_type;
     union
     {
@@ -521,6 +522,7 @@ HRESULT vkd3d_create_static_sampler(struct d3d12_device *device,
 struct d3d12_rtv_desc
 {
     uint32_t magic;
+    pthread_spinlock_t *lock;
     VkSampleCountFlagBits sample_count;
     const struct vkd3d_format *format;
     uint64_t width;
@@ -541,6 +543,7 @@ void d3d12_rtv_desc_create_rtv(struct d3d12_rtv_desc *rtv_desc, struct d3d12_dev
 struct d3d12_dsv_desc
 {
     uint32_t magic;
+    pthread_spinlock_t *lock;
     VkSampleCountFlagBits sample_count;
     const struct vkd3d_format *format;
     uint64_t width;
-- 
2.23.0

Signed-off-by: Derek Lesho <dlesho at codeweavers.com>
---
v3: Stores the size of the vulkan semaphore array and sequence number array separately.
---
 libs/vkd3d/command.c       | 85 ++++++++++++++++++++------------------
 libs/vkd3d/vkd3d_private.h | 10 +++--
 2 files changed, 51 insertions(+), 44 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index ae88910..844d0ba 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -45,9 +45,12 @@ HRESULT vkd3d_queue_create(struct d3d12_device *device,
     object->vk_queue_flags = properties->queueFlags;
     object->timestamp_bits = properties->timestampValidBits;
 
-    object->semaphores = NULL;
-    object->semaphores_size = 0;
+    object->semaphores.vk_semaphores = NULL;
+    object->semaphores.sequence_numbers = NULL;
+    object->vk_semaphores_size = 0;
+    object->seq_numbers_size = 0;
     object->semaphore_count = 0;
+    object->pending_semaphore_index = -1;
 
     memset(object->old_vk_semaphores, 0, sizeof(object->old_vk_semaphores));
 
@@ -70,9 +73,10 @@ void vkd3d_queue_destroy(struct vkd3d_queue *queue, struct d3d12_device *device)
         ERR("Failed to lock mutex, error %d.\n", rc);
 
     for (i = 0; i < queue->semaphore_count; ++i)
-        VK_CALL(vkDestroySemaphore(device->vk_device, queue->semaphores[i].vk_semaphore, NULL));
+        VK_CALL(vkDestroySemaphore(device->vk_device, queue->semaphores.vk_semaphores[i], NULL));
 
-    vkd3d_free(queue->semaphores);
+    vkd3d_free(queue->semaphores.vk_semaphores);
+    vkd3d_free(queue->semaphores.sequence_numbers);
 
     for (i = 0; i < ARRAY_SIZE(queue->old_vk_semaphores); ++i)
     {
@@ -157,10 +161,10 @@ static void vkd3d_queue_update_sequence_number(struct vkd3d_queue *queue,
 
     for (i = 0; i < queue->semaphore_count; ++i)
     {
-        if (queue->semaphores[i].sequence_number > queue->completed_sequence_number)
+        if (queue->semaphores.sequence_numbers[i] > queue->completed_sequence_number)
             break;
 
-        vk_semaphore = queue->semaphores[i].vk_semaphore;
+        vk_semaphore = queue->semaphores.vk_semaphores[i];
 
         /* Try to store the Vulkan semaphore for reuse. */
         for (j = 0; j < ARRAY_SIZE(queue->old_vk_semaphores); ++j)
@@ -182,7 +186,8 @@ static void vkd3d_queue_update_sequence_number(struct vkd3d_queue *queue,
     if (i > 0)
     {
         queue->semaphore_count -= i;
-        memmove(queue->semaphores, &queue->semaphores[i], queue->semaphore_count * sizeof(*queue->semaphores));
+        memmove(queue->semaphores.vk_semaphores, &queue->semaphores.vk_semaphores[i], queue->semaphore_count * sizeof(*queue->semaphores.vk_semaphores));
+        memmove(queue->semaphores.sequence_numbers, &queue->semaphores.sequence_numbers[i], queue->semaphore_count * sizeof(*queue->semaphores.sequence_numbers));
     }
 
     if (destroyed_semaphore_count)
@@ -201,7 +206,7 @@ static uint64_t vkd3d_queue_reset_sequence_number_locked(struct vkd3d_queue *que
     queue->submitted_sequence_number = 1;
 
     for (i = 0; i < queue->semaphore_count; ++i)
-        queue->semaphores[i].sequence_number = queue->submitted_sequence_number;
+        queue->semaphores.sequence_numbers[i] = queue->submitted_sequence_number;
 
     return queue->submitted_sequence_number;
 }
@@ -5511,6 +5516,7 @@ static void STDMETHODCALLTYPE d3d12_command_queue_CopyTileMappings(ID3D12Command
 static void STDMETHODCALLTYPE d3d12_command_queue_ExecuteCommandLists(ID3D12CommandQueue *iface,
         UINT command_list_count, ID3D12CommandList * const *command_lists)
 {
+    static const VkPipelineStageFlagBits wait_stage_mask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     struct d3d12_command_list *cmd_list;
@@ -5556,6 +5562,15 @@ static void STDMETHODCALLTYPE d3d12_command_queue_ExecuteCommandLists(ID3D12Comm
     submit_desc.signalSemaphoreCount = 0;
     submit_desc.pSignalSemaphores = NULL;
 
+    if (command_queue->vkd3d_queue->pending_semaphore_index != -1)
+    {
+        submit_desc.waitSemaphoreCount = command_queue->vkd3d_queue->semaphore_count - command_queue->vkd3d_queue->pending_semaphore_index;
+        submit_desc.pWaitSemaphores = &command_queue->vkd3d_queue->semaphores.vk_semaphores[command_queue->vkd3d_queue->pending_semaphore_index];
+        submit_desc.pWaitDstStageMask = &wait_stage_mask;
+
+        command_queue->vkd3d_queue->pending_semaphore_index = -1;
+    }
+
     if (!(vk_queue = vkd3d_queue_acquire(command_queue->vkd3d_queue)))
     {
         ERR("Failed to acquire queue %p.\n", command_queue->vkd3d_queue);
@@ -5593,6 +5608,7 @@ static void STDMETHODCALLTYPE d3d12_command_queue_EndEvent(ID3D12CommandQueue *i
 static HRESULT STDMETHODCALLTYPE d3d12_command_queue_Signal(ID3D12CommandQueue *iface,
         ID3D12Fence *fence_iface, UINT64 value)
 {
+    static const VkPipelineStageFlagBits wait_stage_mask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkSemaphore vk_semaphore = VK_NULL_HANDLE;
@@ -5643,6 +5659,15 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_queue_Signal(ID3D12CommandQueue *
     submit_info.signalSemaphoreCount = vk_semaphore ? 1 : 0;
     submit_info.pSignalSemaphores = &vk_semaphore;
 
+    if (command_queue->vkd3d_queue->pending_semaphore_index != -1)
+    {
+        submit_info.waitSemaphoreCount = command_queue->vkd3d_queue->semaphore_count - command_queue->vkd3d_queue->pending_semaphore_index;
+        submit_info.pWaitSemaphores = &command_queue->vkd3d_queue->semaphores.vk_semaphores[command_queue->vkd3d_queue->pending_semaphore_index];
+        submit_info.pWaitDstStageMask = &wait_stage_mask;
+
+        command_queue->vkd3d_queue->pending_semaphore_index = -1;
+    }
+
     if ((vr = VK_CALL(vkQueueSubmit(vk_queue, 1, &submit_info, vk_fence))) >= 0)
     {
         sequence_number = ++vkd3d_queue->submitted_sequence_number;
@@ -5702,21 +5727,16 @@ fail:
 static HRESULT STDMETHODCALLTYPE d3d12_command_queue_Wait(ID3D12CommandQueue *iface,
         ID3D12Fence *fence_iface, UINT64 value)
 {
-    static const VkPipelineStageFlagBits wait_stage_mask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
-    const struct vkd3d_vk_device_procs *vk_procs;
     struct vkd3d_signaled_semaphore *semaphore;
     uint64_t completed_value = 0;
     struct vkd3d_queue *queue;
     struct d3d12_fence *fence;
-    VkSubmitInfo submit_info;
     VkQueue vk_queue;
-    VkResult vr;
     HRESULT hr;
 
     TRACE("iface %p, fence %p, value %#"PRIx64".\n", iface, fence_iface, value);
 
-    vk_procs = &command_queue->device->vk_procs;
     queue = command_queue->vkd3d_queue;
 
     fence = unsafe_impl_from_ID3D12Fence(fence_iface);
@@ -5752,18 +5772,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_queue_Wait(ID3D12CommandQueue *if
         return S_OK;
     }
 
-    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
-    submit_info.pNext = NULL;
-    submit_info.waitSemaphoreCount = 1;
-    submit_info.pWaitSemaphores = &semaphore->vk_semaphore;
-    submit_info.pWaitDstStageMask = &wait_stage_mask;
-    submit_info.commandBufferCount = 0;
-    submit_info.pCommandBuffers = NULL;
-    submit_info.signalSemaphoreCount = 0;
-    submit_info.pSignalSemaphores = NULL;
-
-    if (!vkd3d_array_reserve((void **)&queue->semaphores, &queue->semaphores_size,
-            queue->semaphore_count + 1, sizeof(*queue->semaphores)))
+    if (!vkd3d_array_reserve((void **)&queue->semaphores.vk_semaphores, &queue->vk_semaphores_size,
+            queue->semaphore_count + 1, sizeof(*queue->semaphores.vk_semaphores))
+     || !vkd3d_array_reserve((void **)&queue->semaphores.sequence_numbers, &queue->seq_numbers_size,
+            queue->semaphore_count + 1, sizeof(*queue->semaphores.sequence_numbers)))
     {
         ERR("Failed to allocate memory for semaphore.\n");
         vkd3d_queue_release(queue);
@@ -5771,24 +5783,17 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_queue_Wait(ID3D12CommandQueue *if
         goto fail;
     }
 
-    if ((vr = VK_CALL(vkQueueSubmit(vk_queue, 1, &submit_info, VK_NULL_HANDLE))) >= 0)
-    {
-        queue->semaphores[queue->semaphore_count].vk_semaphore = semaphore->vk_semaphore;
-        queue->semaphores[queue->semaphore_count].sequence_number = queue->submitted_sequence_number + 1;
-        ++queue->semaphore_count;
+    queue->semaphores.vk_semaphores[queue->semaphore_count] = semaphore->vk_semaphore;
+    queue->semaphores.sequence_numbers[queue->semaphore_count] = queue->submitted_sequence_number + 1;
 
-        command_queue->last_waited_fence = fence;
-        command_queue->last_waited_fence_value = value;
-    }
+    if (queue->pending_semaphore_index == -1) queue->pending_semaphore_index = queue->semaphore_count;
 
-    vkd3d_queue_release(queue);
+    ++queue->semaphore_count;
 
-    if (vr < 0)
-    {
-        WARN("Failed to submit wait operation, vr %d.\n", vr);
-        hr = hresult_from_vk_result(vr);
-        goto fail;
-    }
+    command_queue->last_waited_fence = fence;
+    command_queue->last_waited_fence_value = value;
+
+    vkd3d_queue_release(queue);
 
     d3d12_fence_remove_vk_semaphore(fence, semaphore);
     return S_OK;
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 294e677..bd9670e 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -954,11 +954,13 @@ struct vkd3d_queue
 
     struct
     {
-        VkSemaphore vk_semaphore;
-        uint64_t sequence_number;
-    } *semaphores;
-    size_t semaphores_size;
+        VkSemaphore *vk_semaphores;
+        uint64_t *sequence_numbers;
+    } semaphores;
+    size_t vk_semaphores_size;
+    size_t seq_numbers_size;
     size_t semaphore_count;
+    uint64_t pending_semaphore_index;
 
     VkSemaphore old_vk_semaphores[VKD3D_MAX_VK_SYNC_OBJECTS];
 };
-- 
2.23.0
