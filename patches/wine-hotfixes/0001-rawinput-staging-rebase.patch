From 5c6200ef5b03ae15336f47fb7cbc79d10e1b0596 Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Sun, 28 Jun 2020 16:32:54 -0600
Subject: [PATCH] rawinput staging rebase

---
 ...user32-Improve-GetKeyboardLayoutList.patch |    2 +-
 patches/patchinstall.sh                       |   82 +
 ...-tests-for-window-region-of-layered-.patch |    9 +-
 ...ess-argument-to-find_rawinput_device.patch |   53 -
 .../0001-user32-rawinput-hid.patch            |  812 ++++++++
 ...ra-data-for-hardware_msg_data-messag.patch |  150 --
 ...nput-message-type-to-send_hardware_m.patch |  262 ---
 ...-WM_INPUT-RIM_TYPEHID-message-handli.patch |  138 --
 ...d-input-message-to-server-when-HID-r.patch |  139 --
 patches/user32-rawinput-hid/definition        |    3 +-
 patches/user32-rawinput-keyboard/definition   |    2 +-
 ...-user32-rawinput-mouse-experimental.patch} |  247 ++-
 ...-relative-RawMotion-events-unprocess.patch |   86 -
 ...mulate-mouse-movement-to-avoid-round.patch |  117 --
 .../definition                                |    3 +-
 .../0001-user32-rawinput-mouse.patch          | 1684 +++++++++++++++++
 ...hardware_message-flags-for-rawinput-.patch |  128 --
 ...-rawinput-message-if-request-flag-is.patch |  171 --
 ...e_send_input-flags-to-hint-raw-input.patch |  201 --
 ...dvertise-XInput2-version-2.1-support.patch |  146 --
 ...-track-of-pointer-and-device-button-.patch |  224 ---
 ...en-to-RawMotion-and-RawButton-events.patch |  282 ---
 ...plement-GetRegisteredRawInputDevices.patch |  204 --
 ...ort-for-dinput-devices-that-use-raw-.patch |  191 --
 ...input-interface-for-dinput8-mouse-de.patch |  194 --
 ...-Fix-rawinput-events-sequence-number.patch |   64 -
 patches/user32-rawinput-mouse/definition      |    2 +-
 ...d-test-for-DISCL_EXCLUSIVE-flag-inte.patch |   44 -
 ...rt-for-RIDEV_NOLEGACY-flag-in-Regist.patch |   75 -
 ..._INPUTSINK-flag-only-when-DISCL_BACK.patch |   28 -
 ...ct-rawinput-flags-for-DISCL_EXCLUSIV.patch |   40 -
 ...sktop-cursor-pos-even-if-RIDEV_NOLEG.patch |   76 -
 ...te-the-key-state-if-RIDEV_NOLEGACY-i.patch |  106 --
 patches/user32-rawinput-nolegacy/definition   |    2 -
 34 files changed, 2813 insertions(+), 3154 deletions(-)
 delete mode 100644 patches/user32-rawinput-hid/0001-server-Add-process-argument-to-find_rawinput_device.patch
 create mode 100644 patches/user32-rawinput-hid/0001-user32-rawinput-hid.patch
 delete mode 100644 patches/user32-rawinput-hid/0002-server-Allow-extra-data-for-hardware_msg_data-messag.patch
 delete mode 100644 patches/user32-rawinput-hid/0003-server-Add-HID-input-message-type-to-send_hardware_m.patch
 delete mode 100644 patches/user32-rawinput-hid/0004-user32-Implement-WM_INPUT-RIM_TYPEHID-message-handli.patch
 delete mode 100644 patches/user32-rawinput-hid/0005-hidclass.sys-Send-input-message-to-server-when-HID-r.patch
 rename patches/user32-rawinput-mouse-experimental/{0001-winex11.drv-Add-support-for-absolute-RawMotion-event.patch => 0001-user32-rawinput-mouse-experimental.patch} (52%)
 delete mode 100644 patches/user32-rawinput-mouse-experimental/0002-winex11.drv-Send-relative-RawMotion-events-unprocess.patch
 delete mode 100644 patches/user32-rawinput-mouse-experimental/0003-winex11.drv-Accumulate-mouse-movement-to-avoid-round.patch
 create mode 100644 patches/user32-rawinput-mouse/0001-user32-rawinput-mouse.patch
 delete mode 100644 patches/user32-rawinput-mouse/0004-server-Add-send_hardware_message-flags-for-rawinput-.patch
 delete mode 100644 patches/user32-rawinput-mouse/0005-server-Broadcast-rawinput-message-if-request-flag-is.patch
 delete mode 100644 patches/user32-rawinput-mouse/0006-user32-Add-__wine_send_input-flags-to-hint-raw-input.patch
 delete mode 100644 patches/user32-rawinput-mouse/0007-winex11.drv-Advertise-XInput2-version-2.1-support.patch
 delete mode 100644 patches/user32-rawinput-mouse/0008-winex11.drv-Keep-track-of-pointer-and-device-button-.patch
 delete mode 100644 patches/user32-rawinput-mouse/0009-winex11.drv-Listen-to-RawMotion-and-RawButton-events.patch
 delete mode 100644 patches/user32-rawinput-mouse/0010-user32-Implement-GetRegisteredRawInputDevices.patch
 delete mode 100644 patches/user32-rawinput-mouse/0011-dinput8-Add-support-for-dinput-devices-that-use-raw-.patch
 delete mode 100644 patches/user32-rawinput-mouse/0012-dinput8-Use-raw-input-interface-for-dinput8-mouse-de.patch
 delete mode 100644 patches/user32-rawinput-mouse/0013-dinput-Fix-rawinput-events-sequence-number.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/0001-dinput8-tests-Add-test-for-DISCL_EXCLUSIVE-flag-inte.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/0002-user32-Add-support-for-RIDEV_NOLEGACY-flag-in-Regist.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/0003-dinput-Set-RIDEV_INPUTSINK-flag-only-when-DISCL_BACK.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/0004-dinput-Set-correct-rawinput-flags-for-DISCL_EXCLUSIV.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/0005-server-Update-desktop-cursor-pos-even-if-RIDEV_NOLEG.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/0006-server-Also-update-the-key-state-if-RIDEV_NOLEGACY-i.patch
 delete mode 100644 patches/user32-rawinput-nolegacy/definition

diff --git a/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch b/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
index 200cbbe9..a9a72e87 100644
--- a/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
+++ b/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
@@ -108,9 +108,9 @@ index 9ec829860af..56fbc558de2 100644
      test_OemKeyScan();
      test_GetRawInputData();
 +    test_GetKeyboardLayoutList();
+     test_GetRawInputBuffer();
      test_RegisterRawInputDevices();
      test_rawinput(argv[0]);
- 
 -- 
 2.27.0
 
diff --git a/patches/patchinstall.sh b/patches/patchinstall.sh
index 99376f3d..bffe3281 100755
--- a/patches/patchinstall.sh
+++ b/patches/patchinstall.sh
@@ -265,6 +265,9 @@ patch_enable_all ()
 	enable_user32_ScrollWindowEx="$1"
 	enable_user32_ShowWindow="$1"
 	enable_user32_msgbox_Support_WM_COPY_mesg="$1"
+	enable_user32_rawinput_mouse="$1"
+	enable_user32_rawinput_hid="$1"
+	enable_user32_rawinput_mouse_experimental="$1"
 	enable_user32_recursive_activation="$1"
 	enable_user32_window_activation="$1"
 	enable_uxtheme_CloseThemeClass="$1"
@@ -882,6 +885,15 @@ patch_enable ()
 		user32-msgbox-Support-WM_COPY-mesg)
 			enable_user32_msgbox_Support_WM_COPY_mesg="$2"
 			;;
+		user32-rawinput-mouse)
+			enable_user32_rawinput_mouse="$2"
+			;;
+		user32-rawinput-hid)
+			enable_user32_rawinput_hid="$2"
+			;;
+		user32-rawinput-mouse-experimental)
+			enable_user32_rawinput_mouse_experimental="$2"
+			;;
 		user32-recursive-activation)
 			enable_user32_recursive_activation="$2"
 			;;
@@ -1492,6 +1504,17 @@ if test "$enable_user32_window_activation" -eq 1; then
 	enable_user32_recursive_activation=1
 fi
 
+if test "$enable_user32_rawinput_mouse" -eq 1; then
+	if test "$enable_loader_KeyboardLayouts" -gt 1; then
+		abort "Patchset loader-KeyboardLayouts disabled, but user32-rawinput-mouse depends on that."
+	fi
+	if test "$enable_winex11_drv_mouse_coorrds" -gt 1; then
+		abort "Patchset winex11.drv-mouse-coorrds disabled, but user32-rawinput-mouse depends on that."
+	fi
+	enable_loader_KeyboardLayouts=1
+	enable_winex11_drv_mouse_coorrds=1
+fi
+
 if test "$enable_stdole32_tlb_SLTG_Typelib" -eq 1; then
 	if test "$enable_widl_SLTG_Typelib_Support" -gt 1; then
 		abort "Patchset widl-SLTG_Typelib_Support disabled, but stdole32.tlb-SLTG_Typelib depends on that."
@@ -5997,6 +6020,65 @@ if test "$enable_winex11_drv_mouse_coorrds" -eq 1; then
 	) >> "$patchlist"
 fi
 
+# Patchset user32-rawinput-mouse
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	loader-KeyboardLayouts, winex11.drv-mouse-coorrds
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#42631] Mouse drift, jump or don't react to small slow movements in Unity-engine games and Fallout 4 (partly fixed in
+# | 	Unity games, have walkaround in Fallout4 )
+# |   *	[#42675] Overwatch: Phantom mouse input / view pulled up to ceiling
+# |
+# | Modified files:
+# |   *	dlls/dinput/device_private.h, dlls/dinput/dinput_main.c, dlls/dinput/mouse.c, dlls/dinput8/tests/device.c,
+# | 	dlls/user32/input.c, dlls/user32/rawinput.c, dlls/user32/user32.spec, dlls/wineandroid.drv/keyboard.c,
+# | 	dlls/wineandroid.drv/window.c, dlls/winemac.drv/ime.c, dlls/winemac.drv/keyboard.c, dlls/winemac.drv/mouse.c,
+# | 	dlls/winex11.drv/event.c, dlls/winex11.drv/keyboard.c, dlls/winex11.drv/mouse.c, dlls/winex11.drv/x11drv.h,
+# | 	dlls/winex11.drv/x11drv_main.c, include/winuser.h, server/protocol.def, server/queue.c
+# |
+if test "$enable_user32_rawinput_mouse" -eq 1; then
+	patch_apply user32-rawinput-mouse/0001-user32-rawinput-mouse.patch
+	(
+		printf '%s\n' '+    { "Rémi Bernon", "user32: Implement GetRegisteredRawInputDevices.", 1 },';
+	) >> "$patchlist"
+fi
+
+# Patchset user32-rawinput-hid
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	server-Key_State, loader-KeyboardLayouts, winex11.drv-mouse-coorrds, user32-rawinput-mouse, user32-rawinput-nolegacy
+# |
+# | Modified files:
+# |   *	dlls/hidclass.sys/device.c, dlls/hidclass.sys/hid.h, dlls/hidclass.sys/pnp.c, dlls/user32/message.c,
+# | 	dlls/user32/rawinput.c, dlls/user32/user_private.h, server/protocol.def, server/queue.c, server/trace.c
+# |
+if test "$enable_user32_rawinput_hid" -eq 1; then
+	patch_apply user32-rawinput-hid/0001-user32-rawinput-hid.patch
+	(
+		printf '%s\n' '+    { "Rémi Bernon", "server: Add process argument to find_rawinput_device.", 1 },';
+	) >> "$patchlist"
+fi
+
+# Patchset user32-rawinput-mouse-experimental
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	server-Key_State, loader-KeyboardLayouts, winex11.drv-mouse-coorrds, user32-rawinput-mouse, user32-rawinput-nolegacy
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#45882] - Raw Input should use untransformed mouse values (affects Overwatch, several Source games).
+# |
+# | Modified files:
+# |   *	dlls/user32/message.c, dlls/winex11.drv/mouse.c, dlls/winex11.drv/x11drv.h, dlls/winex11.drv/x11drv_main.c,
+# | 	server/queue.c
+# |
+if test "$enable_user32_rawinput_mouse_experimental" -eq 1; then
+	patch_apply user32-rawinput-mouse-experimental/0001-user32-rawinput-mouse-experimental.patch
+	(
+		printf '%s\n' '+    { "Derek Lesho", "winex11.drv: Add support for absolute RawMotion events.", 1 },';
+	) >> "$patchlist"
+fi
+
 # Patchset wininet-Cleanup
 # |
 # | Modified files:
diff --git a/patches/user32-Mouse_Message_Hwnd/0003-user32-tests-Add-tests-for-window-region-of-layered-.patch b/patches/user32-Mouse_Message_Hwnd/0003-user32-tests-Add-tests-for-window-region-of-layered-.patch
index 21a75c87..2a5c33ef 100644
--- a/patches/user32-Mouse_Message_Hwnd/0003-user32-tests-Add-tests-for-window-region-of-layered-.patch
+++ b/patches/user32-Mouse_Message_Hwnd/0003-user32-tests-Add-tests-for-window-region-of-layered-.patch
@@ -12,21 +12,22 @@ index 4efca268f..ddb203710 100644
 --- a/dlls/user32/tests/input.c
 +++ b/dlls/user32/tests/input.c
 @@ -83,6 +83,7 @@ static int (WINAPI *pGetMouseMovePointsEx) (UINT, LPMOUSEMOVEPOINT, LPMOUSEMOVEP
- static UINT (WINAPI *pGetRawInputDeviceList) (PRAWINPUTDEVICELIST, PUINT, UINT);
  static UINT (WINAPI *pGetRawInputDeviceInfoW) (HANDLE, UINT, void *, UINT *);
  static UINT (WINAPI *pGetRawInputDeviceInfoA) (HANDLE, UINT, void *, UINT *);
+ static BOOL (WINAPI *pIsWow64Process)(HANDLE, PBOOL);
 +static int  (WINAPI *pGetWindowRgnBox)(HWND, LPRECT);
  
  #define MAXKEYEVENTS 12
  #define MAXKEYMESSAGES MAXKEYEVENTS /* assuming a key event generates one
-@@ -169,6 +170,7 @@ static void init_function_pointers(void)
+@@ -165,7 +165,7 @@ static void init_function_pointers(void)
      GET_PROC(GetRawInputDeviceList);
      GET_PROC(GetRawInputDeviceInfoW);
      GET_PROC(GetRawInputDeviceInfoA);
+-
 +    GET_PROC(GetWindowRgnBox);
+     hdll = GetModuleHandleA("kernel32");
+     GET_PROC(IsWow64Process);
  #undef GET_PROC
- }
- 
 @@ -2054,6 +2056,9 @@ static void test_Input_mouse(void)
      DWORD thread_id;
      WNDCLASSA wclass;
diff --git a/patches/user32-rawinput-hid/0001-server-Add-process-argument-to-find_rawinput_device.patch b/patches/user32-rawinput-hid/0001-server-Add-process-argument-to-find_rawinput_device.patch
deleted file mode 100644
index 7275a048..00000000
--- a/patches/user32-rawinput-hid/0001-server-Add-process-argument-to-find_rawinput_device.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 694ff514bfce59c2590668e3e812d501b713acdb Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 12 Sep 2019 14:14:08 +0200
-Subject: [PATCH 1/5] server: Add process argument to find_rawinput_device.
-
-We need to be able to iterate all registered rawinput devices for
-foreign processes, not only the current one.
----
- server/queue.c | 10 +++++-----
- 1 file changed, 5 insertions(+), 5 deletions(-)
-
-diff --git a/server/queue.c b/server/queue.c
-index f5dc06100d1..3ed7e82a906 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -1576,11 +1576,11 @@ static user_handle_t find_hardware_message_window( struct desktop *desktop, stru
-     return win;
- }
- 
--static struct rawinput_device_entry *find_rawinput_device( unsigned short usage_page, unsigned short usage )
-+static struct rawinput_device_entry *find_rawinput_device( struct process *process, unsigned short usage_page, unsigned short usage )
- {
-     struct rawinput_device_entry *e;
- 
--    LIST_FOR_EACH_ENTRY( e, &current->process->rawinput_devices, struct rawinput_device_entry, entry )
-+    LIST_FOR_EACH_ENTRY( e, &process->rawinput_devices, struct rawinput_device_entry, entry )
-     {
-         if (e->device.usage_page != usage_page || e->device.usage != usage) continue;
-         return e;
-@@ -1593,7 +1593,7 @@ static void update_rawinput_device(const struct rawinput_device *device)
- {
-     struct rawinput_device_entry *e;
- 
--    if (!(e = find_rawinput_device( device->usage_page, device->usage )))
-+    if (!(e = find_rawinput_device( current->process, device->usage_page, device->usage )))
-     {
-         if (!(e = mem_alloc( sizeof(*e) ))) return;
-         list_add_tail( &current->process->rawinput_devices, &e->entry );
-@@ -3375,9 +3375,9 @@ DECL_HANDLER(update_rawinput_devices)
-         update_rawinput_device(&devices[i]);
-     }
- 
--    e = find_rawinput_device( 1, 2 );
-+    e = find_rawinput_device( current->process, 1, 2 );
-     current->process->rawinput_mouse = e ? &e->device : NULL;
--    e = find_rawinput_device( 1, 6 );
-+    e = find_rawinput_device( current->process, 1, 6 );
-     current->process->rawinput_kbd   = e ? &e->device : NULL;
- }
- 
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-hid/0001-user32-rawinput-hid.patch b/patches/user32-rawinput-hid/0001-user32-rawinput-hid.patch
new file mode 100644
index 00000000..9c5604ff
--- /dev/null
+++ b/patches/user32-rawinput-hid/0001-user32-rawinput-hid.patch
@@ -0,0 +1,812 @@
+From 7bf4e8842bb559f19e4ee4dc882c8b62e80dc496 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Thu, 12 Sep 2019 14:14:08 +0200
+Subject: [PATCH 1/5] server: Add process argument to find_rawinput_device.
+
+We need to be able to iterate all registered rawinput devices for
+foreign processes, not only the current one.
+---
+ server/queue.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/server/queue.c b/server/queue.c
+index 46ace52f004..810612c5167 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -1490,11 +1490,11 @@ static user_handle_t find_hardware_message_window( struct desktop *desktop, stru
+     return win;
+ }
+ 
+-static struct rawinput_device_entry *find_rawinput_device( unsigned short usage_page, unsigned short usage )
++static struct rawinput_device_entry *find_rawinput_device( struct process *process, unsigned short usage_page, unsigned short usage )
+ {
+     struct rawinput_device_entry *e;
+ 
+-    LIST_FOR_EACH_ENTRY( e, &current->process->rawinput_devices, struct rawinput_device_entry, entry )
++    LIST_FOR_EACH_ENTRY( e, &process->rawinput_devices, struct rawinput_device_entry, entry )
+     {
+         if (e->device.usage_page != usage_page || e->device.usage != usage) continue;
+         return e;
+@@ -1507,7 +1507,7 @@ static void update_rawinput_device(const struct rawinput_device *device)
+ {
+     struct rawinput_device_entry *e;
+ 
+-    if (!(e = find_rawinput_device( device->usage_page, device->usage )))
++    if (!(e = find_rawinput_device( current->process, device->usage_page, device->usage )))
+     {
+         if (!(e = mem_alloc( sizeof(*e) ))) return;
+         list_add_tail( &current->process->rawinput_devices, &e->entry );
+@@ -3286,9 +3286,9 @@ DECL_HANDLER(update_rawinput_devices)
+         update_rawinput_device(&devices[i]);
+     }
+ 
+-    e = find_rawinput_device( 1, 2 );
++    e = find_rawinput_device( current->process, 1, 2 );
+     current->process->rawinput_mouse = e ? &e->device : NULL;
+-    e = find_rawinput_device( 1, 6 );
++    e = find_rawinput_device( current->process, 1, 6 );
+     current->process->rawinput_kbd   = e ? &e->device : NULL;
+ }
+ 
+-- 
+2.27.0
+
+From 4911b756851c2babeca2bed557d816c7d44e4a6a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Thu, 19 Sep 2019 09:20:44 +0200
+Subject: [PATCH 2/5] server: Allow extra data for hardware_msg_data message.
+
+The RIM_TYPEHID messages will have to carry the variable length HID
+report.
+---
+ server/queue.c | 31 +++++++++++++++++++++----------
+ 1 file changed, 21 insertions(+), 10 deletions(-)
+
+diff --git a/server/queue.c b/server/queue.c
+index 810612c5167..f5d19031485 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -343,13 +343,13 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
+ 
+ /* allocate a hardware message and its data */
+ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_source source,
+-                                               unsigned int time )
++                                               unsigned int time, data_size_t extra_len )
+ {
+     struct hardware_msg_data *msg_data;
+     struct message *msg;
+ 
+     if (!(msg = mem_alloc( sizeof(*msg) ))) return NULL;
+-    if (!(msg_data = mem_alloc( sizeof(*msg_data) )))
++    if (!(msg_data = mem_alloc( sizeof(*msg_data) + extra_len )))
+     {
+         free( msg );
+         return NULL;
+@@ -358,9 +358,9 @@ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_sour
+     msg->type      = MSG_HARDWARE;
+     msg->time      = time;
+     msg->data      = msg_data;
+-    msg->data_size = sizeof(*msg_data);
++    msg->data_size = sizeof(*msg_data) + extra_len;
+ 
+-    memset( msg_data, 0, sizeof(*msg_data) );
++    memset( msg_data, 0, sizeof(*msg_data) + extra_len );
+     msg_data->info   = info;
+     msg_data->source = source;
+     return msg;
+@@ -393,7 +393,7 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
+         return;
+     }
+ 
+-    if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
++    if (!(msg = alloc_hardware_message( 0, source, get_tick_count(), 0 ))) return;
+ 
+     msg->msg = WM_MOUSEMOVE;
+     msg->x   = x;
+@@ -1649,6 +1649,8 @@ struct rawinput_message
+     struct hw_msg_source     source;
+     unsigned int             time;
+     struct hardware_msg_data data;
++    const void              *extra;
++    data_size_t              extra_len;
+ };
+ 
+ /* check if process is supposed to receive a WM_INPUT message and eventually queue it */
+@@ -1659,6 +1661,7 @@ static int queue_rawinput_message( struct process* process, void *arg )
+     struct desktop *target_desktop = NULL;
+     struct thread *target_thread = NULL;
+     struct message *msg;
++    struct hardware_msg_data *msg_data;
+     int wparam = RIM_INPUT;
+ 
+     if (raw_msg->data.rawinput.type == RIM_TYPEMOUSE)
+@@ -1676,14 +1679,18 @@ static int queue_rawinput_message( struct process* process, void *arg )
+         wparam = RIM_INPUTSINK;
+     }
+ 
+-    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time )))
++    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time, raw_msg->extra_len )))
+         goto done;
++    msg_data = msg->data;
+ 
+     msg->win    = device->target;
+     msg->msg    = WM_INPUT;
+     msg->wparam = wparam;
+     msg->lparam = 0;
+-    memcpy( msg->data, &raw_msg->data, sizeof(raw_msg->data) );
++
++    memcpy( msg_data, &raw_msg->data, sizeof(*msg_data) );
++    if (raw_msg->extra_len && raw_msg->extra)
++        memcpy( msg_data + 1, raw_msg->extra, raw_msg->extra_len );
+ 
+     queue_hardware_message( raw_msg->desktop, msg, 1 );
+ 
+@@ -1756,6 +1763,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
+         raw_msg.desktop    = desktop;
+         raw_msg.source     = source;
+         raw_msg.time       = time;
++        raw_msg.extra      = NULL;
++        raw_msg.extra_len  = 0;
+ 
+         msg_data = &raw_msg.data;
+         msg_data->info                = input->mouse.info;
+@@ -1785,7 +1794,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
+         if (!(flags & (1 << i))) continue;
+         flags &= ~(1 << i);
+ 
+-        if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
++        if (!(msg = alloc_hardware_message( input->mouse.info, source, time, 0 ))) return 0;
+         msg_data = msg->data;
+ 
+         msg->win       = get_user_full_handle( win );
+@@ -1894,6 +1903,8 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
+         raw_msg.desktop    = desktop;
+         raw_msg.source     = source;
+         raw_msg.time       = time;
++        raw_msg.extra      = NULL;
++        raw_msg.extra_len  = 0;
+ 
+         msg_data = &raw_msg.data;
+         msg_data->info                 = input->kbd.info;
+@@ -1917,7 +1928,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
+     if (!(req_flags & SEND_HWMSG_WINDOW))
+         return 0;
+ 
+-    if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
++    if (!(msg = alloc_hardware_message( input->kbd.info, source, time, 0 ))) return 0;
+     msg_data = msg->data;
+ 
+     msg->win       = get_user_full_handle( win );
+@@ -1955,7 +1966,7 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
+     struct hw_msg_source source = { IMDT_UNAVAILABLE, origin };
+     struct message *msg;
+ 
+-    if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
++    if (!(msg = alloc_hardware_message( 0, source, get_tick_count(), 0 ))) return;
+ 
+     msg->win       = get_user_full_handle( win );
+     msg->msg       = input->hw.msg;
+-- 
+2.27.0
+
+From 217e81586a7c9edb0f92d06096b0649c75506eac Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 11 Nov 2019 18:35:18 +0100
+Subject: [PATCH 3/5] server: Make it possible to queue rawinput message on all
+ desktops.
+
+---
+ server/queue.c | 18 +++++++++++++-----
+ 1 file changed, 13 insertions(+), 5 deletions(-)
+
+diff --git a/server/queue.c b/server/queue.c
+index f5d19031485..59c6cbb6921 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -1658,8 +1658,8 @@ static int queue_rawinput_message( struct process* process, void *arg )
+ {
+     const struct rawinput_message* raw_msg = arg;
+     const struct rawinput_device *device = NULL;
+-    struct desktop *target_desktop = NULL;
+-    struct thread *target_thread = NULL;
++    struct desktop *target_desktop = NULL, *desktop = NULL;
++    struct thread *target_thread = NULL, *foreground = NULL;
+     struct message *msg;
+     struct hardware_msg_data *msg_data;
+     int wparam = RIM_INPUT;
+@@ -1670,12 +1670,18 @@ static int queue_rawinput_message( struct process* process, void *arg )
+         device = process->rawinput_kbd;
+     if (!device) return 0;
+ 
+-    if (process != raw_msg->foreground->process)
++    if (raw_msg->desktop) desktop = (struct desktop *)grab_object( raw_msg->desktop );
++    else if (!(desktop = get_desktop_obj( process, process->desktop, 0 ))) goto done;
++
++    if (raw_msg->foreground) foreground = (struct thread *)grab_object( raw_msg->foreground );
++    else if (!(foreground = get_foreground_thread( desktop, 0 ))) goto done;
++
++    if (process != foreground->process)
+     {
+         if (!(device->flags & RIDEV_INPUTSINK)) goto done;
+         if (!(target_thread = get_window_thread( device->target ))) goto done;
+         if (!(target_desktop = get_thread_desktop( target_thread, 0 ))) goto done;
+-        if (target_desktop != raw_msg->desktop) goto done;
++        if (target_desktop != desktop) goto done;
+         wparam = RIM_INPUTSINK;
+     }
+ 
+@@ -1692,11 +1698,13 @@ static int queue_rawinput_message( struct process* process, void *arg )
+     if (raw_msg->extra_len && raw_msg->extra)
+         memcpy( msg_data + 1, raw_msg->extra, raw_msg->extra_len );
+ 
+-    queue_hardware_message( raw_msg->desktop, msg, 1 );
++    queue_hardware_message( desktop, msg, 1 );
+ 
+ done:
+     if (target_thread) release_object( target_thread );
+     if (target_desktop) release_object( target_desktop );
++    if (foreground) release_object( foreground );
++    if (desktop) release_object( desktop );
+     return 0;
+ }
+ 
+-- 
+2.27.0
+
+From 3773a581e6c1a90bde0497f31972b1a1aa6987f8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 11 Nov 2019 18:35:18 +0100
+Subject: [PATCH 4/5] server: Add HID input message type to
+ send_hardware_message request.
+
+---
+ dlls/user32/message.c      |  4 ++-
+ dlls/user32/rawinput.c     | 60 ++++++++++++++++++++++++++++++++++++--
+ dlls/user32/user_private.h |  2 ++
+ server/protocol.def        | 26 +++++++++++++++--
+ server/queue.c             | 58 +++++++++++++++++++++++++++++++-----
+ server/trace.c             | 10 +++++--
+ 6 files changed, 143 insertions(+), 17 deletions(-)
+
+diff --git a/dlls/user32/message.c b/dlls/user32/message.c
+index c5c7db667cf..bb7c79b9b2c 100644
+--- a/dlls/user32/message.c
++++ b/dlls/user32/message.c
+@@ -3244,10 +3244,10 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, UINT flags )
+     {
+         req->win        = wine_server_user_handle( hwnd );
+         req->flags      = flags;
+-        req->input.type = input->type;
+         switch (input->type)
+         {
+         case INPUT_MOUSE:
++            req->input.type        = HW_INPUT_MOUSE;
+             req->input.mouse.x     = input->u.mi.dx;
+             req->input.mouse.y     = input->u.mi.dy;
+             req->input.mouse.data  = input->u.mi.mouseData;
+@@ -3256,6 +3256,7 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, UINT flags )
+             req->input.mouse.info  = input->u.mi.dwExtraInfo;
+             break;
+         case INPUT_KEYBOARD:
++            req->input.type      = HW_INPUT_KEYBOARD;
+             req->input.kbd.vkey  = input->u.ki.wVk;
+             req->input.kbd.scan  = input->u.ki.wScan;
+             req->input.kbd.flags = input->u.ki.dwFlags;
+@@ -3263,6 +3264,7 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, UINT flags )
+             req->input.kbd.info  = input->u.ki.dwExtraInfo;
+             break;
+         case INPUT_HARDWARE:
++            req->input.type      = HW_INPUT_HARDWARE;
+             req->input.hw.msg    = input->u.hi.uMsg;
+             req->input.hw.lparam = MAKELONG( input->u.hi.wParamL, input->u.hi.wParamH );
+             break;
+diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
+index 43da5248faf..90dc911397d 100644
+--- a/dlls/user32/rawinput.c
++++ b/dlls/user32/rawinput.c
+@@ -47,6 +47,7 @@ struct device
+ {
+     WCHAR *path;
+     HANDLE file;
++    HANDLE handle;
+     RID_DEVICE_INFO info;
+     PHIDP_PREPARSED_DATA data;
+ };
+@@ -63,6 +64,8 @@ static CRITICAL_SECTION_DEBUG rawinput_devices_cs_debug =
+ };
+ static CRITICAL_SECTION rawinput_devices_cs = { &rawinput_devices_cs_debug, -1, 0, 0, 0, 0 };
+ 
++extern DWORD WINAPI GetFinalPathNameByHandleW(HANDLE file, LPWSTR path, DWORD charcount, DWORD flags);
++
+ static BOOL array_reserve(void **elements, unsigned int *capacity, unsigned int count, unsigned int size)
+ {
+     unsigned int new_capacity, max_capacity;
+@@ -144,10 +147,43 @@ static struct device *add_device(HDEVINFO set, SP_DEVICE_INTERFACE_DATA *iface)
+     device->path = path;
+     device->file = file;
+     device->info.cbSize = sizeof(RID_DEVICE_INFO);
++    device->handle = INVALID_HANDLE_VALUE;
+ 
+     return device;
+ }
+ 
++HANDLE rawinput_handle_from_device_handle(HANDLE device)
++{
++    WCHAR buffer[sizeof(OBJECT_NAME_INFORMATION) + MAX_PATH + 1];
++    OBJECT_NAME_INFORMATION *info = (OBJECT_NAME_INFORMATION*)&buffer;
++    ULONG dummy;
++    unsigned int i;
++
++    for (i = 0; i < rawinput_devices_count; ++i)
++    {
++        if (rawinput_devices[i].handle == device)
++            return &rawinput_devices[i];
++    }
++
++    if (NtQueryObject( device, ObjectNameInformation, &buffer, sizeof(buffer) - sizeof(WCHAR), &dummy ) || !info->Name.Buffer)
++        return NULL;
++
++    /* replace \??\ with \\?\ to match rawinput_devices paths */
++    if (info->Name.Length > 1 && info->Name.Buffer[0] == '\\' && info->Name.Buffer[1] == '?')
++        info->Name.Buffer[1] = '\\';
++
++    for (i = 0; i < rawinput_devices_count; ++i)
++    {
++        if (strcmpW(rawinput_devices[i].path, info->Name.Buffer) == 0)
++        {
++            rawinput_devices[i].handle = device;
++            return &rawinput_devices[i];
++        }
++    }
++
++    return NULL;
++}
++
+ static void find_devices(void)
+ {
+     static ULONGLONG last_check;
+@@ -325,6 +361,22 @@ BOOL rawinput_from_hardware_message(RAWINPUT *rawinput, const struct hardware_ms
+         rawinput->data.keyboard.Message          = msg_data->rawinput.kbd.message;
+         rawinput->data.keyboard.ExtraInformation = msg_data->info;
+     }
++    else if (msg_data->rawinput.type == RIM_TYPEHID)
++    {
++        if (sizeof(*rawinput) + msg_data->rawinput.hid.length > RAWINPUT_BUFFER_SIZE)
++        {
++            ERR("unexpectedly large hardware message dropped\n");
++            return FALSE;
++        }
++
++        rawinput->header.dwSize  = FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + msg_data->rawinput.hid.length;
++        rawinput->header.hDevice = rawinput_handle_from_device_handle(wine_server_ptr_handle(msg_data->rawinput.hid.device));
++        rawinput->header.wParam  = 0;
++
++        rawinput->data.hid.dwSizeHid = msg_data->rawinput.hid.length;
++        rawinput->data.hid.dwCount = 1;
++        memcpy(rawinput->data.hid.bRawData, msg_data + 1, msg_data->rawinput.hid.length);
++    }
+     else
+     {
+         FIXME("Unhandled rawinput type %#x.\n", msg_data->rawinput.type);
+@@ -514,7 +566,7 @@ UINT WINAPI DECLSPEC_HOTPATCH GetRawInputBuffer(RAWINPUT *data, UINT *data_size,
+ {
+     struct hardware_msg_data *msg_data;
+     RAWINPUT *rawinput;
+-    UINT count = 0, rawinput_size, next_size, overhead;
++    UINT count = 0, rawinput_size, msg_size, next_size, overhead;
+     BOOL is_wow64;
+     int i;
+ 
+@@ -572,7 +624,10 @@ UINT WINAPI DECLSPEC_HOTPATCH GetRawInputBuffer(RAWINPUT *data, UINT *data_size,
+                               data->header.dwSize - sizeof(RAWINPUTHEADER));
+         data->header.dwSize += overhead;
+         data = NEXTRAWINPUTBLOCK(data);
+-        msg_data++;
++        msg_size = sizeof(*msg_data);
++        if (msg_data->rawinput.type == RIM_TYPEHID)
++            msg_size += msg_data->rawinput.hid.length;
++        msg_data = (struct hardware_msg_data *)((char *)msg_data + msg_size);
+     }
+ 
+     if (count == 0 && next_size == 0) *data_size = 0;
+@@ -647,6 +702,7 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT
+             handle, command, data, data_size);
+ 
+     if (!data_size) return ~0U;
++    if (!device) return ~0U;
+ 
+     /* each case below must set:
+      *     *data_size: length (meaning defined by command) of data we want to copy
+diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
+index eb828203597..6592927cfae 100644
+--- a/dlls/user32/user_private.h
++++ b/dlls/user32/user_private.h
+@@ -380,4 +380,6 @@ static inline WCHAR *heap_strdupW(const WCHAR *src)
+     return dst;
+ }
+ 
++extern HANDLE rawinput_handle_from_device_handle(HANDLE device);
++
+ #endif /* __WINE_USER_PRIVATE_H */
+diff --git a/server/protocol.def b/server/protocol.def
+index 447dd0b023b..3aa150039fd 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -312,6 +312,13 @@ struct hardware_msg_data
+             int            y;       /* y coordinate */
+             unsigned int   data;    /* mouse data */
+         } mouse;
++        struct
++        {
++            int            type;    /* RIM_TYPEHID */
++            obj_handle_t   device;
++            unsigned int   length;  /* HID report length */
++            /* followed by length bytes of HID report data  */
++        } hid;
+     } rawinput;
+ };
+ 
+@@ -335,7 +342,7 @@ typedef union
+     int type;
+     struct
+     {
+-        int            type;    /* INPUT_KEYBOARD */
++        int            type;    /* HW_INPUT_KEYBOARD */
+         unsigned short vkey;    /* virtual key code */
+         unsigned short scan;    /* scan code */
+         unsigned int   flags;   /* event flags */
+@@ -344,7 +351,7 @@ typedef union
+     } kbd;
+     struct
+     {
+-        int            type;    /* INPUT_MOUSE */
++        int            type;    /* HW_INPUT_MOUSE */
+         int            x;       /* coordinates */
+         int            y;
+         unsigned int   data;    /* mouse data */
+@@ -354,11 +361,23 @@ typedef union
+     } mouse;
+     struct
+     {
+-        int            type;    /* INPUT_HARDWARE */
++        int            type;    /* HW_INPUT_HARDWARE */
+         unsigned int   msg;     /* message code */
+         lparam_t       lparam;  /* message param */
+     } hw;
++    struct
++    {
++        int            type;    /* HW_INPUT_HID */
++        obj_handle_t   device;
++        unsigned char  usage_page;
++        unsigned char  usage;
++        unsigned int   length;
++    } hid;
+ } hw_input_t;
++#define HW_INPUT_MOUSE    0
++#define HW_INPUT_KEYBOARD 1
++#define HW_INPUT_HARDWARE 2
++#define HW_INPUT_HID      3
+ 
+ typedef union
+ {
+@@ -2326,6 +2345,7 @@ enum message_type
+     user_handle_t   win;       /* window handle */
+     hw_input_t      input;     /* input data */
+     unsigned int    flags;     /* flags (see below) */
++    VARARG(data,bytes);        /* hid report data */
+ @REPLY
+     int             wait;      /* do we need to wait for a reply? */
+     int             prev_x;    /* previous cursor position */
+diff --git a/server/queue.c b/server/queue.c
+index 59c6cbb6921..fbed47d6951 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -1594,7 +1594,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
+     struct msg_queue *queue;
+     struct message *msg;
+     timeout_t timeout = 2000 * -10000;  /* FIXME: load from registry */
+-    int id = (input->type == INPUT_MOUSE) ? WH_MOUSE_LL : WH_KEYBOARD_LL;
++    int id = (input->type == HW_INPUT_MOUSE) ? WH_MOUSE_LL : WH_KEYBOARD_LL;
+ 
+     if (!(hook_thread = get_first_global_hook( id ))) return 0;
+     if (!(queue = hook_thread->queue)) return 0;
+@@ -1612,7 +1612,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
+     msg->data_size = hardware_msg->data_size;
+     msg->result    = NULL;
+ 
+-    if (input->type == INPUT_KEYBOARD)
++    if (input->type == HW_INPUT_KEYBOARD)
+     {
+         unsigned short vkey = input->kbd.vkey;
+         if (input->kbd.flags & KEYEVENTF_UNICODE) vkey = VK_PACKET;
+@@ -1648,6 +1648,8 @@ struct rawinput_message
+     struct desktop          *desktop;
+     struct hw_msg_source     source;
+     unsigned int             time;
++    unsigned char            usage_page;
++    unsigned char            usage;
+     struct hardware_msg_data data;
+     const void              *extra;
+     data_size_t              extra_len;
+@@ -1657,6 +1659,7 @@ struct rawinput_message
+ static int queue_rawinput_message( struct process* process, void *arg )
+ {
+     const struct rawinput_message* raw_msg = arg;
++    const struct rawinput_device_entry *entry;
+     const struct rawinput_device *device = NULL;
+     struct desktop *target_desktop = NULL, *desktop = NULL;
+     struct thread *target_thread = NULL, *foreground = NULL;
+@@ -1668,6 +1671,8 @@ static int queue_rawinput_message( struct process* process, void *arg )
+         device = process->rawinput_mouse;
+     else if (raw_msg->data.rawinput.type == RIM_TYPEKEYBOARD)
+         device = process->rawinput_kbd;
++    else if ((entry = find_rawinput_device( process, raw_msg->usage_page, raw_msg->usage )))
++        device = &entry->device;
+     if (!device) return 0;
+ 
+     if (raw_msg->desktop) desktop = (struct desktop *)grab_object( raw_msg->desktop );
+@@ -1986,6 +1991,37 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
+     queue_hardware_message( desktop, msg, 1 );
+ }
+ 
++/* queue a hardware message for an hid event */
++static void queue_hid_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
++                               unsigned int origin, struct msg_queue *sender, unsigned int req_flags,
++                               const void *report, data_size_t report_len )
++{
++    struct hw_msg_source source = { IMDT_UNAVAILABLE, origin };
++    struct hardware_msg_data *msg_data;
++    struct rawinput_message raw_msg;
++
++    if (!(req_flags & SEND_HWMSG_RAWINPUT))
++        return;
++
++    /* send to all desktops */
++    raw_msg.foreground = NULL;
++    raw_msg.desktop    = NULL;
++    raw_msg.source     = source;
++    raw_msg.time       = get_tick_count();
++    raw_msg.usage_page = input->hid.usage_page;
++    raw_msg.usage      = input->hid.usage;
++    raw_msg.extra      = report;
++    raw_msg.extra_len  = report_len;
++
++    msg_data = &raw_msg.data;
++    msg_data->flags               = 0;
++    msg_data->rawinput.type       = RIM_TYPEHID;
++    msg_data->rawinput.hid.device = input->hid.device;
++    msg_data->rawinput.hid.length = report_len;
++
++    enum_processes( queue_rawinput_message, &raw_msg );
++}
++
+ /* check message filter for a hardware message */
+ static int check_hw_message_filter( user_handle_t win, unsigned int msg_code,
+                                     user_handle_t filter_win, unsigned int first, unsigned int last )
+@@ -2491,15 +2527,18 @@ DECL_HANDLER(send_hardware_message)
+ 
+     switch (req->input.type)
+     {
+-    case INPUT_MOUSE:
++    case HW_INPUT_MOUSE:
+         reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
+         break;
+-    case INPUT_KEYBOARD:
++    case HW_INPUT_KEYBOARD:
+         reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
+         break;
+-    case INPUT_HARDWARE:
++    case HW_INPUT_HARDWARE:
+         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
+         break;
++    case HW_INPUT_HID:
++        queue_hid_message( desktop, req->win, &req->input, origin, sender, req->flags, get_req_data(), get_req_data_size() );
++        break;
+     default:
+         set_error( STATUS_INVALID_PARAMETER );
+     }
+@@ -3271,20 +3310,23 @@ DECL_HANDLER(get_rawinput_buffer)
+     {
+         struct message *msg = LIST_ENTRY( ptr, struct message, entry );
+         struct hardware_msg_data *data = msg->data;
++        data_size_t msg_size = sizeof(*data);
++        if (data->rawinput.type == RIM_TYPEHID)
++            msg_size += data->rawinput.hid.length;
+ 
+         ptr = list_next( &input->msg_list, ptr );
+         if (msg->msg != WM_INPUT) continue;
+ 
+         next_size = req->rawinput_size;
+         if (size + next_size > req->buffer_size) break;
+-        if (cur + sizeof(*data) > buf + get_reply_max_size()) break;
++        if (cur + msg_size > buf + get_reply_max_size()) break;
+ 
+-        memcpy(cur, data, sizeof(*data));
++        memcpy(cur, data, msg_size);
+         list_remove( &msg->entry );
+         free_message( msg );
+ 
+         size += next_size;
+-        cur += sizeof(*data);
++        cur += msg_size;
+         count++;
+     }
+ 
+diff --git a/server/trace.c b/server/trace.c
+index 6c7f3251db6..15bc7f2135e 100644
+--- a/server/trace.c
++++ b/server/trace.c
+@@ -386,24 +386,28 @@ static void dump_hw_input( const char *prefix, const hw_input_t *input )
+ {
+     switch (input->type)
+     {
+-    case INPUT_MOUSE:
++    case HW_INPUT_MOUSE:
+         fprintf( stderr, "%s{type=MOUSE,x=%d,y=%d,data=%08x,flags=%08x,time=%u",
+                  prefix, input->mouse.x, input->mouse.y, input->mouse.data, input->mouse.flags,
+                  input->mouse.time );
+         dump_uint64( ",info=", &input->mouse.info );
+         fputc( '}', stderr );
+         break;
+-    case INPUT_KEYBOARD:
++    case HW_INPUT_KEYBOARD:
+         fprintf( stderr, "%s{type=KEYBOARD,vkey=%04hx,scan=%04hx,flags=%08x,time=%u",
+                  prefix, input->kbd.vkey, input->kbd.scan, input->kbd.flags, input->kbd.time );
+         dump_uint64( ",info=", &input->kbd.info );
+         fputc( '}', stderr );
+         break;
+-    case INPUT_HARDWARE:
++    case HW_INPUT_HARDWARE:
+         fprintf( stderr, "%s{type=HARDWARE,msg=%04x", prefix, input->hw.msg );
+         dump_uint64( ",lparam=", &input->hw.lparam );
+         fputc( '}', stderr );
+         break;
++    case HW_INPUT_HID:
++        fprintf( stderr, "%s{type=HID,device=%04x,usage_page=%02x,usage=%02x,length=%04x}",
++                 prefix, input->hid.device, input->hid.usage_page, input->hid.usage, input->hid.length );
++        break;
+     default:
+         fprintf( stderr, "%s{type=%04x}", prefix, input->type );
+         break;
+-- 
+2.27.0
+
+From e66b6ebb0ca064b98f2d71d744c2ed49dffc3eb2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Wed, 18 Sep 2019 21:04:25 +0200
+Subject: [PATCH 5/5] hidclass.sys: Send input message to server when HID
+ report is received.
+
+---
+ dlls/hidclass.sys/device.c | 30 ++++++++++++++++++++++++++++++
+ dlls/hidclass.sys/hid.h    |  1 +
+ dlls/hidclass.sys/pnp.c    | 16 ++++++++++++++++
+ 3 files changed, 47 insertions(+)
+
+diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
+index 0e905c8322f..369d847e3c1 100644
+--- a/dlls/hidclass.sys/device.c
++++ b/dlls/hidclass.sys/device.c
+@@ -26,9 +26,11 @@
+ #include "winuser.h"
+ #include "setupapi.h"
+ 
++#include "wine/server.h"
+ #include "wine/debug.h"
+ #include "ddk/hidsdi.h"
+ #include "ddk/hidtypes.h"
++#include "ddk/ntifs.h"
+ #include "ddk/wdm.h"
+ 
+ #include "initguid.h"
+@@ -123,6 +125,8 @@ NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device)
+         return status;
+     }
+ 
++    ext->link_handle = INVALID_HANDLE_VALUE;
++
+     /* FIXME: This should probably be done in mouhid.sys. */
+     if (ext->preparseData->caps.UsagePage == HID_USAGE_PAGE_GENERIC
+             && ext->preparseData->caps.Usage == HID_USAGE_GENERIC_MOUSE)
+@@ -207,6 +211,8 @@ void HID_DeleteDevice(DEVICE_OBJECT *device)
+         IoCompleteRequest(irp, IO_NO_INCREMENT);
+     }
+ 
++    CloseHandle(ext->link_handle);
++
+     TRACE("Delete device(%p) %s\n", device, debugstr_w(ext->device_name));
+     HeapFree(GetProcessHeap(), 0, ext->device_name);
+     RtlFreeUnicodeString(&ext->link_name);
+@@ -241,6 +247,28 @@ static NTSTATUS copy_packet_into_buffer(HID_XFER_PACKET *packet, BYTE* buffer, U
+         return STATUS_BUFFER_OVERFLOW;
+ }
+ 
++static void HID_Device_sendRawInput(DEVICE_OBJECT *device, HID_XFER_PACKET *packet)
++{
++    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
++
++    if (ext->link_handle == INVALID_HANDLE_VALUE)
++        return;
++
++    SERVER_START_REQ(send_hardware_message)
++    {
++        req->win                  = 0;
++        req->flags                = SEND_HWMSG_RAWINPUT;
++        req->input.type           = HW_INPUT_HID;
++        req->input.hid.device     = wine_server_obj_handle(ext->link_handle);
++        req->input.hid.usage_page = ext->preparseData->caps.UsagePage;
++        req->input.hid.usage      = ext->preparseData->caps.Usage;
++        req->input.hid.length     = packet->reportBufferLen;
++        wine_server_add_data(req, packet->reportBuffer, packet->reportBufferLen);
++        wine_server_call(req);
++    }
++    SERVER_END_REQ;
++}
++
+ static void HID_Device_processQueue(DEVICE_OBJECT *device)
+ {
+     IRP *irp;
+@@ -324,6 +352,7 @@ static DWORD CALLBACK hid_device_thread(void *args)
+             if (irp->IoStatus.u.Status == STATUS_SUCCESS)
+             {
+                 RingBuffer_Write(ext->ring_buffer, packet);
++                HID_Device_sendRawInput(device, packet);
+                 HID_Device_processQueue(device);
+             }
+ 
+@@ -370,6 +399,7 @@ static DWORD CALLBACK hid_device_thread(void *args)
+                 else
+                     packet->reportId = 0;
+                 RingBuffer_Write(ext->ring_buffer, packet);
++                HID_Device_sendRawInput(device, packet);
+                 HID_Device_processQueue(device);
+             }
+ 
+diff --git a/dlls/hidclass.sys/hid.h b/dlls/hidclass.sys/hid.h
+index 36d13c009d7..f12e04d7898 100644
+--- a/dlls/hidclass.sys/hid.h
++++ b/dlls/hidclass.sys/hid.h
+@@ -46,6 +46,7 @@ typedef struct _BASE_DEVICE_EXTENSION {
+     ULONG poll_interval;
+     WCHAR *device_name;
+     UNICODE_STRING link_name;
++    HANDLE link_handle;
+     WCHAR device_id[MAX_DEVICE_ID_LEN];
+     WCHAR instance_id[MAX_DEVICE_ID_LEN];
+     struct ReportRingBuffer *ring_buffer;
+diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
+index 1c130e8dd80..b84a358dba4 100644
+--- a/dlls/hidclass.sys/pnp.c
++++ b/dlls/hidclass.sys/pnp.c
+@@ -299,12 +299,28 @@ NTSTATUS WINAPI HID_PNP_Dispatch(DEVICE_OBJECT *device, IRP *irp)
+         case IRP_MN_START_DEVICE:
+         {
+             BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
++            OBJECT_ATTRIBUTES attr;
+ 
+             rc = minidriver->PNPDispatch(device, irp);
+ 
+             IoSetDeviceInterfaceState(&ext->link_name, TRUE);
+             if (ext->is_mouse)
+                 IoSetDeviceInterfaceState(&ext->mouse_link_name, TRUE);
++
++            attr.Length = sizeof(attr);
++            attr.RootDirectory = 0;
++            attr.Attributes = OBJ_CASE_INSENSITIVE;
++            attr.ObjectName = &ext->link_name;
++            attr.SecurityDescriptor = NULL;
++            attr.SecurityQualityOfService = NULL;
++            NtOpenSymbolicLinkObject(&ext->link_handle, SYMBOLIC_LINK_QUERY, &attr);
++            ext->link_handle = ConvertToGlobalHandle(ext->link_handle);
++
++            if (ext->link_handle == INVALID_HANDLE_VALUE)
++                ERR("Failed to open link %s, error %u.\n", debugstr_w(ext->link_name.Buffer), GetLastError());
++            else
++                TRACE("Opened link handle: %p for %s\n", ext->link_handle, debugstr_w(ext->link_name.Buffer));
++
+             return rc;
+         }
+         case IRP_MN_REMOVE_DEVICE:
+-- 
+2.27.0
+
diff --git a/patches/user32-rawinput-hid/0002-server-Allow-extra-data-for-hardware_msg_data-messag.patch b/patches/user32-rawinput-hid/0002-server-Allow-extra-data-for-hardware_msg_data-messag.patch
deleted file mode 100644
index 476dac09..00000000
--- a/patches/user32-rawinput-hid/0002-server-Allow-extra-data-for-hardware_msg_data-messag.patch
+++ /dev/null
@@ -1,150 +0,0 @@
-From 9aca9116db8ca84eea5be6a67b748ff6fdde9a31 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 19 Sep 2019 09:20:44 +0200
-Subject: [PATCH] server: Allow extra data for hardware_msg_data message.
-
-The RIM_TYPEHID messages will have to carry the variable length HID
-report.
----
- server/queue.c | 43 +++++++++++++++++++++++++++----------------
- 1 file changed, 27 insertions(+), 16 deletions(-)
-
-diff --git a/server/queue.c b/server/queue.c
-index 9dca519cad2..364c8e43485 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -398,13 +398,13 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
- 
- /* allocate a hardware message and its data */
- static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_source source,
--                                               unsigned int time )
-+                                               unsigned int time, data_size_t extra_len )
- {
-     struct hardware_msg_data *msg_data;
-     struct message *msg;
- 
-     if (!(msg = mem_alloc( sizeof(*msg) ))) return NULL;
--    if (!(msg_data = mem_alloc( sizeof(*msg_data) )))
-+    if (!(msg_data = mem_alloc( sizeof(*msg_data) + extra_len )))
-     {
-         free( msg );
-         return NULL;
-@@ -413,9 +413,9 @@ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_sour
-     msg->type      = MSG_HARDWARE;
-     msg->time      = time;
-     msg->data      = msg_data;
--    msg->data_size = sizeof(*msg_data);
-+    msg->data_size = sizeof(*msg_data) + extra_len;
- 
--    memset( msg_data, 0, sizeof(*msg_data) );
-+    memset( msg_data, 0, sizeof(*msg_data) + extra_len );
-     msg_data->info   = info;
-     msg_data->source = source;
-     return msg;
-@@ -448,7 +448,7 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
-         return;
-     }
- 
--    if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
-+    if (!(msg = alloc_hardware_message( 0, source, get_tick_count(), 0 ))) return;
- 
-     msg->msg = WM_MOUSEMOVE;
-     msg->x   = x;
-@@ -1756,6 +1756,8 @@ struct rawinput_message
-     struct hw_msg_source      source;
-     unsigned int              time;
-     struct hardware_msg_data  data;
-+    const void               *extra;
-+    data_size_t               extra_len;
- };
- 
- static int queue_rawinput_message( struct process* process, void* user )
-@@ -1765,6 +1767,7 @@ static int queue_rawinput_message( struct process* process, void* user )
-     struct desktop *desktop = NULL;
-     struct thread *thread = NULL, *foreground = NULL;
-     struct message *msg;
-+    struct hardware_msg_data *msg_data;
- 
-     if (raw_msg->data.rawinput.type == RIM_TYPEMOUSE)
-         device = process->rawinput_mouse;
-@@ -1787,14 +1790,18 @@ static int queue_rawinput_message( struct process* process, void* user )
-         thread->process != foreground->process)
-         goto done;
- 
--    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time )))
-+    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time, raw_msg->extra_len )))
-         goto done;
-+    msg_data = msg->data;
- 
-     msg->win    = device->target;
-     msg->msg    = WM_INPUT;
-     msg->wparam = RIM_INPUT;
-     msg->lparam = 0;
--    memcpy( msg->data, &raw_msg->data, sizeof(raw_msg->data) );
-+
-+    memcpy( msg_data, &raw_msg->data, sizeof(*msg_data) );
-+    if (raw_msg->extra_len && raw_msg->extra)
-+        memcpy( msg_data + 1, raw_msg->extra, raw_msg->extra_len );
- 
-     queue_hardware_message( desktop, msg, 0 );
- 
-@@ -1863,9 +1870,11 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
- 
-     if (req_flags & SEND_HWMSG_RAWINPUT)
-     {
--        raw_msg.desktop = desktop;
--        raw_msg.source  = source;
--        raw_msg.time    = time;
-+        raw_msg.desktop   = desktop;
-+        raw_msg.source    = source;
-+        raw_msg.time      = time;
-+        raw_msg.extra     = NULL;
-+        raw_msg.extra_len = 0;
- 
-         msg_data = &raw_msg.data;
-         msg_data->info                = input->mouse.info;
-@@ -1895,7 +1904,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
-         if (!(flags & (1 << i))) continue;
-         flags &= ~(1 << i);
- 
--        if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
-+        if (!(msg = alloc_hardware_message( input->mouse.info, source, time, 0 ))) return 0;
-         msg_data = msg->data;
- 
-         msg->win       = get_user_full_handle( win );
-@@ -1999,9 +2008,11 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
- 
-     if (req_flags & SEND_HWMSG_RAWINPUT)
-     {
--        raw_msg.desktop = desktop;
--        raw_msg.source  = source;
--        raw_msg.time    = time;
-+        raw_msg.desktop   = desktop;
-+        raw_msg.source    = source;
-+        raw_msg.time      = time;
-+        raw_msg.extra     = NULL;
-+        raw_msg.extra_len = 0;
- 
-         msg_data = &raw_msg.data;
-         msg_data->info                 = input->kbd.info;
-@@ -2022,7 +2033,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
-     if ((device = current->process->rawinput_kbd) && (device->flags & RIDEV_NOLEGACY))
-         return 0;
- 
--    if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
-+    if (!(msg = alloc_hardware_message( input->kbd.info, source, time, 0 ))) return 0;
-     msg_data = msg->data;
- 
-     msg->win       = get_user_full_handle( win );
-@@ -2060,7 +2071,7 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
-     struct hw_msg_source source = { IMDT_UNAVAILABLE, origin };
-     struct message *msg;
- 
--    if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
-+    if (!(msg = alloc_hardware_message( 0, source, get_tick_count(), 0 ))) return;
- 
-     msg->win       = get_user_full_handle( win );
-     msg->msg       = input->hw.msg;
--- 
-2.17.1
-
diff --git a/patches/user32-rawinput-hid/0003-server-Add-HID-input-message-type-to-send_hardware_m.patch b/patches/user32-rawinput-hid/0003-server-Add-HID-input-message-type-to-send_hardware_m.patch
deleted file mode 100644
index 19f6f599..00000000
--- a/patches/user32-rawinput-hid/0003-server-Add-HID-input-message-type-to-send_hardware_m.patch
+++ /dev/null
@@ -1,262 +0,0 @@
-From d0347613c7149144d4339109b641901537c4c326 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Mon, 11 Nov 2019 18:35:18 +0100
-Subject: [PATCH 3/5] server: Add HID input message type to
- send_hardware_message request.
-
----
- dlls/user32/message.c |  4 +++-
- server/protocol.def   | 26 +++++++++++++++++++---
- server/queue.c        | 50 ++++++++++++++++++++++++++++++++++++++-----
- server/trace.c        | 10 ++++++---
- 4 files changed, 78 insertions(+), 12 deletions(-)
-
-diff --git a/dlls/user32/message.c b/dlls/user32/message.c
-index cc25d2f6c2f..55bbe409c9e 100644
---- a/dlls/user32/message.c
-+++ b/dlls/user32/message.c
-@@ -3354,10 +3354,10 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, UINT flags )
-     {
-         req->win        = wine_server_user_handle( hwnd );
-         req->flags      = flags;
--        req->input.type = input->type;
-         switch (input->type)
-         {
-         case INPUT_MOUSE:
-+            req->input.type        = HW_INPUT_MOUSE;
-             req->input.mouse.x     = input->u.mi.dx;
-             req->input.mouse.y     = input->u.mi.dy;
-             req->input.mouse.data  = input->u.mi.mouseData;
-@@ -3366,6 +3366,7 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, UINT flags )
-             req->input.mouse.info  = input->u.mi.dwExtraInfo;
-             break;
-         case INPUT_KEYBOARD:
-+            req->input.type      = HW_INPUT_KEYBOARD;
-             req->input.kbd.vkey  = input->u.ki.wVk;
-             req->input.kbd.scan  = input->u.ki.wScan;
-             req->input.kbd.flags = input->u.ki.dwFlags;
-@@ -3373,6 +3374,7 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, UINT flags )
-             req->input.kbd.info  = input->u.ki.dwExtraInfo;
-             break;
-         case INPUT_HARDWARE:
-+            req->input.type      = HW_INPUT_HARDWARE;
-             req->input.hw.msg    = input->u.hi.uMsg;
-             req->input.hw.lparam = MAKELONG( input->u.hi.wParamL, input->u.hi.wParamH );
-             break;
-diff --git a/server/protocol.def b/server/protocol.def
-index d37dceba40c..85cc2ac6937 100644
---- a/server/protocol.def
-+++ b/server/protocol.def
-@@ -321,6 +321,13 @@ struct hardware_msg_data
-             int            y;       /* y coordinate */
-             unsigned int   data;    /* mouse data */
-         } mouse;
-+        struct
-+        {
-+            int            type;    /* RIM_TYPEHID */
-+            obj_handle_t   device;
-+            unsigned int   length;  /* HID report length */
-+            /* followed by length bytes of HID report data  */
-+        } hid;
-     } rawinput;
- };
- 
-@@ -344,7 +351,7 @@ typedef union
-     int type;
-     struct
-     {
--        int            type;    /* INPUT_KEYBOARD */
-+        int            type;    /* HW_INPUT_KEYBOARD */
-         unsigned short vkey;    /* virtual key code */
-         unsigned short scan;    /* scan code */
-         unsigned int   flags;   /* event flags */
-@@ -353,7 +360,7 @@ typedef union
-     } kbd;
-     struct
-     {
--        int            type;    /* INPUT_MOUSE */
-+        int            type;    /* HW_INPUT_MOUSE */
-         int            x;       /* coordinates */
-         int            y;
-         unsigned int   data;    /* mouse data */
-@@ -363,11 +370,23 @@ typedef union
-     } mouse;
-     struct
-     {
--        int            type;    /* INPUT_HARDWARE */
-+        int            type;    /* HW_INPUT_HARDWARE */
-         unsigned int   msg;     /* message code */
-         lparam_t       lparam;  /* message param */
-     } hw;
-+    struct
-+    {
-+        int            type;    /* HW_INPUT_HID */
-+        obj_handle_t   device;
-+        unsigned char  usage_page;
-+        unsigned char  usage;
-+        unsigned int   length;
-+    } hid;
- } hw_input_t;
-+#define HW_INPUT_MOUSE    0
-+#define HW_INPUT_KEYBOARD 1
-+#define HW_INPUT_HARDWARE 2
-+#define HW_INPUT_HID      3
- 
- typedef union
- {
-@@ -2361,6 +2380,7 @@ enum message_type
-     user_handle_t   win;       /* window handle */
-     hw_input_t      input;     /* input data */
-     unsigned int    flags;     /* flags (see below) */
-+    VARARG(data,bytes);        /* hid report data */
- @REPLY
-     int             wait;      /* do we need to wait for a reply? */
-     int             prev_x;    /* previous cursor position */
-diff --git a/server/queue.c b/server/queue.c
-index feff00e2b9f..85aa896c7bd 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -1698,7 +1698,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
-     struct msg_queue *queue;
-     struct message *msg;
-     timeout_t timeout = 2000 * -10000;  /* FIXME: load from registry */
--    int id = (input->type == INPUT_MOUSE) ? WH_MOUSE_LL : WH_KEYBOARD_LL;
-+    int id = (input->type == HW_INPUT_MOUSE) ? WH_MOUSE_LL : WH_KEYBOARD_LL;
- 
-     if (!(hook_thread = get_first_global_hook( id ))) return 0;
-     if (!(queue = hook_thread->queue)) return 0;
-@@ -1716,7 +1716,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
-     msg->data_size = hardware_msg->data_size;
-     msg->result    = NULL;
- 
--    if (input->type == INPUT_KEYBOARD)
-+    if (input->type == HW_INPUT_KEYBOARD)
-     {
-         unsigned short vkey = input->kbd.vkey;
-         if (input->kbd.flags & KEYEVENTF_UNICODE) vkey = VK_PACKET;
-@@ -1742,6 +1742,8 @@ struct rawinput_message
-     struct desktop           *desktop;
-     struct hw_msg_source      source;
-     unsigned int              time;
-+    unsigned char             usage_page;
-+    unsigned char             usage;
-     struct hardware_msg_data  data;
-     const void               *extra;
-     data_size_t               extra_len;
-@@ -1750,6 +1752,7 @@ struct rawinput_message
- static int queue_rawinput_message( struct process* process, void* user )
- {
-     const struct rawinput_message* raw_msg = user;
-+    const struct rawinput_device_entry *entry;
-     const struct rawinput_device *device = NULL;
-     struct desktop *desktop = NULL;
-     struct thread *thread = NULL, *foreground = NULL;
-@@ -1760,6 +1763,8 @@ static int queue_rawinput_message( struct process* process, void* user )
-         device = process->rawinput_mouse;
-     else if (raw_msg->data.rawinput.type == RIM_TYPEKEYBOARD)
-         device = process->rawinput_kbd;
-+    else if ((entry = find_rawinput_device( process, raw_msg->usage_page, raw_msg->usage )))
-+        device = &entry->device;
- 
-     if (!device)
-         goto done;
-@@ -2067,6 +2072,38 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
-     queue_hardware_message( desktop, msg, 1 );
- }
- 
-+/* queue a hardware message for an hid event */
-+static void queue_hid_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
-+                               unsigned int origin, struct msg_queue *sender, unsigned int req_flags,
-+                               const void *report, data_size_t report_len )
-+{
-+    struct hw_msg_source source = { IMDT_UNAVAILABLE, origin };
-+    struct hardware_msg_data *msg_data;
-+    struct rawinput_message raw_msg;
-+
-+    if (!(req_flags & SEND_HWMSG_RAWINPUT))
-+        return;
-+
-+    raw_msg.desktop    = NULL; /* send to all desktops */
-+    raw_msg.source     = source;
-+    raw_msg.time       = get_tick_count();
-+    raw_msg.usage_page = input->hid.usage_page;
-+    raw_msg.usage      = input->hid.usage;
-+    raw_msg.extra      = report;
-+    raw_msg.extra_len  = report_len;
-+
-+    msg_data = &raw_msg.data;
-+    msg_data->flags               = 0;
-+    msg_data->rawinput.type       = RIM_TYPEHID;
-+    msg_data->rawinput.hid.device = input->hid.device;
-+    msg_data->rawinput.hid.length = report_len;
-+
-+    if (req_flags == SEND_HWMSG_RAWINPUT)
-+        enum_processes( queue_rawinput_message, &raw_msg );
-+    else
-+        queue_rawinput_message( current->process, &raw_msg );
-+}
-+
- /* check message filter for a hardware message */
- static int check_hw_message_filter( user_handle_t win, unsigned int msg_code,
-                                     user_handle_t filter_win, unsigned int first, unsigned int last )
-@@ -2577,15 +2614,18 @@ DECL_HANDLER(send_hardware_message)
- 
-     switch (req->input.type)
-     {
--    case INPUT_MOUSE:
-+    case HW_INPUT_MOUSE:
-         reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
-         break;
--    case INPUT_KEYBOARD:
-+    case HW_INPUT_KEYBOARD:
-         reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
-         break;
--    case INPUT_HARDWARE:
-+    case HW_INPUT_HARDWARE:
-         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
-         break;
-+    case HW_INPUT_HID:
-+        queue_hid_message( desktop, req->win, &req->input, origin, sender, req->flags, get_req_data(), get_req_data_size() );
-+        break;
-     default:
-         set_error( STATUS_INVALID_PARAMETER );
-     }
-diff --git a/server/trace.c b/server/trace.c
-index 18b56c729e4..c39c56087c1 100644
---- a/server/trace.c
-+++ b/server/trace.c
-@@ -381,24 +381,28 @@ static void dump_hw_input( const char *prefix, const hw_input_t *input )
- {
-     switch (input->type)
-     {
--    case INPUT_MOUSE:
-+    case HW_INPUT_MOUSE:
-         fprintf( stderr, "%s{type=MOUSE,x=%d,y=%d,data=%08x,flags=%08x,time=%u",
-                  prefix, input->mouse.x, input->mouse.y, input->mouse.data, input->mouse.flags,
-                  input->mouse.time );
-         dump_uint64( ",info=", &input->mouse.info );
-         fputc( '}', stderr );
-         break;
--    case INPUT_KEYBOARD:
-+    case HW_INPUT_KEYBOARD:
-         fprintf( stderr, "%s{type=KEYBOARD,vkey=%04hx,scan=%04hx,flags=%08x,time=%u",
-                  prefix, input->kbd.vkey, input->kbd.scan, input->kbd.flags, input->kbd.time );
-         dump_uint64( ",info=", &input->kbd.info );
-         fputc( '}', stderr );
-         break;
--    case INPUT_HARDWARE:
-+    case HW_INPUT_HARDWARE:
-         fprintf( stderr, "%s{type=HARDWARE,msg=%04x", prefix, input->hw.msg );
-         dump_uint64( ",lparam=", &input->hw.lparam );
-         fputc( '}', stderr );
-         break;
-+    case HW_INPUT_HID:
-+        fprintf( stderr, "%s{type=HID,device=%04x,usage_page=%02x,usage=%02x,length=%04x}",
-+                 prefix, input->hid.device, input->hid.usage_page, input->hid.usage, input->hid.length );
-+        break;
-     default:
-         fprintf( stderr, "%s{type=%04x}", prefix, input->type );
-         break;
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-hid/0004-user32-Implement-WM_INPUT-RIM_TYPEHID-message-handli.patch b/patches/user32-rawinput-hid/0004-user32-Implement-WM_INPUT-RIM_TYPEHID-message-handli.patch
deleted file mode 100644
index d410a56f..00000000
--- a/patches/user32-rawinput-hid/0004-user32-Implement-WM_INPUT-RIM_TYPEHID-message-handli.patch
+++ /dev/null
@@ -1,138 +0,0 @@
-From a6c66494095012c8a867bf4ee6f44fbebf7bd69a Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 12 Sep 2019 14:48:23 +0200
-Subject: [PATCH] user32: Implement WM_INPUT/RIM_TYPEHID message handling.
-
----
- dlls/user32/message.c      | 19 ++++++++++++++++++-
- dlls/user32/rawinput.c     | 37 +++++++++++++++++++++++++++++++++++++
- dlls/user32/user_private.h |  2 ++
- 3 files changed, 57 insertions(+), 1 deletion(-)
-
-diff --git a/dlls/user32/message.c b/dlls/user32/message.c
-index 8c915629613..5e8ae1e5fb5 100644
---- a/dlls/user32/message.c
-+++ b/dlls/user32/message.c
-@@ -2285,10 +2285,17 @@ static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *
- {
-     struct user_thread_info *thread_info = get_user_thread_info();
-     RAWINPUT *rawinput = thread_info->rawinput;
-+    SIZE_T data_len = 0;
-+
-+    if (msg_data->rawinput.type == RIM_TYPEHID)
-+    {
-+        data_len = msg_data->rawinput.hid.length;
-+        rawinput = thread_info->rawinput = HeapReAlloc( GetProcessHeap(), 0, rawinput, sizeof(*rawinput) + data_len );
-+    }
- 
-     if (!rawinput)
-     {
--        thread_info->rawinput = HeapAlloc( GetProcessHeap(), 0, sizeof(*rawinput) );
-+        thread_info->rawinput = HeapAlloc( GetProcessHeap(), 0, sizeof(*rawinput) + data_len );
-         if (!(rawinput = thread_info->rawinput)) return FALSE;
-     }
- 
-@@ -2383,6 +2390,16 @@ static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *
-         rawinput->data.keyboard.Message          = msg_data->rawinput.kbd.message;
-         rawinput->data.keyboard.ExtraInformation = msg_data->info;
-     }
-+    else if (msg_data->rawinput.type == RIM_TYPEHID)
-+    {
-+        rawinput->header.dwSize  = FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + data_len;
-+        rawinput->header.hDevice = rawinput_handle_from_device_handle(wine_server_ptr_handle(msg_data->rawinput.hid.device));
-+        rawinput->header.wParam  = 0;
-+
-+        rawinput->data.hid.dwSizeHid = data_len;
-+        rawinput->data.hid.dwCount = 1;
-+        memcpy(rawinput->data.hid.bRawData, msg_data + 1, data_len);
-+    }
-     else
-     {
-         FIXME("Unhandled rawinput type %#x.\n", msg_data->rawinput.type);
-diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
-index 0c72b3343ae..5211999e836 100644
---- a/dlls/user32/rawinput.c
-+++ b/dlls/user32/rawinput.c
-@@ -46,6 +46,7 @@ struct device
- {
-     WCHAR *path;
-     HANDLE file;
-+    HANDLE handle;
-     RID_DEVICE_INFO info;
-     PHIDP_PREPARSED_DATA data;
- };
-@@ -62,6 +63,8 @@ static CRITICAL_SECTION_DEBUG rawinput_devices_cs_debug =
- };
- static CRITICAL_SECTION rawinput_devices_cs = { &rawinput_devices_cs_debug, -1, 0, 0, 0, 0 };
- 
-+extern DWORD WINAPI GetFinalPathNameByHandleW(HANDLE file, LPWSTR path, DWORD charcount, DWORD flags);
-+
- static BOOL array_reserve(void **elements, unsigned int *capacity, unsigned int count, unsigned int size)
- {
-     unsigned int new_capacity, max_capacity;
-@@ -143,10 +146,43 @@ static struct device *add_device(HDEVINFO set, SP_DEVICE_INTERFACE_DATA *iface)
-     device->path = path;
-     device->file = file;
-     device->info.cbSize = sizeof(RID_DEVICE_INFO);
-+    device->handle = INVALID_HANDLE_VALUE;
- 
-     return device;
- }
- 
-+HANDLE rawinput_handle_from_device_handle(HANDLE device)
-+{
-+    WCHAR buffer[sizeof(OBJECT_NAME_INFORMATION) + MAX_PATH + 1];
-+    OBJECT_NAME_INFORMATION *info = (OBJECT_NAME_INFORMATION*)&buffer;
-+    ULONG dummy;
-+    unsigned int i;
-+
-+    for (i = 0; i < rawinput_devices_count; ++i)
-+    {
-+        if (rawinput_devices[i].handle == device)
-+            return &rawinput_devices[i];
-+    }
-+
-+    if (NtQueryObject( device, ObjectNameInformation, &buffer, sizeof(buffer) - sizeof(WCHAR), &dummy ) || !info->Name.Buffer)
-+        return NULL;
-+
-+    /* replace \??\ with \\?\ to match hid_devices paths */
-+    if (info->Name.Length > 1 && info->Name.Buffer[0] == '\\' && info->Name.Buffer[1] == '?')
-+        info->Name.Buffer[1] = '\\';
-+
-+    for (i = 0; i < rawinput_devices_count; ++i)
-+    {
-+        if (strcmpW(rawinput_devices[i].path, info->Name.Buffer) == 0)
-+        {
-+            rawinput_devices[i].handle = device;
-+            return &rawinput_devices[i];
-+        }
-+    }
-+
-+    return NULL;
-+}
-+
- static void find_devices(void)
- {
-     static ULONGLONG last_check;
-@@ -438,6 +474,7 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT
-             handle, command, data, data_size);
- 
-     if (!data_size) return ~0U;
-+    if (!device) return ~0U;
- 
-     /* each case below must set:
-      *     *data_size: length (meaning defined by command) of data we want to copy
-diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
-index 5172423280b..4c478db5449 100644
---- a/dlls/user32/user_private.h
-+++ b/dlls/user32/user_private.h
-@@ -375,4 +375,6 @@ static inline WCHAR *heap_strdupW(const WCHAR *src)
-     return dst;
- }
- 
-+extern HANDLE rawinput_handle_from_device_handle(HANDLE device);
-+
- #endif /* __WINE_USER_PRIVATE_H */
--- 
-2.25.1
-
diff --git a/patches/user32-rawinput-hid/0005-hidclass.sys-Send-input-message-to-server-when-HID-r.patch b/patches/user32-rawinput-hid/0005-hidclass.sys-Send-input-message-to-server-when-HID-r.patch
deleted file mode 100644
index 9cb632ef..00000000
--- a/patches/user32-rawinput-hid/0005-hidclass.sys-Send-input-message-to-server-when-HID-r.patch
+++ /dev/null
@@ -1,139 +0,0 @@
-From 249548cff4ae17da6731e28a5fafe277a7b3d6ea Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Wed, 18 Sep 2019 21:04:25 +0200
-Subject: [PATCH 5/5] hidclass.sys: Send input message to server when HID
- report is received.
-
----
- dlls/hidclass.sys/device.c | 30 ++++++++++++++++++++++++++++++
- dlls/hidclass.sys/hid.h    |  1 +
- dlls/hidclass.sys/pnp.c    | 16 ++++++++++++++++
- 3 files changed, 47 insertions(+)
-
-diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
-index 0e905c8322f..369d847e3c1 100644
---- a/dlls/hidclass.sys/device.c
-+++ b/dlls/hidclass.sys/device.c
-@@ -26,9 +26,11 @@
- #include "winuser.h"
- #include "setupapi.h"
- 
-+#include "wine/server.h"
- #include "wine/debug.h"
- #include "ddk/hidsdi.h"
- #include "ddk/hidtypes.h"
-+#include "ddk/ntifs.h"
- #include "ddk/wdm.h"
- 
- #include "initguid.h"
-@@ -123,6 +125,8 @@ NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device)
-         return status;
-     }
- 
-+    ext->link_handle = INVALID_HANDLE_VALUE;
-+
-     /* FIXME: This should probably be done in mouhid.sys. */
-     if (ext->preparseData->caps.UsagePage == HID_USAGE_PAGE_GENERIC
-             && ext->preparseData->caps.Usage == HID_USAGE_GENERIC_MOUSE)
-@@ -207,6 +211,8 @@ void HID_DeleteDevice(DEVICE_OBJECT *device)
-         IoCompleteRequest(irp, IO_NO_INCREMENT);
-     }
- 
-+    CloseHandle(ext->link_handle);
-+
-     TRACE("Delete device(%p) %s\n", device, debugstr_w(ext->device_name));
-     HeapFree(GetProcessHeap(), 0, ext->device_name);
-     RtlFreeUnicodeString(&ext->link_name);
-@@ -241,6 +247,28 @@ static NTSTATUS copy_packet_into_buffer(HID_XFER_PACKET *packet, BYTE* buffer, U
-         return STATUS_BUFFER_OVERFLOW;
- }
- 
-+static void HID_Device_sendRawInput(DEVICE_OBJECT *device, HID_XFER_PACKET *packet)
-+{
-+    BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
-+
-+    if (ext->link_handle == INVALID_HANDLE_VALUE)
-+        return;
-+
-+    SERVER_START_REQ(send_hardware_message)
-+    {
-+        req->win                  = 0;
-+        req->flags                = SEND_HWMSG_RAWINPUT;
-+        req->input.type           = HW_INPUT_HID;
-+        req->input.hid.device     = wine_server_obj_handle(ext->link_handle);
-+        req->input.hid.usage_page = ext->preparseData->caps.UsagePage;
-+        req->input.hid.usage      = ext->preparseData->caps.Usage;
-+        req->input.hid.length     = packet->reportBufferLen;
-+        wine_server_add_data(req, packet->reportBuffer, packet->reportBufferLen);
-+        wine_server_call(req);
-+    }
-+    SERVER_END_REQ;
-+}
-+
- static void HID_Device_processQueue(DEVICE_OBJECT *device)
- {
-     IRP *irp;
-@@ -324,6 +352,7 @@ static DWORD CALLBACK hid_device_thread(void *args)
-             if (irp->IoStatus.u.Status == STATUS_SUCCESS)
-             {
-                 RingBuffer_Write(ext->ring_buffer, packet);
-+                HID_Device_sendRawInput(device, packet);
-                 HID_Device_processQueue(device);
-             }
- 
-@@ -370,6 +399,7 @@ static DWORD CALLBACK hid_device_thread(void *args)
-                 else
-                     packet->reportId = 0;
-                 RingBuffer_Write(ext->ring_buffer, packet);
-+                HID_Device_sendRawInput(device, packet);
-                 HID_Device_processQueue(device);
-             }
- 
-diff --git a/dlls/hidclass.sys/hid.h b/dlls/hidclass.sys/hid.h
-index 36d13c009d7..f12e04d7898 100644
---- a/dlls/hidclass.sys/hid.h
-+++ b/dlls/hidclass.sys/hid.h
-@@ -46,6 +46,7 @@ typedef struct _BASE_DEVICE_EXTENSION {
-     ULONG poll_interval;
-     WCHAR *device_name;
-     UNICODE_STRING link_name;
-+    HANDLE link_handle;
-     WCHAR device_id[MAX_DEVICE_ID_LEN];
-     WCHAR instance_id[MAX_DEVICE_ID_LEN];
-     struct ReportRingBuffer *ring_buffer;
-diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
-index 1c130e8dd80..b84a358dba4 100644
---- a/dlls/hidclass.sys/pnp.c
-+++ b/dlls/hidclass.sys/pnp.c
-@@ -299,12 +299,28 @@ NTSTATUS WINAPI HID_PNP_Dispatch(DEVICE_OBJECT *device, IRP *irp)
-         case IRP_MN_START_DEVICE:
-         {
-             BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
-+            OBJECT_ATTRIBUTES attr;
- 
-             rc = minidriver->PNPDispatch(device, irp);
- 
-             IoSetDeviceInterfaceState(&ext->link_name, TRUE);
-             if (ext->is_mouse)
-                 IoSetDeviceInterfaceState(&ext->mouse_link_name, TRUE);
-+
-+            attr.Length = sizeof(attr);
-+            attr.RootDirectory = 0;
-+            attr.Attributes = OBJ_CASE_INSENSITIVE;
-+            attr.ObjectName = &ext->link_name;
-+            attr.SecurityDescriptor = NULL;
-+            attr.SecurityQualityOfService = NULL;
-+            NtOpenSymbolicLinkObject(&ext->link_handle, SYMBOLIC_LINK_QUERY, &attr);
-+            ext->link_handle = ConvertToGlobalHandle(ext->link_handle);
-+
-+            if (ext->link_handle == INVALID_HANDLE_VALUE)
-+                ERR("Failed to open link %s, error %u.\n", debugstr_w(ext->link_name.Buffer), GetLastError());
-+            else
-+                TRACE("Opened link handle: %p for %s\n", ext->link_handle, debugstr_w(ext->link_name.Buffer));
-+
-             return rc;
-         }
-         case IRP_MN_REMOVE_DEVICE:
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-hid/definition b/patches/user32-rawinput-hid/definition
index 8b4477ab..a160c918 100644
--- a/patches/user32-rawinput-hid/definition
+++ b/patches/user32-rawinput-hid/definition
@@ -1,2 +1 @@
-Depends: user32-rawinput-nolegacy
-Disabled: true
+Disabled: false
diff --git a/patches/user32-rawinput-keyboard/definition b/patches/user32-rawinput-keyboard/definition
index 3041bdd8..37309863 100644
--- a/patches/user32-rawinput-keyboard/definition
+++ b/patches/user32-rawinput-keyboard/definition
@@ -1,3 +1,3 @@
 Fixes: [35128] Air Conflicts (Pacific Carriers/Secret Wars) hangs at the loading screen (needs support for raw input in DInput8 keyboard)
 Depends: user32-rawinput-hid
-Disabled: True
+Disabled: false
diff --git a/patches/user32-rawinput-mouse-experimental/0001-winex11.drv-Add-support-for-absolute-RawMotion-event.patch b/patches/user32-rawinput-mouse-experimental/0001-user32-rawinput-mouse-experimental.patch
similarity index 52%
rename from patches/user32-rawinput-mouse-experimental/0001-winex11.drv-Add-support-for-absolute-RawMotion-event.patch
rename to patches/user32-rawinput-mouse-experimental/0001-user32-rawinput-mouse-experimental.patch
index 2f8583d5..68717871 100644
--- a/patches/user32-rawinput-mouse-experimental/0001-winex11.drv-Add-support-for-absolute-RawMotion-event.patch
+++ b/patches/user32-rawinput-mouse-experimental/0001-user32-rawinput-mouse-experimental.patch
@@ -1,7 +1,7 @@
-From c227552d313a51f625b741c330ce4509dff99cb5 Mon Sep 17 00:00:00 2001
+From 177a7fb4854f2639e65be6fec1df4d1ab16aa7ef Mon Sep 17 00:00:00 2001
 From: Derek Lesho <dereklesho52@Gmail.com>
 Date: Tue, 25 Jun 2019 22:37:34 -0400
-Subject: [PATCH 1/4] winex11.drv: Add support for absolute RawMotion events.
+Subject: [PATCH 1/3] winex11.drv: Add support for absolute RawMotion events.
 
 When running Xwayland, or using pointing devices, the valuators may
 provide absolute values only. In which case, we should translate the
@@ -18,18 +18,18 @@ example - while their axis valuators keep their "Abs X/Y" name. We can
 however use the valuator mode to distinguish between relative movements
 and absolute position events.
 ---
- dlls/user32/message.c          |  7 ++-
+ dlls/user32/rawinput.c         |  7 ++-
  dlls/winex11.drv/mouse.c       | 96 +++++++++++++++++++++-------------
  dlls/winex11.drv/x11drv.h      | 18 +++----
  dlls/winex11.drv/x11drv_main.c |  2 +
  server/queue.c                 |  4 +-
  5 files changed, 79 insertions(+), 48 deletions(-)
 
-diff --git a/dlls/user32/message.c b/dlls/user32/message.c
-index cc25d2f6c2f..26c3aa91421 100644
---- a/dlls/user32/message.c
-+++ b/dlls/user32/message.c
-@@ -2311,7 +2311,12 @@ static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *
+diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
+index 90dc911397d..d6dc377ddc3 100644
+--- a/dlls/user32/rawinput.c
++++ b/dlls/user32/rawinput.c
+@@ -289,7 +289,12 @@ BOOL rawinput_from_hardware_message(RAWINPUT *rawinput, const struct hardware_ms
          rawinput->header.hDevice = WINE_MOUSE_HANDLE;
          rawinput->header.wParam  = 0;
  
@@ -44,10 +44,10 @@ index cc25d2f6c2f..26c3aa91421 100644
          rawinput->data.mouse.u.s.usButtonData  = 0;
          for (i = 1; i < ARRAY_SIZE(button_flags); ++i)
 diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index d331ed5aef8..3474a176003 100644
+index ded877a140f..84a47f1e522 100644
 --- a/dlls/winex11.drv/mouse.c
 +++ b/dlls/winex11.drv/mouse.c
-@@ -333,32 +333,40 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
+@@ -331,32 +331,40 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
      struct x11drv_thread_data *thread_data = x11drv_thread_data();
      int i;
  
@@ -106,7 +106,7 @@ index d331ed5aef8..3474a176003 100644
  }
  #endif
  
-@@ -443,8 +451,8 @@ void X11DRV_XInput2_Disable(void)
+@@ -441,8 +449,8 @@ void X11DRV_XInput2_Disable(void)
      mask.deviceid = XIAllMasterDevices;
  
      pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
@@ -117,7 +117,7 @@ index d331ed5aef8..3474a176003 100644
      data->xi2_core_pointer = 0;
  #endif
  }
-@@ -1895,16 +1903,22 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+@@ -1893,16 +1901,22 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
      INPUT input;
      int i;
      double dx = 0, dy = 0, val;
@@ -144,7 +144,7 @@ index d331ed5aef8..3474a176003 100644
  
      input.type             = INPUT_MOUSE;
      input.u.mi.mouseData   = 0;
-@@ -1915,24 +1929,34 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+@@ -1913,24 +1927,34 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
      input.u.mi.dy          = 0;
  
      virtual_rect = get_virtual_screen_rect();
@@ -192,7 +192,7 @@ index d331ed5aef8..3474a176003 100644
      }
  
 diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
-index 4a7cab67ada..c4218699034 100644
+index 6febdc18b0a..396056464a7 100644
 --- a/dlls/winex11.drv/x11drv.h
 +++ b/dlls/winex11.drv/x11drv.h
 @@ -32,6 +32,9 @@
@@ -219,7 +219,7 @@ index 4a7cab67ada..c4218699034 100644
  struct x11drv_thread_data
  {
      Display *display;
-@@ -341,11 +337,13 @@ struct x11drv_thread_data
+@@ -340,11 +336,13 @@ struct x11drv_thread_data
      HWND     clip_hwnd;            /* message window stored in desktop while clipping is active */
      DWORD    clip_reset;           /* time when clipping was last reset */
      HKL      kbd_layout;           /* active keyboard layout */
@@ -235,7 +235,7 @@ index 4a7cab67ada..c4218699034 100644
  };
  
  extern struct x11drv_thread_data *x11drv_init_thread_data(void) DECLSPEC_HIDDEN;
-@@ -431,6 +429,8 @@ enum x11drv_atoms
+@@ -429,6 +427,8 @@ enum x11drv_atoms
      XATOM_RAW_CAP_HEIGHT,
      XATOM_Rel_X,
      XATOM_Rel_Y,
@@ -245,10 +245,10 @@ index 4a7cab67ada..c4218699034 100644
      XATOM_WM_DELETE_WINDOW,
      XATOM_WM_STATE,
 diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
-index f33a79d98bf..3e8dd82654a 100644
+index 4eaedd1c556..f08ac92e36f 100644
 --- a/dlls/winex11.drv/x11drv_main.c
 +++ b/dlls/winex11.drv/x11drv_main.c
-@@ -144,6 +144,8 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
+@@ -142,6 +142,8 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
      "RAW_CAP_HEIGHT",
      "Rel X",
      "Rel Y",
@@ -258,10 +258,10 @@ index f33a79d98bf..3e8dd82654a 100644
      "WM_DELETE_WINDOW",
      "WM_STATE",
 diff --git a/server/queue.c b/server/queue.c
-index f5dc06100d1..b369f0cdb78 100644
+index fbed47d6951..161b48e888f 100644
 --- a/server/queue.c
 +++ b/server/queue.c
-@@ -1858,8 +1858,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
+@@ -1783,8 +1783,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
          msg_data->info                = input->mouse.info;
          msg_data->flags               = flags;
          msg_data->rawinput.type       = RIM_TYPEMOUSE;
@@ -271,7 +271,210 @@ index f5dc06100d1..b369f0cdb78 100644
 +        msg_data->rawinput.mouse.y    = input->mouse.y;
          msg_data->rawinput.mouse.data = input->mouse.data;
  
-         if (req_flags == SEND_HWMSG_RAWINPUT)
+         if ((req_flags & SEND_HWMSG_RAWINPUT))
 -- 
-2.24.1
+2.27.0
+
+From 59e086ac5c54705fa163889160f6462434e90e56 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Tue, 10 Sep 2019 12:24:22 +0200
+Subject: [PATCH 2/3] winex11.drv: Send relative RawMotion events unprocessed.
+
+This makes relative raw input independent from cursor speed, as it is
+the case on Windows. Absolute raw input is already translated to
+virtual desktop space, and cursor speed is meaningless in this case.
+
+This does not support mixed relative/absolute X/Y axis.
+---
+ dlls/winex11.drv/mouse.c | 19 +++++++++++++------
+ 1 file changed, 13 insertions(+), 6 deletions(-)
+
+diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
+index 84a47f1e522..2fcacaee95c 100644
+--- a/dlls/winex11.drv/mouse.c
++++ b/dlls/winex11.drv/mouse.c
+@@ -1897,20 +1897,17 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+ {
+     XIRawEvent *event = xev->data;
+     const double *values = event->valuators.values;
++    const double *raw_values = event->raw_values;
+     RECT virtual_rect;
+     INPUT input;
+     int i;
+     double dx = 0, dy = 0, val;
++    double raw_dx = 0, raw_dy = 0, raw_val;
+     double x_scale = 1, y_scale = 1;
+     struct x11drv_thread_data *thread_data = x11drv_thread_data();
+     XIValuatorClassInfo *x_pos, *y_pos;
+ 
+     if (thread_data->x_pos_valuator.number < 0 || thread_data->y_pos_valuator.number < 0) return FALSE;
+-    if (thread_data->x_pos_valuator.mode != thread_data->y_pos_valuator.mode)
+-    {
+-        FIXME("Unsupported relative/absolute X/Y axis mismatch\n.");
+-        return FALSE;
+-    }
+     if (!event->valuators.mask_len) return FALSE;
+     if (thread_data->xi2_state != xi_enabled) return FALSE;
+     if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
+@@ -1938,9 +1935,11 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     {
+         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
+         val = *values++;
++        raw_val = *raw_values++;
+         if (i == x_pos->number)
+         {
+             dx = val;
++            raw_dx = raw_val;
+             input.u.mi.dwFlags |= (x_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
+             if (x_pos->mode == XIModeAbsolute)
+                 input.u.mi.dx = (dx - x_pos->min) * x_scale;
+@@ -1950,6 +1949,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+         if (i == y_pos->number)
+         {
+             dy = val;
++            raw_dy = raw_val;
+             input.u.mi.dwFlags |= (y_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
+             if (y_pos->mode == XIModeAbsolute)
+                 input.u.mi.dy = (dy - y_pos->min) * y_scale;
+@@ -1964,13 +1964,20 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+         return FALSE;
+     }
+ 
+-    if (!thread_data->xi2_rawinput_only)
++    if (x_pos->mode == XIModeAbsolute)
++    {
++        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
++        __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
++    }
++    else if (!thread_data->xi2_rawinput_only)
+     {
+         TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+         __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
+     }
+     else
+     {
++        input.u.mi.dx = raw_dx;
++        input.u.mi.dy = raw_dy;
+         TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+         __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
+     }
+-- 
+2.27.0
+
+From 52877cb446b6761633a7f58bb7fc9d11d35cde8f Mon Sep 17 00:00:00 2001
+From: Jordan Galby <gravemind2a+wine@gmail.com>
+Date: Tue, 16 Jul 2019 00:34:38 -0400
+Subject: [PATCH 3/3] winex11.drv: Accumulate mouse movement to avoid rounding
+ losses.
+
+Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=42631
+From: Jordan Galby <gravemind2a+wine@gmail.com>
+---
+ dlls/winex11.drv/mouse.c | 40 +++++++++++++++++++++++++++++++++-------
+ 1 file changed, 33 insertions(+), 7 deletions(-)
+
+diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
+index 2fcacaee95c..e3c5f8d122e 100644
+--- a/dlls/winex11.drv/mouse.c
++++ b/dlls/winex11.drv/mouse.c
+@@ -365,6 +365,9 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
+         thread_data->x_pos_valuator.min = thread_data->x_pos_valuator.max = 0;
+     if (thread_data->y_pos_valuator.min >= thread_data->y_pos_valuator.max)
+         thread_data->y_pos_valuator.min = thread_data->y_pos_valuator.max = 0;
++
++    thread_data->x_pos_valuator.value = 0;
++    thread_data->y_pos_valuator.value = 0;
+ }
+ #endif
+ 
+@@ -1904,6 +1907,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     double dx = 0, dy = 0, val;
+     double raw_dx = 0, raw_dy = 0, raw_val;
+     double x_scale = 1, y_scale = 1;
++    double x_accum = 0, y_accum = 0;
+     struct x11drv_thread_data *thread_data = x11drv_thread_data();
+     XIValuatorClassInfo *x_pos, *y_pos;
+ 
+@@ -1915,6 +1919,9 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     x_pos = &thread_data->x_pos_valuator;
+     y_pos = &thread_data->y_pos_valuator;
+ 
++    x_accum = x_pos->value;
++    y_accum = y_pos->value;
++
+     input.type             = INPUT_MOUSE;
+     input.u.mi.mouseData   = 0;
+     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
+@@ -1942,9 +1949,9 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+             raw_dx = raw_val;
+             input.u.mi.dwFlags |= (x_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
+             if (x_pos->mode == XIModeAbsolute)
+-                input.u.mi.dx = (dx - x_pos->min) * x_scale;
++                x_accum = (dx - x_pos->min) * x_scale;
+             else
+-                input.u.mi.dx = dx * x_scale;
++                x_accum += dx * x_scale;
+         }
+         if (i == y_pos->number)
+         {
+@@ -1952,18 +1959,30 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+             raw_dy = raw_val;
+             input.u.mi.dwFlags |= (y_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
+             if (y_pos->mode == XIModeAbsolute)
+-                input.u.mi.dy = (dy - y_pos->min) * y_scale;
++                y_accum = (dy - y_pos->min) * y_scale;
+             else
+-                input.u.mi.dy = dy * y_scale;
++                y_accum += dy * y_scale;
+         }
+     }
+ 
++    /* Accumulate the fractional parts so they aren't lost after casting
++     * successive motion values to integral fields.
++     *
++     * Note: It looks like raw_dx, raw_dy are already
++     * integral values but that may be wrong.
++     */
++    input.u.mi.dx = (LONG)x_accum;
++    input.u.mi.dy = (LONG)y_accum;
++
+     if (broken_rawevents && is_old_motion_event( xev->serial ))
+     {
+         TRACE( "pos %d,%d old serial %lu, ignoring\n", input.u.mi.dx, input.u.mi.dy, xev->serial );
+         return FALSE;
+     }
+ 
++    x_pos->value = x_accum - input.u.mi.dx;
++    y_pos->value = y_accum - input.u.mi.dy;
++
+     if (x_pos->mode == XIModeAbsolute)
+     {
+         TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+@@ -1971,14 +1990,21 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     }
+     else if (!thread_data->xi2_rawinput_only)
+     {
+-        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+-        __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
++        if ((dy || dy) && !(input.u.mi.dx || input.u.mi.dy))
++        {
++            TRACE( "accumulating raw motion (event %f,%f accum %f,%f)\n", dx, dy, x_pos->value, y_pos->value );
++        }
++        else
++        {
++            TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
++            __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
++        }
+     }
+     else
+     {
+         input.u.mi.dx = raw_dx;
+         input.u.mi.dy = raw_dy;
+-        TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
++        TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, raw_dx, raw_dy );
+         __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
+     }
+     return TRUE;
+-- 
+2.27.0
 
diff --git a/patches/user32-rawinput-mouse-experimental/0002-winex11.drv-Send-relative-RawMotion-events-unprocess.patch b/patches/user32-rawinput-mouse-experimental/0002-winex11.drv-Send-relative-RawMotion-events-unprocess.patch
deleted file mode 100644
index 5a7f3667..00000000
--- a/patches/user32-rawinput-mouse-experimental/0002-winex11.drv-Send-relative-RawMotion-events-unprocess.patch
+++ /dev/null
@@ -1,86 +0,0 @@
-From 108f1467e2d2712b5fb8956e69d481a033cbcbfe Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Tue, 10 Sep 2019 12:24:22 +0200
-Subject: [PATCH 2/4] winex11.drv: Send relative RawMotion events unprocessed.
-
-This makes relative raw input independent from cursor speed, as it is
-the case on Windows. Absolute raw input is already translated to
-virtual desktop space, and cursor speed is meaningless in this case.
-
-This does not support mixed relative/absolute X/Y axis.
----
- dlls/winex11.drv/mouse.c | 19 +++++++++++++------
- 1 file changed, 13 insertions(+), 6 deletions(-)
-
-diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index 3474a176003..a2310297ff9 100644
---- a/dlls/winex11.drv/mouse.c
-+++ b/dlls/winex11.drv/mouse.c
-@@ -1899,20 +1899,17 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
- {
-     XIRawEvent *event = xev->data;
-     const double *values = event->valuators.values;
-+    const double *raw_values = event->raw_values;
-     RECT virtual_rect;
-     INPUT input;
-     int i;
-     double dx = 0, dy = 0, val;
-+    double raw_dx = 0, raw_dy = 0, raw_val;
-     double x_scale = 1, y_scale = 1;
-     struct x11drv_thread_data *thread_data = x11drv_thread_data();
-     XIValuatorClassInfo *x_pos, *y_pos;
- 
-     if (thread_data->x_pos_valuator.number < 0 || thread_data->y_pos_valuator.number < 0) return FALSE;
--    if (thread_data->x_pos_valuator.mode != thread_data->y_pos_valuator.mode)
--    {
--        FIXME("Unsupported relative/absolute X/Y axis mismatch\n.");
--        return FALSE;
--    }
-     if (!event->valuators.mask_len) return FALSE;
-     if (thread_data->xi2_state != xi_enabled) return FALSE;
-     if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
-@@ -1940,9 +1937,11 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     {
-         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
-         val = *values++;
-+        raw_val = *raw_values++;
-         if (i == x_pos->number)
-         {
-             dx = val;
-+            raw_dx = raw_val;
-             input.u.mi.dwFlags |= (x_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
-             if (x_pos->mode == XIModeAbsolute)
-                 input.u.mi.dx = (dx - x_pos->min) * x_scale;
-@@ -1952,6 +1951,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-         if (i == y_pos->number)
-         {
-             dy = val;
-+            raw_dy = raw_val;
-             input.u.mi.dwFlags |= (y_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
-             if (y_pos->mode == XIModeAbsolute)
-                 input.u.mi.dy = (dy - y_pos->min) * y_scale;
-@@ -1966,13 +1966,20 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-         return FALSE;
-     }
- 
--    if (!thread_data->xi2_rawinput_only)
-+    if (x_pos->mode == XIModeAbsolute)
-+    {
-+        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-+        __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
-+    }
-+    else if (!thread_data->xi2_rawinput_only)
-     {
-         TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-         __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
-     }
-     else
-     {
-+        input.u.mi.dx = raw_dx;
-+        input.u.mi.dy = raw_dy;
-         TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-         __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
-     }
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-mouse-experimental/0003-winex11.drv-Accumulate-mouse-movement-to-avoid-round.patch b/patches/user32-rawinput-mouse-experimental/0003-winex11.drv-Accumulate-mouse-movement-to-avoid-round.patch
deleted file mode 100644
index 2864baaf..00000000
--- a/patches/user32-rawinput-mouse-experimental/0003-winex11.drv-Accumulate-mouse-movement-to-avoid-round.patch
+++ /dev/null
@@ -1,117 +0,0 @@
-From e53124abe8f6eaeebdb8ccb75cd884543f63a996 Mon Sep 17 00:00:00 2001
-From: Jordan Galby <gravemind2a+wine@gmail.com>
-Date: Tue, 16 Jul 2019 00:34:38 -0400
-Subject: [PATCH 3/3] winex11.drv: Accumulate mouse movement to avoid rounding
- losses.
-
-Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=42631
-From: Jordan Galby <gravemind2a+wine@gmail.com>
----
- dlls/winex11.drv/mouse.c | 40 +++++++++++++++++++++++++++++++++-------
- 1 file changed, 33 insertions(+), 7 deletions(-)
-
-diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index a2310297ff9..e1273571fe2 100644
---- a/dlls/winex11.drv/mouse.c
-+++ b/dlls/winex11.drv/mouse.c
-@@ -367,6 +367,9 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
-         thread_data->x_pos_valuator.min = thread_data->x_pos_valuator.max = 0;
-     if (thread_data->y_pos_valuator.min >= thread_data->y_pos_valuator.max)
-         thread_data->y_pos_valuator.min = thread_data->y_pos_valuator.max = 0;
-+
-+    thread_data->x_pos_valuator.value = 0;
-+    thread_data->y_pos_valuator.value = 0;
- }
- #endif
- 
-@@ -1906,6 +1909,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     double dx = 0, dy = 0, val;
-     double raw_dx = 0, raw_dy = 0, raw_val;
-     double x_scale = 1, y_scale = 1;
-+    double x_accum = 0, y_accum = 0;
-     struct x11drv_thread_data *thread_data = x11drv_thread_data();
-     XIValuatorClassInfo *x_pos, *y_pos;
- 
-@@ -1917,6 +1921,9 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     x_pos = &thread_data->x_pos_valuator;
-     y_pos = &thread_data->y_pos_valuator;
- 
-+    x_accum = x_pos->value;
-+    y_accum = y_pos->value;
-+
-     input.type             = INPUT_MOUSE;
-     input.u.mi.mouseData   = 0;
-     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
-@@ -1944,9 +1951,9 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-             raw_dx = raw_val;
-             input.u.mi.dwFlags |= (x_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
-             if (x_pos->mode == XIModeAbsolute)
--                input.u.mi.dx = (dx - x_pos->min) * x_scale;
-+                x_accum = (dx - x_pos->min) * x_scale;
-             else
--                input.u.mi.dx = dx * x_scale;
-+                x_accum += dx * x_scale;
-         }
-         if (i == y_pos->number)
-         {
-@@ -1954,18 +1961,30 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-             raw_dy = raw_val;
-             input.u.mi.dwFlags |= (y_pos->mode == XIModeAbsolute ? MOUSEEVENTF_ABSOLUTE : 0);
-             if (y_pos->mode == XIModeAbsolute)
--                input.u.mi.dy = (dy - y_pos->min) * y_scale;
-+                y_accum = (dy - y_pos->min) * y_scale;
-             else
--                input.u.mi.dy = dy * y_scale;
-+                y_accum += dy * y_scale;
-         }
-     }
- 
-+    /* Accumulate the fractional parts so they aren't lost after casting
-+     * successive motion values to integral fields.
-+     *
-+     * Note: It looks like raw_dx, raw_dy are already
-+     * integral values but that may be wrong.
-+     */
-+    input.u.mi.dx = (LONG)x_accum;
-+    input.u.mi.dy = (LONG)y_accum;
-+
-     if (broken_rawevents && is_old_motion_event( xev->serial ))
-     {
-         TRACE( "pos %d,%d old serial %lu, ignoring\n", input.u.mi.dx, input.u.mi.dy, xev->serial );
-         return FALSE;
-     }
- 
-+    x_pos->value = x_accum - input.u.mi.dx;
-+    y_pos->value = y_accum - input.u.mi.dy;
-+
-     if (x_pos->mode == XIModeAbsolute)
-     {
-         TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-@@ -1973,14 +1992,21 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     }
-     else if (!thread_data->xi2_rawinput_only)
-     {
--        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
--        __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
-+        if ((dy || dy) && !(input.u.mi.dx || input.u.mi.dy))
-+        {
-+            TRACE( "accumulating raw motion (event %f,%f accum %f,%f)\n", dx, dy, x_pos->value, y_pos->value );
-+        }
-+        else
-+        {
-+            TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-+            __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
-+        }
-     }
-     else
-     {
-         input.u.mi.dx = raw_dx;
-         input.u.mi.dy = raw_dy;
--        TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-+        TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, raw_dx, raw_dy );
-         __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
-     }
-     return TRUE;
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-mouse-experimental/definition b/patches/user32-rawinput-mouse-experimental/definition
index bf45b339..7ea01d04 100644
--- a/patches/user32-rawinput-mouse-experimental/definition
+++ b/patches/user32-rawinput-mouse-experimental/definition
@@ -1,3 +1,2 @@
 Fixes: [45882] - Raw Input should use untransformed mouse values (affects Overwatch, several Source games).
-Depends: user32-rawinput-nolegacy
-Disabled: True
+Disabled: false
diff --git a/patches/user32-rawinput-mouse/0001-user32-rawinput-mouse.patch b/patches/user32-rawinput-mouse/0001-user32-rawinput-mouse.patch
new file mode 100644
index 00000000..635551b1
--- /dev/null
+++ b/patches/user32-rawinput-mouse/0001-user32-rawinput-mouse.patch
@@ -0,0 +1,1684 @@
+From 6c0ff19096fc4d23f8e2128dd5ca9fd61770d0b2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 26 Aug 2019 16:06:58 +0200
+Subject: [PATCH 01/10] user32: Implement GetRegisteredRawInputDevices.
+
+---
+ dlls/dinput8/tests/device.c | 13 ---------
+ dlls/user32/rawinput.c      | 55 +++++++++++++++++++++++++++++++++++--
+ server/protocol.def         |  6 ++++
+ server/queue.c              | 24 ++++++++++++++++
+ 4 files changed, 83 insertions(+), 15 deletions(-)
+
+diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
+index 39c635f2fb9..328174e5796 100644
+--- a/dlls/dinput8/tests/device.c
++++ b/dlls/dinput8/tests/device.c
+@@ -602,7 +602,6 @@ static void test_mouse_keyboard(void)
+ 
+     raw_devices_count = ARRAY_SIZE(raw_devices);
+     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+-    todo_wine
+     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
+ 
+     hr = IDirectInputDevice8_Acquire(di_keyboard);
+@@ -624,7 +623,6 @@ static void test_mouse_keyboard(void)
+     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
+     raw_devices_count = ARRAY_SIZE(raw_devices);
+     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+-    todo_wine
+     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
+ 
+     if (raw_devices[0].hwndTarget != NULL)
+@@ -662,7 +660,6 @@ static void test_mouse_keyboard(void)
+     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
+     raw_devices_count = ARRAY_SIZE(raw_devices);
+     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+-    todo_wine
+     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
+ 
+     /* expect dinput8 to take over any activated raw input devices */
+@@ -689,26 +686,18 @@ static void test_mouse_keyboard(void)
+     raw_devices_count = ARRAY_SIZE(raw_devices);
+     memset(raw_devices, 0, sizeof(raw_devices));
+     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+-    todo_wine
+     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+-    todo_wine
+     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+-    todo_wine
+     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+     todo_wine
+     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+     todo_wine
+     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
+-    todo_wine
+     ok(raw_devices[1].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
+-    todo_wine
+     ok(raw_devices[1].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
+     ok(raw_devices[1].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
+-    todo_wine
+     ok(raw_devices[1].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[1].hwndTarget);
+-    todo_wine
+     ok(raw_devices[2].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
+-    todo_wine
+     ok(raw_devices[2].usUsage == 6, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
+     todo_wine
+     ok(raw_devices[2].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
+@@ -727,12 +716,10 @@ static void test_mouse_keyboard(void)
+     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+     todo_wine
+     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+-    todo_wine
+     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+     todo_wine
+     ok(raw_devices[0].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+     ok(raw_devices[0].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+-    todo_wine
+     ok(raw_devices[0].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
+ 
+     IDirectInputDevice8_Release(di_mouse);
+diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
+index b5af008e885..43da5248faf 100644
+--- a/dlls/user32/rawinput.c
++++ b/dlls/user32/rawinput.c
+@@ -732,14 +732,65 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT
+     return *data_size;
+ }
+ 
++static int compare_raw_input_devices(const void *ap, const void *bp)
++{
++    const RAWINPUTDEVICE a = *(const RAWINPUTDEVICE *)ap;
++    const RAWINPUTDEVICE b = *(const RAWINPUTDEVICE *)bp;
++
++    if (a.usUsagePage != b.usUsagePage) return a.usUsagePage - b.usUsagePage;
++    if (a.usUsage != b.usUsage) return a.usUsage - b.usUsage;
++    return 0;
++}
++
+ /***********************************************************************
+  *              GetRegisteredRawInputDevices   (USER32.@)
+  */
+ UINT WINAPI DECLSPEC_HOTPATCH GetRegisteredRawInputDevices(RAWINPUTDEVICE *devices, UINT *device_count, UINT size)
+ {
+-    FIXME("devices %p, device_count %p, size %u stub!\n", devices, device_count, size);
++    struct rawinput_device *d = NULL;
++    unsigned int count = ~0U;
+ 
+-    return 0;
++    TRACE("devices %p, device_count %p, size %u\n", devices, device_count, size);
++
++    if (!device_count)
++    {
++        SetLastError(ERROR_INVALID_PARAMETER);
++        return ~0U;
++    }
++
++    if (devices && !(d = HeapAlloc( GetProcessHeap(), 0, *device_count * sizeof(*d) )))
++        return ~0U;
++
++    SERVER_START_REQ( get_rawinput_devices )
++    {
++        if (d)
++            wine_server_set_reply( req, d, *device_count * sizeof(*d) );
++
++        if (wine_server_call( req ))
++            goto done;
++
++        if (!d || reply->device_count > *device_count)
++        {
++            *device_count = reply->device_count;
++            SetLastError( ERROR_INSUFFICIENT_BUFFER );
++            goto done;
++        }
++
++        for (count = 0; count < reply->device_count; ++count)
++        {
++            devices[count].usUsagePage = d[count].usage_page;
++            devices[count].usUsage = d[count].usage;
++            devices[count].dwFlags = d[count].flags;
++            devices[count].hwndTarget = wine_server_ptr_handle(d[count].target);
++        }
++    }
++    SERVER_END_REQ;
++
++    qsort(devices, count, sizeof(*devices), compare_raw_input_devices);
++
++done:
++    if (d) HeapFree( GetProcessHeap(), 0, d );
++    return count;
+ }
+ 
+ 
+diff --git a/server/protocol.def b/server/protocol.def
+index d1f20497e1d..2e9ea6e5746 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -3895,6 +3895,12 @@ struct handle_info
+     VARARG(devices,rawinput_devices);
+ @END
+ 
++/* Retrieve the list of registered rawinput devices */
++@REQ(get_rawinput_devices)
++@REPLY
++    unsigned int device_count;
++    VARARG(devices,rawinput_devices);
++@END
+ 
+ /* Create a new job object */
+ @REQ(create_job)
+diff --git a/server/queue.c b/server/queue.c
+index 432885f9e4c..ff9e703d1ff 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -3283,3 +3283,27 @@ DECL_HANDLER(update_rawinput_devices)
+     e = find_rawinput_device( 1, 6 );
+     current->process->rawinput_kbd   = e ? &e->device : NULL;
+ }
++
++DECL_HANDLER(get_rawinput_devices)
++{
++    unsigned int device_count = list_count(&current->process->rawinput_devices);
++    struct rawinput_device *devices;
++    struct rawinput_device_entry *e;
++    unsigned int i;
++
++    reply->device_count = device_count;
++    if (get_reply_max_size() / sizeof (*devices) < device_count)
++        return;
++
++    if (!(devices = mem_alloc( device_count * sizeof (*devices) )))
++    {
++        set_error( STATUS_NO_MEMORY );
++        return;
++    }
++
++    i = 0;
++    LIST_FOR_EACH_ENTRY( e, &current->process->rawinput_devices, struct rawinput_device_entry, entry )
++        devices[i++] = e->device;
++
++    set_reply_data_ptr( devices, device_count * sizeof (*devices) );
++}
+-- 
+2.27.0
+
+From 1c7ed44dba104334ea76c6dafa5acf9e799f6d22 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Thu, 19 Dec 2019 19:00:21 +0100
+Subject: [PATCH 02/10] dinput8/tests: Add DISCL_EXCLUSIVE / rawinput test.
+
+---
+ dlls/dinput8/tests/device.c | 20 ++++++++++++++++++++
+ 1 file changed, 20 insertions(+)
+
+diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
+index 328174e5796..6fe9a635510 100644
+--- a/dlls/dinput8/tests/device.c
++++ b/dlls/dinput8/tests/device.c
+@@ -712,6 +712,26 @@ static void test_mouse_keyboard(void)
+     todo_wine
+     ok(raw_devices_count == 1, "Unexpected raw devices registered: %d\n", raw_devices_count);
+ 
++    IDirectInputDevice8_SetCooperativeLevel(di_mouse, hwnd, DISCL_FOREGROUND|DISCL_EXCLUSIVE);
++    IDirectInputDevice8_SetCooperativeLevel(di_keyboard, hwnd, DISCL_FOREGROUND|DISCL_EXCLUSIVE);
++
++    hr = IDirectInputDevice8_Acquire(di_keyboard);
++    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
++    hr = IDirectInputDevice8_Acquire(di_mouse);
++    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
++    raw_devices_count = ARRAY_SIZE(raw_devices);
++    memset(raw_devices, 0, sizeof(raw_devices));
++    hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
++    ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
++    todo_wine
++    ok(raw_devices[0].dwFlags == (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
++    todo_wine
++    ok(raw_devices[2].dwFlags == (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
++    hr = IDirectInputDevice8_Unacquire(di_keyboard);
++    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
++    hr = IDirectInputDevice8_Unacquire(di_mouse);
++    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
++
+     raw_devices_count = ARRAY_SIZE(raw_devices);
+     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+     todo_wine
+-- 
+2.27.0
+
+From c87aec1bc776a6966479fc7bd60b2e14072959b1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 26 Aug 2019 16:06:59 +0200
+Subject: [PATCH 03/10] dinput8: Add support for rawinput based devices.
+
+This adds a global message window that will receive WM_INPUT messages.
+
+Devices that use rawinput will conflict with any rawinput device
+registered outside of dinput, as exposed by the unit tests.
+---
+ dlls/dinput/device_private.h |  3 ++
+ dlls/dinput/dinput_main.c    | 80 ++++++++++++++++++++++++++++++++++++
+ 2 files changed, 83 insertions(+)
+
+diff --git a/dlls/dinput/device_private.h b/dlls/dinput/device_private.h
+index fe5644f21c7..2fac4f0e61e 100644
+--- a/dlls/dinput/device_private.h
++++ b/dlls/dinput/device_private.h
+@@ -69,6 +69,9 @@ struct IDirectInputDeviceImpl
+     HWND                        win;
+     int                         acquired;
+ 
++    BOOL                        use_raw_input; /* use raw input instead of low-level messages */
++    RAWINPUTDEVICE              raw_device;    /* raw device to (un)register */
++
+     LPDIDEVICEOBJECTDATA        data_queue;  /* buffer for 'GetDeviceData'.                 */
+     int                         queue_len;   /* valid size of the queue                     */
+     int                         queue_head;  /* position to write new event into queue      */
+diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
+index 2e561502406..d0937d35e5b 100644
+--- a/dlls/dinput/dinput_main.c
++++ b/dlls/dinput/dinput_main.c
+@@ -97,6 +97,10 @@ static const struct dinput_device *dinput_devices[] =
+ 
+ HINSTANCE DINPUT_instance;
+ 
++static ATOM        di_em_win_class;
++static const WCHAR di_em_winW[] = {'D','I','E','m','W','i','n',0};
++static HWND        di_em_win;
++
+ static BOOL check_hook_thread(void);
+ static CRITICAL_SECTION dinput_hook_crit;
+ static struct list direct_input_list = LIST_INIT( direct_input_list );
+@@ -637,6 +641,47 @@ static HRESULT WINAPI IDirectInputWImpl_QueryInterface(LPDIRECTINPUT7W iface, RE
+     return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+ }
+ 
++static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
++{
++    IDirectInputDeviceImpl *dev;
++    RAWINPUT ri;
++    UINT size = sizeof(ri);
++    int rim = GET_RAWINPUT_CODE_WPARAM(wparam);
++
++    TRACE( "%p %d %lx %lx\n", hwnd, msg, wparam, lparam );
++
++    if (msg == WM_INPUT && (rim == RIM_INPUT || rim == RIM_INPUTSINK))
++    {
++        if (GetRawInputData( (HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER) ) > sizeof(ri))
++            WARN( "Unable to read raw input data\n" );
++    }
++
++    return DefWindowProcW(hwnd, msg, wparam, lparam);
++}
++
++static void register_di_em_win_class(void)
++{
++    static WNDCLASSEXW class;
++
++    ZeroMemory(&class, sizeof(class));
++    class.cbSize = sizeof(class);
++    class.lpfnWndProc = di_em_win_wndproc;
++    class.hInstance = DINPUT_instance;
++    class.lpszClassName = di_em_winW;
++
++    if (!(di_em_win_class = RegisterClassExW( &class )))
++        WARN( "Unable to register message window class\n" );
++}
++
++static void unregister_di_em_win_class(void)
++{
++    if (!di_em_win_class)
++        return;
++
++    if (!UnregisterClassW( MAKEINTRESOURCEW( di_em_win_class ), DINPUT_instance ))
++        WARN( "Unable to unregister message window class\n" );
++}
++
+ static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion)
+ {
+     if (!This->initialized)
+@@ -1668,11 +1713,13 @@ static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
+     EnterCriticalSection( &dinput_hook_crit );
+     LIST_FOR_EACH_ENTRY( dev, &acquired_mouse_list, IDirectInputDeviceImpl, entry )
+     {
++        if (dev->use_raw_input) continue;
+         TRACE("calling dinput_mouse_hook (%p %lx %lx)\n", dev, wparam, lparam);
+         skip |= dinput_mouse_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
+     }
+     LIST_FOR_EACH_ENTRY( dev, &acquired_keyboard_list, IDirectInputDeviceImpl, entry )
+     {
++        if (dev->use_raw_input) continue;
+         TRACE("calling dinput_keyboard_hook (%p %lx %lx)\n", dev, wparam, lparam);
+         skip |= dinput_keyboard_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
+     }
+@@ -1728,6 +1775,9 @@ static DWORD WINAPI hook_thread_proc(void *param)
+     static HHOOK kbd_hook, mouse_hook;
+     MSG msg;
+ 
++    di_em_win = CreateWindowW( MAKEINTRESOURCEW(di_em_win_class), di_em_winW,
++                               0, 0, 0, 0, 0, HWND_MESSAGE, 0, DINPUT_instance, NULL );
++
+     /* Force creation of the message queue */
+     PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE );
+     SetEvent(param);
+@@ -1778,6 +1828,9 @@ static DWORD WINAPI hook_thread_proc(void *param)
+         DispatchMessageW(&msg);
+     }
+ 
++    DestroyWindow( di_em_win );
++    di_em_win = NULL;
++
+     FreeLibraryAndExitThread(DINPUT_instance, 0);
+ }
+ 
+@@ -1860,6 +1913,31 @@ void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
+         hook_thread_event = NULL;
+     }
+ 
++    if (dev->use_raw_input)
++    {
++        if (acquired)
++        {
++            dev->raw_device.dwFlags = 0;
++            if (dev->dwCoopLevel & DISCL_BACKGROUND)
++                dev->raw_device.dwFlags |= RIDEV_INPUTSINK;
++            if (dev->dwCoopLevel & DISCL_EXCLUSIVE)
++                dev->raw_device.dwFlags |= RIDEV_NOLEGACY;
++            if ((dev->dwCoopLevel & DISCL_EXCLUSIVE) && dev->raw_device.usUsage == 2)
++                dev->raw_device.dwFlags |= RIDEV_CAPTUREMOUSE;
++            if ((dev->dwCoopLevel & DISCL_EXCLUSIVE) && dev->raw_device.usUsage == 6)
++                dev->raw_device.dwFlags |= RIDEV_NOHOTKEYS;
++            dev->raw_device.hwndTarget = di_em_win;
++        }
++        else
++        {
++            dev->raw_device.dwFlags = RIDEV_REMOVE;
++            dev->raw_device.hwndTarget = NULL;
++        }
++
++        if (!RegisterRawInputDevices( &dev->raw_device, 1, sizeof(RAWINPUTDEVICE) ))
++            WARN( "Unable to (un)register raw device %x:%x\n", dev->raw_device.usUsagePage, dev->raw_device.usUsage );
++    }
++
+     if (acquired)
+         hook_change_finished_event = CreateEventW( NULL, FALSE, FALSE, NULL );
+     PostThreadMessageW( hook_thread_id, WM_USER+0x10, 1, (LPARAM)hook_change_finished_event );
+@@ -1894,9 +1972,11 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
+       case DLL_PROCESS_ATTACH:
+         DisableThreadLibraryCalls(inst);
+         DINPUT_instance = inst;
++        register_di_em_win_class();
+         break;
+       case DLL_PROCESS_DETACH:
+         if (reserved) break;
++        unregister_di_em_win_class();
+         DeleteCriticalSection(&dinput_hook_crit);
+         break;
+     }
+-- 
+2.27.0
+
+From b70a6f35b770f6dc77ba398311a122307f1b3146 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 26 Aug 2019 16:06:59 +0200
+Subject: [PATCH 04/10] dinput8: Use rawinput interface for mouse device.
+
+---
+ dlls/dinput/dinput_main.c    | 10 ++++
+ dlls/dinput/dinput_private.h |  1 +
+ dlls/dinput/mouse.c          | 90 ++++++++++++++++++++++++++++++++++++
+ dlls/dinput8/tests/device.c  | 11 ++---
+ 4 files changed, 104 insertions(+), 8 deletions(-)
+
+diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
+index d0937d35e5b..c333ed7d3d0 100644
+--- a/dlls/dinput/dinput_main.c
++++ b/dlls/dinput/dinput_main.c
+@@ -654,6 +654,16 @@ static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPAR
+     {
+         if (GetRawInputData( (HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER) ) > sizeof(ri))
+             WARN( "Unable to read raw input data\n" );
++        else if (ri.header.dwType == RIM_TYPEMOUSE)
++        {
++            EnterCriticalSection( &dinput_hook_crit );
++            LIST_FOR_EACH_ENTRY( dev, &acquired_mouse_list, IDirectInputDeviceImpl, entry )
++            {
++                if (!dev->use_raw_input) continue;
++                dinput_mouse_rawinput_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam, &ri );
++            }
++            LeaveCriticalSection( &dinput_hook_crit );
++        }
+     }
+ 
+     return DefWindowProcW(hwnd, msg, wparam, lparam);
+diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
+index 06a439d6a41..c0c88da9674 100644
+--- a/dlls/dinput/dinput_private.h
++++ b/dlls/dinput/dinput_private.h
+@@ -73,6 +73,7 @@ extern void dinput_hooks_acquire_device(LPDIRECTINPUTDEVICE8W iface);
+ extern void dinput_hooks_unacquire_device(LPDIRECTINPUTDEVICE8W iface);
+ extern int dinput_mouse_hook(LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam);
+ extern int dinput_keyboard_hook(LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam);
++extern void dinput_mouse_rawinput_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam, RAWINPUT *raw );
+ 
+ extern void check_dinput_hooks(LPDIRECTINPUTDEVICE8W, BOOL) DECLSPEC_HIDDEN;
+ extern void check_dinput_events(void) DECLSPEC_HIDDEN;
+diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
+index 5e6f34f0eca..429271e8f43 100644
+--- a/dlls/dinput/mouse.c
++++ b/dlls/dinput/mouse.c
+@@ -239,6 +239,13 @@ static SysMouseImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput)
+     newDevice->base.data_format.wine_df = df;
+     IDirectInput_AddRef(&newDevice->base.dinput->IDirectInput7A_iface);
+ 
++    if (dinput->dwVersion >= 0x0800)
++    {
++        newDevice->base.use_raw_input = TRUE;
++        newDevice->base.raw_device.usUsagePage = 1; /* HID generic device page */
++        newDevice->base.raw_device.usUsage = 2; /* HID generic mouse */
++    }
++
+     return newDevice;
+ 
+ failed:
+@@ -306,6 +313,89 @@ const struct dinput_device mouse_device = {
+  *	SysMouseA (DInput Mouse support)
+  */
+ 
++void dinput_mouse_rawinput_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam, RAWINPUT *ri )
++{
++    SysMouseImpl* This = impl_from_IDirectInputDevice8A(iface);
++    POINT rel, pt;
++    DWORD seq;
++    int i, wdata = 0;
++
++    static const USHORT mouse_button_flags[] =
++    {
++        RI_MOUSE_BUTTON_1_DOWN, RI_MOUSE_BUTTON_1_UP,
++        RI_MOUSE_BUTTON_2_DOWN, RI_MOUSE_BUTTON_2_UP,
++        RI_MOUSE_BUTTON_3_DOWN, RI_MOUSE_BUTTON_3_UP,
++        RI_MOUSE_BUTTON_4_DOWN, RI_MOUSE_BUTTON_4_UP,
++        RI_MOUSE_BUTTON_5_DOWN, RI_MOUSE_BUTTON_5_UP
++    };
++
++    TRACE("(%p) wp %08lx, lp %08lx\n", iface, wparam, lparam);
++
++    if (ri->data.mouse.usFlags & MOUSE_VIRTUAL_DESKTOP)
++        FIXME( "Unimplemented MOUSE_VIRTUAL_DESKTOP flag\n" );
++    if (ri->data.mouse.usFlags & MOUSE_ATTRIBUTES_CHANGED)
++        FIXME( "Unimplemented MOUSE_ATTRIBUTES_CHANGED flag\n" );
++
++    EnterCriticalSection(&This->base.crit);
++    seq = This->base.dinput->evsequence++;
++
++    rel.x = ri->data.mouse.lLastX;
++    rel.y = ri->data.mouse.lLastY;
++    if (ri->data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
++    {
++        GetCursorPos(&pt);
++        rel.x -= pt.x;
++        rel.y -= pt.y;
++    }
++
++    This->m_state.lX += rel.x;
++    This->m_state.lY += rel.y;
++
++    if (This->base.data_format.user_df->dwFlags & DIDF_ABSAXIS)
++    {
++        pt.x = This->m_state.lX;
++        pt.y = This->m_state.lY;
++    }
++    else
++    {
++        pt = rel;
++    }
++
++    if (rel.x)
++        queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS,
++                    pt.x, GetCurrentTime(), seq);
++
++    if (rel.y)
++        queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS,
++                    pt.y, GetCurrentTime(), seq);
++
++    if (rel.x || rel.y)
++    {
++        if ((This->warp_override == WARP_FORCE_ON) ||
++            (This->warp_override != WARP_DISABLE && (This->base.dwCoopLevel & DISCL_EXCLUSIVE)))
++            This->need_warp = TRUE;
++    }
++
++    if (ri->data.mouse.usButtonFlags & RI_MOUSE_WHEEL)
++    {
++        This->m_state.lZ += (wdata = (SHORT)ri->data.mouse.usButtonData);
++        queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Z_AXIS_INSTANCE) | DIDFT_RELAXIS,
++                    wdata, GetCurrentTime(), seq);
++    }
++
++    for (i = 0; i < ARRAY_SIZE(mouse_button_flags); ++i)
++    {
++        if (ri->data.mouse.usButtonFlags & mouse_button_flags[i])
++        {
++            This->m_state.rgbButtons[i / 2] = 0x80 - (i % 2) * 0x80;
++            queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + (i / 2)) | DIDFT_PSHBUTTON,
++                        This->m_state.rgbButtons[i / 2], GetCurrentTime(), seq);
++        }
++    }
++
++    LeaveCriticalSection(&This->base.crit);
++}
++
+ /* low-level mouse hook */
+ int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam )
+ {
+diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
+index 6fe9a635510..80a7fe26c3b 100644
+--- a/dlls/dinput8/tests/device.c
++++ b/dlls/dinput8/tests/device.c
+@@ -646,13 +646,9 @@ static void test_mouse_keyboard(void)
+     raw_devices_count = ARRAY_SIZE(raw_devices);
+     memset(raw_devices, 0, sizeof(raw_devices));
+     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+-    todo_wine
+     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+-    todo_wine
+     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+-    todo_wine
+     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+-    todo_wine
+     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+     todo_wine
+     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
+@@ -662,6 +658,9 @@ static void test_mouse_keyboard(void)
+     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
+ 
++    if (raw_devices[0].hwndTarget != NULL)
++        di_hwnd = raw_devices[0].hwndTarget;
++
+     /* expect dinput8 to take over any activated raw input devices */
+     raw_devices[0].usUsagePage = 0x01;
+     raw_devices[0].usUsage = 0x05;
+@@ -689,9 +688,7 @@ static void test_mouse_keyboard(void)
+     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+-    todo_wine
+     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+-    todo_wine
+     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
+     ok(raw_devices[1].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
+     ok(raw_devices[1].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
+@@ -723,7 +720,6 @@ static void test_mouse_keyboard(void)
+     memset(raw_devices, 0, sizeof(raw_devices));
+     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+-    todo_wine
+     ok(raw_devices[0].dwFlags == (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+     todo_wine
+     ok(raw_devices[2].dwFlags == (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
+@@ -737,7 +733,6 @@ static void test_mouse_keyboard(void)
+     todo_wine
+     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+-    todo_wine
+     ok(raw_devices[0].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+     ok(raw_devices[0].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+     ok(raw_devices[0].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
+-- 
+2.27.0
+
+From d58e4ce3e5a44e0c10b80b645fc0a2e448d4c43e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Sat, 6 Jun 2020 11:46:24 +0200
+Subject: [PATCH 05/10] dinput8: Stop using LL hooks for mouse devices.
+
+LL hooks are heavy and using them cause performance hit with high
+polling rate mice. We don't need them anymore since we now use rawinput
+API for mouse device.
+
+This also uses a separate list for rawinput mouse devices.
+---
+ dlls/dinput/dinput_main.c | 17 +++++++++++------
+ 1 file changed, 11 insertions(+), 6 deletions(-)
+
+diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
+index c333ed7d3d0..5e03964f901 100644
+--- a/dlls/dinput/dinput_main.c
++++ b/dlls/dinput/dinput_main.c
+@@ -105,6 +105,7 @@ static BOOL check_hook_thread(void);
+ static CRITICAL_SECTION dinput_hook_crit;
+ static struct list direct_input_list = LIST_INIT( direct_input_list );
+ static struct list acquired_mouse_list = LIST_INIT( acquired_mouse_list );
++static struct list acquired_rawmouse_list = LIST_INIT( acquired_rawmouse_list );
+ static struct list acquired_keyboard_list = LIST_INIT( acquired_keyboard_list );
+ static struct list acquired_device_list = LIST_INIT( acquired_device_list );
+ 
+@@ -117,7 +118,7 @@ void dinput_hooks_acquire_device(LPDIRECTINPUTDEVICE8W iface)
+ 
+     EnterCriticalSection( &dinput_hook_crit );
+     if (IsEqualGUID( &dev->guid, &GUID_SysMouse ))
+-        list_add_tail( &acquired_mouse_list, &dev->entry );
++        list_add_tail( dev->use_raw_input ? &acquired_rawmouse_list : &acquired_mouse_list, &dev->entry );
+     else if (IsEqualGUID( &dev->guid, &GUID_SysKeyboard ))
+         list_add_tail( &acquired_keyboard_list, &dev->entry );
+     else
+@@ -657,11 +658,8 @@ static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPAR
+         else if (ri.header.dwType == RIM_TYPEMOUSE)
+         {
+             EnterCriticalSection( &dinput_hook_crit );
+-            LIST_FOR_EACH_ENTRY( dev, &acquired_mouse_list, IDirectInputDeviceImpl, entry )
+-            {
+-                if (!dev->use_raw_input) continue;
++            LIST_FOR_EACH_ENTRY( dev, &acquired_rawmouse_list, IDirectInputDeviceImpl, entry )
+                 dinput_mouse_rawinput_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam, &ri );
+-            }
+             LeaveCriticalSection( &dinput_hook_crit );
+         }
+     }
+@@ -1723,7 +1721,6 @@ static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
+     EnterCriticalSection( &dinput_hook_crit );
+     LIST_FOR_EACH_ENTRY( dev, &acquired_mouse_list, IDirectInputDeviceImpl, entry )
+     {
+-        if (dev->use_raw_input) continue;
+         TRACE("calling dinput_mouse_hook (%p %lx %lx)\n", dev, wparam, lparam);
+         skip |= dinput_mouse_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
+     }
+@@ -1767,6 +1764,14 @@ static LRESULT CALLBACK callwndproc_proc( int code, WPARAM wparam, LPARAM lparam
+             IDirectInputDevice_Unacquire( &dev->IDirectInputDevice8A_iface );
+         }
+     }
++    LIST_FOR_EACH_ENTRY_SAFE( dev, next, &acquired_rawmouse_list, IDirectInputDeviceImpl, entry )
++    {
++        if (msg->hwnd == dev->win && msg->hwnd != foreground)
++        {
++            TRACE( "%p window is not foreground - unacquiring %p\n", dev->win, dev );
++            IDirectInputDevice_Unacquire( &dev->IDirectInputDevice8A_iface );
++        }
++    }
+     LIST_FOR_EACH_ENTRY_SAFE( dev, next, &acquired_keyboard_list, IDirectInputDeviceImpl, entry )
+     {
+         if (msg->hwnd == dev->win && msg->hwnd != foreground)
+-- 
+2.27.0
+
+From 485e427ff46d599376d08963205dc76bb9172590 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 26 Aug 2019 14:37:20 +0200
+Subject: [PATCH 06/10] server: Add send_hardware_message flags for rawinput
+ translation.
+
+---
+ dlls/user32/input.c |  6 +++---
+ server/protocol.def |  2 ++
+ server/queue.c      | 20 ++++++++++++++------
+ 3 files changed, 19 insertions(+), 9 deletions(-)
+
+diff --git a/dlls/user32/input.c b/dlls/user32/input.c
+index 1dd43a36a11..f0b95c7fc6c 100644
+--- a/dlls/user32/input.c
++++ b/dlls/user32/input.c
+@@ -125,7 +125,7 @@ BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret )
+  */
+ BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input )
+ {
+-    NTSTATUS status = send_hardware_message( hwnd, input, 0 );
++    NTSTATUS status = send_hardware_message( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+     if (status) SetLastError( RtlNtStatusToDosError(status) );
+     return !status;
+ }
+@@ -193,9 +193,9 @@ UINT WINAPI SendInput( UINT count, LPINPUT inputs, int size )
+             /* we need to update the coordinates to what the server expects */
+             INPUT input = inputs[i];
+             update_mouse_coords( &input );
+-            status = send_hardware_message( 0, &input, SEND_HWMSG_INJECTED );
++            status = send_hardware_message( 0, &input, SEND_HWMSG_INJECTED|SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+         }
+-        else status = send_hardware_message( 0, &inputs[i], SEND_HWMSG_INJECTED );
++        else status = send_hardware_message( 0, &inputs[i], SEND_HWMSG_INJECTED|SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+ 
+         if (status)
+         {
+diff --git a/server/protocol.def b/server/protocol.def
+index 2e9ea6e5746..447dd0b023b 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -2335,6 +2335,8 @@ enum message_type
+     VARARG(keystate,bytes);    /* global state array for all the keys */
+ @END
+ #define SEND_HWMSG_INJECTED    0x01
++#define SEND_HWMSG_RAWINPUT    0x02
++#define SEND_HWMSG_WINDOW      0x04
+ 
+ 
+ /* Get a message from the current queue */
+diff --git a/server/queue.c b/server/queue.c
+index ff9e703d1ff..46ace52f004 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -1695,7 +1695,7 @@ done:
+ 
+ /* queue a hardware message for a mouse event */
+ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
+-                                unsigned int origin, struct msg_queue *sender )
++                                unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
+ {
+     const struct rawinput_device *device;
+     struct hardware_msg_data *msg_data;
+@@ -1765,7 +1765,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
+         msg_data->rawinput.mouse.y    = y - desktop->cursor.y;
+         msg_data->rawinput.mouse.data = input->mouse.data;
+ 
+-        enum_processes( queue_rawinput_message, &raw_msg );
++        if ((req_flags & SEND_HWMSG_RAWINPUT))
++            enum_processes( queue_rawinput_message, &raw_msg );
+         release_object( foreground );
+     }
+ 
+@@ -1775,6 +1776,9 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
+         return 0;
+     }
+ 
++    if (!(req_flags & SEND_HWMSG_WINDOW))
++        return 0;
++
+     for (i = 0; i < ARRAY_SIZE( messages ); i++)
+     {
+         if (!messages[i]) continue;
+@@ -1806,7 +1810,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
+ 
+ /* queue a hardware message for a keyboard event */
+ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
+-                                   unsigned int origin, struct msg_queue *sender )
++                                   unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
+ {
+     struct hw_msg_source source = { IMDT_KEYBOARD, origin };
+     const struct rawinput_device *device;
+@@ -1899,7 +1903,8 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
+         msg_data->rawinput.kbd.vkey    = vkey;
+         msg_data->rawinput.kbd.scan    = input->kbd.scan;
+ 
+-        enum_processes( queue_rawinput_message, &raw_msg );
++        if ((req_flags & SEND_HWMSG_RAWINPUT))
++            enum_processes( queue_rawinput_message, &raw_msg );
+         release_object( foreground );
+     }
+ 
+@@ -1909,6 +1914,9 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
+         return 0;
+     }
+ 
++    if (!(req_flags & SEND_HWMSG_WINDOW))
++        return 0;
++
+     if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
+     msg_data = msg->data;
+ 
+@@ -2465,10 +2473,10 @@ DECL_HANDLER(send_hardware_message)
+     switch (req->input.type)
+     {
+     case INPUT_MOUSE:
+-        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender );
++        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
+         break;
+     case INPUT_KEYBOARD:
+-        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender );
++        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
+         break;
+     case INPUT_HARDWARE:
+         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
+-- 
+2.27.0
+
+From 45f8b4e04f70e16c6bb0f895bd72529fc2a44e7f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Mon, 26 Aug 2019 15:20:32 +0200
+Subject: [PATCH 07/10] user32: Add __wine_send_input flags to hint raw input
+ translation.
+
+---
+ dlls/user32/input.c             | 4 ++--
+ dlls/user32/user32.spec         | 2 +-
+ dlls/wineandroid.drv/keyboard.c | 2 +-
+ dlls/wineandroid.drv/window.c   | 4 ++--
+ dlls/winemac.drv/ime.c          | 5 +++--
+ dlls/winemac.drv/keyboard.c     | 2 +-
+ dlls/winemac.drv/mouse.c        | 2 +-
+ dlls/winex11.drv/keyboard.c     | 2 +-
+ dlls/winex11.drv/mouse.c        | 8 ++++----
+ include/winuser.h               | 2 +-
+ 10 files changed, 17 insertions(+), 16 deletions(-)
+
+diff --git a/dlls/user32/input.c b/dlls/user32/input.c
+index f0b95c7fc6c..150b7de9704 100644
+--- a/dlls/user32/input.c
++++ b/dlls/user32/input.c
+@@ -123,9 +123,9 @@ BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret )
+  *
+  * Internal SendInput function to allow the graphics driver to inject real events.
+  */
+-BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input )
++BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, UINT flags )
+ {
+-    NTSTATUS status = send_hardware_message( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
++    NTSTATUS status = send_hardware_message( hwnd, input, flags );
+     if (status) SetLastError( RtlNtStatusToDosError(status) );
+     return !status;
+ }
+diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
+index d2a14879714..6ffc7d44096 100644
+--- a/dlls/user32/user32.spec
++++ b/dlls/user32/user32.spec
+@@ -833,5 +833,5 @@
+ # All functions must be prefixed with '__wine_' (for internal functions)
+ # or 'wine_' (for user-visible functions) to avoid namespace conflicts.
+ #
+-@ cdecl __wine_send_input(long ptr)
++@ cdecl __wine_send_input(long ptr long)
+ @ cdecl __wine_set_pixel_format(long long)
+diff --git a/dlls/wineandroid.drv/keyboard.c b/dlls/wineandroid.drv/keyboard.c
+index a0f3257f74b..1af8a98f1f9 100644
+--- a/dlls/wineandroid.drv/keyboard.c
++++ b/dlls/wineandroid.drv/keyboard.c
+@@ -680,7 +680,7 @@ static void send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD flags )
+     input.u.ki.time        = 0;
+     input.u.ki.dwExtraInfo = 0;
+ 
+-    __wine_send_input( hwnd, &input );
++    __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+ }
+ 
+ /***********************************************************************
+diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
+index eb05aaf2832..c1e7b000a8f 100644
+--- a/dlls/wineandroid.drv/window.c
++++ b/dlls/wineandroid.drv/window.c
+@@ -521,7 +521,7 @@ static int process_events( DWORD mask )
+                     }
+                     SERVER_END_REQ;
+                 }
+-                __wine_send_input( capture ? capture : event->data.motion.hwnd, &event->data.motion.input );
++                __wine_send_input( capture ? capture : event->data.motion.hwnd, &event->data.motion.input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+             }
+             break;
+ 
+@@ -535,7 +535,7 @@ static int process_events( DWORD mask )
+                       event->data.kbd.input.u.ki.wVk, event->data.kbd.input.u.ki.wVk,
+                       event->data.kbd.input.u.ki.wScan );
+             update_keyboard_lock_state( event->data.kbd.input.u.ki.wVk, event->data.kbd.lock_state );
+-            __wine_send_input( 0, &event->data.kbd.input );
++            __wine_send_input( 0, &event->data.kbd.input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+             break;
+ 
+         default:
+diff --git a/dlls/winemac.drv/ime.c b/dlls/winemac.drv/ime.c
+index dabe6654f98..3593374a613 100644
+--- a/dlls/winemac.drv/ime.c
++++ b/dlls/winemac.drv/ime.c
+@@ -42,6 +42,7 @@
+ #include "winuser.h"
+ #include "imm.h"
+ #include "ddk/imm.h"
++#include "wine/server.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(imm);
+ 
+@@ -1427,10 +1428,10 @@ void macdrv_im_set_text(const macdrv_event *event)
+             {
+                 input.ki.wScan      = chars[i];
+                 input.ki.dwFlags    = KEYEVENTF_UNICODE;
+-                __wine_send_input(hwnd, &input);
++                __wine_send_input(hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
+ 
+                 input.ki.dwFlags    = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
+-                __wine_send_input(hwnd, &input);
++                __wine_send_input(hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
+             }
+         }
+ 
+diff --git a/dlls/winemac.drv/keyboard.c b/dlls/winemac.drv/keyboard.c
+index bb408cb20c5..41919baafc7 100644
+--- a/dlls/winemac.drv/keyboard.c
++++ b/dlls/winemac.drv/keyboard.c
+@@ -929,7 +929,7 @@ static void macdrv_send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD fl
+     input.ki.time           = time;
+     input.ki.dwExtraInfo    = 0;
+ 
+-    __wine_send_input(hwnd, &input);
++    __wine_send_input(hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
+ }
+ 
+ 
+diff --git a/dlls/winemac.drv/mouse.c b/dlls/winemac.drv/mouse.c
+index dd6443fe1ba..91cafdf1362 100644
+--- a/dlls/winemac.drv/mouse.c
++++ b/dlls/winemac.drv/mouse.c
+@@ -165,7 +165,7 @@ static void send_mouse_input(HWND hwnd, macdrv_window cocoa_window, UINT flags,
+     input.mi.time           = time;
+     input.mi.dwExtraInfo    = 0;
+ 
+-    __wine_send_input(top_level_hwnd, &input);
++    __wine_send_input(top_level_hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
+ }
+ 
+ 
+diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
+index 48da12c0292..2a3bed787ab 100644
+--- a/dlls/winex11.drv/keyboard.c
++++ b/dlls/winex11.drv/keyboard.c
+@@ -1148,7 +1148,7 @@ static void X11DRV_send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD f
+     input.u.ki.time        = time;
+     input.u.ki.dwExtraInfo = 0;
+ 
+-    __wine_send_input( hwnd, &input );
++    __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+ }
+ 
+ 
+diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
+index 7f11ba86e49..aaa34d8ff0f 100644
+--- a/dlls/winex11.drv/mouse.c
++++ b/dlls/winex11.drv/mouse.c
+@@ -657,7 +657,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
+         }
+         input->u.mi.dx += clip_rect.left;
+         input->u.mi.dy += clip_rect.top;
+-        __wine_send_input( hwnd, input );
++        __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+         return;
+     }
+ 
+@@ -697,7 +697,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
+         SERVER_END_REQ;
+     }
+ 
+-    __wine_send_input( hwnd, input );
++    __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+ }
+ 
+ #ifdef SONAME_LIBXCURSOR
+@@ -1643,7 +1643,7 @@ void move_resize_window( HWND hwnd, int dir )
+             input.u.mi.dwFlags     = button_up_flags[button - 1] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
+             input.u.mi.time        = GetTickCount();
+             input.u.mi.dwExtraInfo = 0;
+-            __wine_send_input( hwnd, &input );
++            __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+         }
+ 
+         while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
+@@ -1882,7 +1882,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+ 
+     input.type = INPUT_MOUSE;
+-    __wine_send_input( 0, &input );
++    __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
+     return TRUE;
+ }
+ 
+diff --git a/include/winuser.h b/include/winuser.h
+index 311b1481be4..4bc18a63e31 100644
+--- a/include/winuser.h
++++ b/include/winuser.h
+@@ -4406,7 +4406,7 @@ static inline BOOL WINAPI SetRectEmpty(LPRECT rect)
+ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
+ 
+ #ifdef __WINESRC__
+-WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input );
++WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, UINT flags );
+ #endif
+ 
+ #ifdef __cplusplus
+-- 
+2.27.0
+
+From bd8d2ab09ddbceabdc1641af6fd73a6199bf916b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Fri, 2 Aug 2019 02:24:32 -0400
+Subject: [PATCH 08/10] winex11.drv: Advertise XInput2 version 2.1 support.
+
+Under XInput2 protocol version < 2.1, RawEvents are not supposed to be
+sent if a pointer grab is active. However slave device events are still
+received regardless of this specification and Wine implemented a
+workaround to receive RawEvents during pointer grabs by listening to
+these slave device events. Then, as soon as a mouse button is pressed
+only the grabbing client will receive the raw motion events.
+
+By advertising the support of XInput2 version >= 2.1, where RawEvents
+are sent even during pointer grabs, we ensure to receive the RawMotion
+events from the desktop window thread, even if a mouse grab is active.
+
+It is now also possible to simplify the code by listening to master
+device events only and get rid of slave device id tracking.
+---
+ dlls/winex11.drv/mouse.c  | 49 ++++++++-------------------------------
+ dlls/winex11.drv/x11drv.h |  3 ---
+ 2 files changed, 10 insertions(+), 42 deletions(-)
+
+diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
+index aaa34d8ff0f..3a4b1198829 100644
+--- a/dlls/winex11.drv/mouse.c
++++ b/dlls/winex11.drv/mouse.c
+@@ -302,12 +302,16 @@ static void enable_xinput2(void)
+ 
+     if (data->xi2_state == xi_unknown)
+     {
+-        int major = 2, minor = 0;
+-        if (!pXIQueryVersion( data->display, &major, &minor )) data->xi2_state = xi_disabled;
++        int major = 2, minor = 1;
++        if (!pXIQueryVersion( data->display, &major, &minor ) && major == 2 && minor > 0)
++        {
++            TRACE( "XInput2 v%d.%d available\n", major, minor );
++            data->xi2_state = xi_disabled;
++        }
+         else
+         {
+             data->xi2_state = xi_unavailable;
+-            WARN( "X Input 2 not available\n" );
++            WARN( "XInput v2.1 not available\n" );
+         }
+     }
+     if (data->xi2_state == xi_unavailable) return;
+@@ -315,7 +319,7 @@ static void enable_xinput2(void)
+ 
+     mask.mask     = mask_bits;
+     mask.mask_len = sizeof(mask_bits);
+-    mask.deviceid = XIAllDevices;
++    mask.deviceid = XIAllMasterDevices;
+     memset( mask_bits, 0, sizeof(mask_bits) );
+     XISetMask( mask_bits, XI_DeviceChanged );
+     XISetMask( mask_bits, XI_RawMotion );
+@@ -327,16 +331,6 @@ static void enable_xinput2(void)
+     update_relative_valuators( pointer_info->classes, pointer_info->num_classes );
+     pXIFreeDeviceInfo( pointer_info );
+ 
+-    /* This device info list is only used to find the initial current slave if
+-     * no XI_DeviceChanged events happened. If any hierarchy change occurred that
+-     * might be relevant here (eg. user switching mice after (un)plugging), a
+-     * XI_DeviceChanged event will point us to the right slave. So this list is
+-     * safe to be obtained statically at enable_xinput2() time.
+-     */
+-    if (data->xi2_devices) pXIFreeDeviceInfo( data->xi2_devices );
+-    data->xi2_devices = pXIQueryDevice( data->display, XIAllDevices, &data->xi2_device_count );
+-    data->xi2_current_slave = 0;
+-
+     data->xi2_state = xi_enabled;
+ #endif
+ }
+@@ -357,15 +351,12 @@ static void disable_xinput2(void)
+ 
+     mask.mask = NULL;
+     mask.mask_len = 0;
+-    mask.deviceid = XIAllDevices;
++    mask.deviceid = XIAllMasterDevices;
+ 
+     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
+-    pXIFreeDeviceInfo( data->xi2_devices );
+     data->x_rel_valuator.number = -1;
+     data->y_rel_valuator.number = -1;
+-    data->xi2_devices = NULL;
+     data->xi2_core_pointer = 0;
+-    data->xi2_current_slave = 0;
+ #endif
+ }
+ 
+@@ -1799,7 +1790,6 @@ static BOOL X11DRV_DeviceChanged( XGenericEventCookie *xev )
+     if (event->reason != XISlaveSwitch) return FALSE;
+ 
+     update_relative_valuators( event->classes, event->num_classes );
+-    data->xi2_current_slave = event->sourceid;
+     return TRUE;
+ }
+ 
+@@ -1820,26 +1810,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     if (thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0) return FALSE;
+     if (!event->valuators.mask_len) return FALSE;
+     if (thread_data->xi2_state != xi_enabled) return FALSE;
+-
+-    /* If there is no slave currently detected, no previous motion nor device
+-     * change events were received. Look it up now on the device list in this
+-     * case.
+-     */
+-    if (!thread_data->xi2_current_slave)
+-    {
+-        XIDeviceInfo *devices = thread_data->xi2_devices;
+-
+-        for (i = 0; i < thread_data->xi2_device_count; i++)
+-        {
+-            if (devices[i].use != XISlavePointer) continue;
+-            if (devices[i].deviceid != event->deviceid) continue;
+-            if (devices[i].attachment != thread_data->xi2_core_pointer) continue;
+-            thread_data->xi2_current_slave = event->deviceid;
+-            break;
+-        }
+-    }
+-
+-    if (event->deviceid != thread_data->xi2_current_slave) return FALSE;
++    if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
+ 
+     x_rel = &thread_data->x_rel_valuator;
+     y_rel = &thread_data->y_rel_valuator;
+diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
+index cfce09bf11d..8a02a6ebf94 100644
+--- a/dlls/winex11.drv/x11drv.h
++++ b/dlls/winex11.drv/x11drv.h
+@@ -339,12 +339,9 @@ struct x11drv_thread_data
+     DWORD    clip_reset;           /* time when clipping was last reset */
+     HKL      kbd_layout;           /* active keyboard layout */
+     enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled } xi2_state; /* XInput2 state */
+-    void    *xi2_devices;          /* list of XInput2 devices (valid when state is enabled) */
+-    int      xi2_device_count;
+     struct x11drv_valuator_data x_rel_valuator;
+     struct x11drv_valuator_data y_rel_valuator;
+     int      xi2_core_pointer;     /* XInput2 core pointer id */
+-    int      xi2_current_slave;    /* Current slave driving the Core pointer */
+ };
+ 
+ extern struct x11drv_thread_data *x11drv_init_thread_data(void) DECLSPEC_HIDDEN;
+-- 
+2.27.0
+
+From f442d439342e79fb6745bf3f3326ddfe614c3fd8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Thu, 19 Dec 2019 22:34:44 +0100
+Subject: [PATCH 09/10] winex11.drv: Keep track of pointer and device button
+ mappings.
+
+We are going to receive raw button events and we will need to apply the
+correct button mappings ourselves.
+
+Original patch by Andrew Eikum <aeikum@codeweavers.com>.
+---
+ dlls/winex11.drv/keyboard.c    | 23 ++++++---
+ dlls/winex11.drv/mouse.c       | 89 +++++++++++++++++++++++++++++++++-
+ dlls/winex11.drv/x11drv.h      |  1 +
+ dlls/winex11.drv/x11drv_main.c |  1 +
+ 4 files changed, 106 insertions(+), 8 deletions(-)
+
+diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
+index 2a3bed787ab..37c96c926f4 100644
+--- a/dlls/winex11.drv/keyboard.c
++++ b/dlls/winex11.drv/keyboard.c
+@@ -1977,13 +1977,24 @@ BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
+ {
+     HWND hwnd;
+ 
+-    XRefreshKeyboardMapping(&event->xmapping);
+-    X11DRV_InitKeyboard( event->xmapping.display );
++    switch (event->xmapping.request)
++    {
++    case MappingModifier:
++    case MappingKeyboard:
++        XRefreshKeyboardMapping( &event->xmapping );
++        X11DRV_InitKeyboard( event->xmapping.display );
++
++        hwnd = GetFocus();
++        if (!hwnd) hwnd = GetActiveWindow();
++        PostMessageW(hwnd, WM_INPUTLANGCHANGEREQUEST,
++                     0 /*FIXME*/, (LPARAM)X11DRV_GetKeyboardLayout(0));
++        break;
++
++    case MappingPointer:
++        X11DRV_InitMouse( event->xmapping.display );
++        break;
++    }
+ 
+-    hwnd = GetFocus();
+-    if (!hwnd) hwnd = GetActiveWindow();
+-    PostMessageW(hwnd, WM_INPUTLANGCHANGEREQUEST,
+-                 0 /*FIXME*/, (LPARAM)X11DRV_GetKeyboardLayout(0));
+     return TRUE;
+ }
+ 
+diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
+index 3a4b1198829..26e8b4eea92 100644
+--- a/dlls/winex11.drv/mouse.c
++++ b/dlls/winex11.drv/mouse.c
+@@ -25,6 +25,9 @@
+ #include <X11/Xlib.h>
+ #include <X11/cursorfont.h>
+ #include <stdarg.h>
++#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
++#include <X11/extensions/XInput.h>
++#endif
+ #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+ #include <X11/extensions/XInput2.h>
+ #endif
+@@ -142,6 +145,14 @@ MAKE_FUNCPTR(XISelectEvents);
+ #undef MAKE_FUNCPTR
+ #endif
+ 
++#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
++#define MAKE_FUNCPTR(f) static typeof(f) * p##f
++MAKE_FUNCPTR(XOpenDevice);
++MAKE_FUNCPTR(XCloseDevice);
++MAKE_FUNCPTR(XGetDeviceButtonMapping);
++#undef MAKE_FUNCPTR
++#endif
++
+ /***********************************************************************
+  *		X11DRV_Xcursor_Init
+  *
+@@ -247,6 +258,70 @@ void sync_window_cursor( Window window )
+     set_window_cursor( window, cursor );
+ }
+ 
++struct mouse_button_mapping
++{
++    int deviceid;
++    unsigned int button_count;
++    unsigned char buttons[256];
++};
++
++static struct mouse_button_mapping *pointer_mapping;
++static struct mouse_button_mapping *device_mapping;
++
++static void update_pointer_mapping( Display *display )
++{
++    struct mouse_button_mapping *tmp;
++
++    if (!(tmp = HeapAlloc( GetProcessHeap(), 0, sizeof(*tmp) )))
++    {
++        WARN("Unable to allocate device mapping.\n");
++        return;
++    }
++
++    tmp->button_count = ARRAY_SIZE( tmp->buttons );
++    tmp->button_count = XGetPointerMapping( display, tmp->buttons, tmp->button_count );
++
++    tmp = InterlockedExchangePointer( (void**)&pointer_mapping, tmp );
++
++    HeapFree( GetProcessHeap(), 0, tmp );
++}
++
++static void update_device_mapping( Display *display, int deviceid )
++{
++#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
++    struct mouse_button_mapping *tmp;
++    XDevice *device;
++
++    if (!(device = pXOpenDevice( display, deviceid )))
++    {
++        WARN( "Unable to open cursor device %d\n", deviceid );
++        return;
++    }
++
++    if (!(tmp = HeapAlloc( GetProcessHeap(), 0, sizeof(*tmp) )))
++    {
++        WARN( "Unable to allocate device mapping.\n" );
++        pXCloseDevice( display, device );
++        return;
++    }
++
++    tmp->deviceid = deviceid;
++    tmp->button_count = ARRAY_SIZE( tmp->buttons );
++    tmp->button_count = pXGetDeviceButtonMapping( display, device, tmp->buttons, tmp->button_count );
++
++    tmp = InterlockedExchangePointer( (void**)&device_mapping, tmp );
++
++    HeapFree( GetProcessHeap(), 0, tmp );
++
++    pXCloseDevice( display, device );
++#endif
++}
++
++void X11DRV_InitMouse( Display *display )
++{
++    update_pointer_mapping( display );
++}
++
+ #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+ /***********************************************************************
+  *              update_relative_valuators
+@@ -1790,6 +1865,8 @@ static BOOL X11DRV_DeviceChanged( XGenericEventCookie *xev )
+     if (event->reason != XISlaveSwitch) return FALSE;
+ 
+     update_relative_valuators( event->classes, event->num_classes );
++    update_device_mapping( event->display, event->sourceid );
++
+     return TRUE;
+ }
+ 
+@@ -1859,13 +1936,12 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+ 
+ #endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
+ 
+-
+ /***********************************************************************
+  *              X11DRV_XInput2_Init
+  */
+ void X11DRV_XInput2_Init(void)
+ {
+-#if defined(SONAME_LIBXI) && defined(HAVE_X11_EXTENSIONS_XINPUT2_H)
++#if defined(SONAME_LIBXI)
+     int event, error;
+     void *libxi_handle = dlopen( SONAME_LIBXI, RTLD_NOW );
+ 
+@@ -1881,11 +1957,20 @@ void X11DRV_XInput2_Init(void)
+         return; \
+     }
+ 
++#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+     LOAD_FUNCPTR(XIGetClientPointer);
+     LOAD_FUNCPTR(XIFreeDeviceInfo);
+     LOAD_FUNCPTR(XIQueryDevice);
+     LOAD_FUNCPTR(XIQueryVersion);
+     LOAD_FUNCPTR(XISelectEvents);
++#endif
++
++#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
++    LOAD_FUNCPTR(XOpenDevice);
++    LOAD_FUNCPTR(XCloseDevice);
++    LOAD_FUNCPTR(XGetDeviceButtonMapping);
++#endif
++
+ #undef LOAD_FUNCPTR
+ 
+     xinput2_available = XQueryExtension( gdi_display, "XInputExtension", &xinput2_opcode, &event, &error );
+diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
+index 8a02a6ebf94..73b1e90f12e 100644
+--- a/dlls/winex11.drv/x11drv.h
++++ b/dlls/winex11.drv/x11drv.h
+@@ -629,6 +629,7 @@ extern void retry_grab_clipping_window(void) DECLSPEC_HIDDEN;
+ extern BOOL clip_fullscreen_window( HWND hwnd, BOOL reset ) DECLSPEC_HIDDEN;
+ extern void move_resize_window( HWND hwnd, int dir ) DECLSPEC_HIDDEN;
+ extern void X11DRV_InitKeyboard( Display *display ) DECLSPEC_HIDDEN;
++extern void X11DRV_InitMouse( Display *display ) DECLSPEC_HIDDEN;
+ extern DWORD CDECL X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles, DWORD timeout,
+                                                        DWORD mask, DWORD flags ) DECLSPEC_HIDDEN;
+ 
+diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
+index e6e61e801e1..20e829ba64f 100644
+--- a/dlls/winex11.drv/x11drv_main.c
++++ b/dlls/winex11.drv/x11drv_main.c
+@@ -615,6 +615,7 @@ static BOOL process_attach(void)
+     if (use_xkb) use_xkb = XkbUseExtension( gdi_display, NULL, NULL );
+ #endif
+     X11DRV_InitKeyboard( gdi_display );
++    X11DRV_InitMouse( gdi_display );
+     if (use_xim) use_xim = X11DRV_InitXIM( input_style );
+ 
+     X11DRV_DisplayDevices_Init(FALSE);
+-- 
+2.27.0
+
+From f39704932d3de690ce868c3e25ce546bcb62ebd0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
+Date: Wed, 11 Sep 2019 10:15:20 +0200
+Subject: [PATCH 10/10] winex11.drv: Listen to RawMotion and RawButton* events
+ in the desktop thread.
+
+We still need to send "normal" input from the clipping window thread
+to trigger low-level hooks callbacks when clipping cursor. This is for
+instance used in our dinput implementation.
+---
+ dlls/winex11.drv/event.c       | 10 +++-
+ dlls/winex11.drv/mouse.c       | 88 ++++++++++++++++++++++++++++------
+ dlls/winex11.drv/x11drv.h      |  3 ++
+ dlls/winex11.drv/x11drv_main.c |  4 ++
+ 4 files changed, 89 insertions(+), 16 deletions(-)
+
+diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
+index 07f7a1ad502..d722ba9d7cc 100644
+--- a/dlls/winex11.drv/event.c
++++ b/dlls/winex11.drv/event.c
+@@ -321,6 +321,10 @@ static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawE
+  */
+ static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
+ {
++#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
++    struct x11drv_thread_data *thread_data = x11drv_thread_data();
++#endif
++
+     switch (prev->type)
+     {
+     case ConfigureNotify:
+@@ -352,19 +356,21 @@ static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
+         case GenericEvent:
+             if (next->xcookie.extension != xinput2_opcode) break;
+             if (next->xcookie.evtype != XI_RawMotion) break;
+-            if (x11drv_thread_data()->warp_serial) break;
++            if (thread_data->xi2_rawinput_only) break;
++            if (thread_data->warp_serial) break;
+             return MERGE_KEEP;
+         }
+         break;
+     case GenericEvent:
+         if (prev->xcookie.extension != xinput2_opcode) break;
+         if (prev->xcookie.evtype != XI_RawMotion) break;
++        if (thread_data->xi2_rawinput_only) break;
+         switch (next->type)
+         {
+         case GenericEvent:
+             if (next->xcookie.extension != xinput2_opcode) break;
+             if (next->xcookie.evtype != XI_RawMotion) break;
+-            if (x11drv_thread_data()->warp_serial) break;
++            if (thread_data->warp_serial) break;
+             return merge_raw_motion_events( prev->xcookie.data, next->xcookie.data );
+ #endif
+         }
+diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
+index 26e8b4eea92..ded877a140f 100644
+--- a/dlls/winex11.drv/mouse.c
++++ b/dlls/winex11.drv/mouse.c
+@@ -362,9 +362,9 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
+ 
+ 
+ /***********************************************************************
+- *              enable_xinput2
++ *              X11DRV_XInput2_Enable
+  */
+-static void enable_xinput2(void)
++void X11DRV_XInput2_Enable(void)
+ {
+ #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+     struct x11drv_thread_data *data = x11drv_thread_data();
+@@ -396,9 +396,21 @@ static void enable_xinput2(void)
+     mask.mask_len = sizeof(mask_bits);
+     mask.deviceid = XIAllMasterDevices;
+     memset( mask_bits, 0, sizeof(mask_bits) );
++
+     XISetMask( mask_bits, XI_DeviceChanged );
+     XISetMask( mask_bits, XI_RawMotion );
+-    XISetMask( mask_bits, XI_ButtonPress );
++
++    if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
++    {
++        XISetMask( mask_bits, XI_RawButtonPress );
++        XISetMask( mask_bits, XI_RawButtonRelease );
++        data->xi2_rawinput_only = TRUE;
++    }
++    else
++    {
++        XISetMask( mask_bits, XI_ButtonPress );
++        data->xi2_rawinput_only = FALSE;
++    }
+ 
+     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
+ 
+@@ -411,9 +423,9 @@ static void enable_xinput2(void)
+ }
+ 
+ /***********************************************************************
+- *              disable_xinput2
++ *              X11DRV_XInput2_Disable
+  */
+-static void disable_xinput2(void)
++void X11DRV_XInput2_Disable(void)
+ {
+ #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+     struct x11drv_thread_data *data = x11drv_thread_data();
+@@ -473,7 +485,7 @@ static BOOL grab_clipping_window( const RECT *clip )
+     }
+ 
+     /* enable XInput2 unless we are already clipping */
+-    if (!data->clip_hwnd) enable_xinput2();
++    if (!data->clip_hwnd) X11DRV_XInput2_Enable();
+ 
+     if (data->xi2_state != xi_enabled)
+     {
+@@ -503,7 +515,7 @@ static BOOL grab_clipping_window( const RECT *clip )
+ 
+     if (!clipping_cursor)
+     {
+-        disable_xinput2();
++        X11DRV_XInput2_Disable();
+         DestroyWindow( msg_hwnd );
+         return FALSE;
+     }
+@@ -584,7 +596,7 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND prev_clip_hwnd, HWND new_clip_hwnd )
+         TRACE( "clip hwnd reset from %p\n", hwnd );
+         data->clip_hwnd = 0;
+         data->clip_reset = GetTickCount();
+-        disable_xinput2();
++        X11DRV_XInput2_Disable();
+         DestroyWindow( hwnd );
+     }
+     else if (hwnd == GetForegroundWindow())  /* request to clip */
+@@ -723,7 +735,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
+         }
+         input->u.mi.dx += clip_rect.left;
+         input->u.mi.dy += clip_rect.top;
+-        __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
++        __wine_send_input( hwnd, input, SEND_HWMSG_WINDOW );
+         return;
+     }
+ 
+@@ -763,7 +775,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
+         SERVER_END_REQ;
+     }
+ 
+-    __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
++    __wine_send_input( hwnd, input, SEND_HWMSG_WINDOW );
+ }
+ 
+ #ifdef SONAME_LIBXCURSOR
+@@ -1709,7 +1721,7 @@ void move_resize_window( HWND hwnd, int dir )
+             input.u.mi.dwFlags     = button_up_flags[button - 1] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
+             input.u.mi.time        = GetTickCount();
+             input.u.mi.dwExtraInfo = 0;
+-            __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
++            __wine_send_input( hwnd, &input, SEND_HWMSG_WINDOW );
+         }
+ 
+         while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
+@@ -1892,6 +1904,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+     x_rel = &thread_data->x_rel_valuator;
+     y_rel = &thread_data->y_rel_valuator;
+ 
++    input.type             = INPUT_MOUSE;
+     input.u.mi.mouseData   = 0;
+     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
+     input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
+@@ -1927,10 +1940,53 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
+         return FALSE;
+     }
+ 
+-    TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
++    if (!thread_data->xi2_rawinput_only)
++    {
++        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
++        __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
++    }
++    else
++    {
++        TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
++        __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
++    }
++    return TRUE;
++}
+ 
+-    input.type = INPUT_MOUSE;
+-    __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
++/***********************************************************************
++ *           X11DRV_RawButtonEvent
++ */
++static BOOL X11DRV_RawButtonEvent( XGenericEventCookie *cookie )
++{
++    struct x11drv_thread_data *thread_data = x11drv_thread_data();
++    XIRawEvent *event = cookie->data;
++    int button = event->detail - 1;
++    INPUT input;
++
++    if (!device_mapping || device_mapping->deviceid != event->sourceid)
++        update_device_mapping( event->display, event->sourceid );
++
++    if (button >= 0 && device_mapping)
++        button = device_mapping->buttons[button] - 1;
++
++    if (button >= 0 && pointer_mapping)
++        button = pointer_mapping->buttons[button] - 1;
++
++    if (button < 0 || button >= NB_BUTTONS) return FALSE;
++    if (thread_data->xi2_state != xi_enabled) return FALSE;
++    if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
++
++    TRACE( "raw button %u (raw: %u) %s\n", button, event->detail, event->evtype == XI_RawButtonRelease ? "up" : "down" );
++
++    input.type             = INPUT_MOUSE;
++    input.u.mi.dx          = 0;
++    input.u.mi.dy          = 0;
++    input.u.mi.mouseData   = event->evtype == XI_RawButtonRelease ? button_up_data[button] : button_down_data[button];
++    input.u.mi.dwFlags     = event->evtype == XI_RawButtonRelease ? button_up_flags[button] : button_down_flags[button];
++    input.u.mi.time        = EVENT_x11_time_to_win32_time(event->time);
++    input.u.mi.dwExtraInfo = 0;
++
++    __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
+     return TRUE;
+ }
+ 
+@@ -2006,6 +2062,10 @@ BOOL X11DRV_GenericEvent( HWND hwnd, XEvent *xev )
+     case XI_RawMotion:
+         ret = X11DRV_RawMotion( event );
+         break;
++    case XI_RawButtonPress:
++    case XI_RawButtonRelease:
++        ret = X11DRV_RawButtonEvent( event );
++        break;
+ 
+     default:
+         TRACE( "Unhandled event %#x\n", event->evtype );
+diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
+index 73b1e90f12e..6febdc18b0a 100644
+--- a/dlls/winex11.drv/x11drv.h
++++ b/dlls/winex11.drv/x11drv.h
+@@ -196,6 +196,8 @@ extern BOOL CDECL X11DRV_UnrealizePalette( HPALETTE hpal ) DECLSPEC_HIDDEN;
+ 
+ extern void X11DRV_Xcursor_Init(void) DECLSPEC_HIDDEN;
+ extern void X11DRV_XInput2_Init(void) DECLSPEC_HIDDEN;
++extern void X11DRV_XInput2_Enable(void) DECLSPEC_HIDDEN;
++extern void X11DRV_XInput2_Disable(void) DECLSPEC_HIDDEN;
+ 
+ extern DWORD copy_image_bits( BITMAPINFO *info, BOOL is_r8g8b8, XImage *image,
+                               const struct gdi_image_bits *src_bits, struct gdi_image_bits *dst_bits,
+@@ -342,6 +344,7 @@ struct x11drv_thread_data
+     struct x11drv_valuator_data x_rel_valuator;
+     struct x11drv_valuator_data y_rel_valuator;
+     int      xi2_core_pointer;     /* XInput2 core pointer id */
++    int      xi2_rawinput_only;
+ };
+ 
+ extern struct x11drv_thread_data *x11drv_init_thread_data(void) DECLSPEC_HIDDEN;
+diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
+index 20e829ba64f..4eaedd1c556 100644
+--- a/dlls/winex11.drv/x11drv_main.c
++++ b/dlls/winex11.drv/x11drv_main.c
+@@ -632,6 +632,8 @@ void CDECL X11DRV_ThreadDetach(void)
+ 
+     if (data)
+     {
++        if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
++            X11DRV_XInput2_Disable();
+         if (data->xim) XCloseIM( data->xim );
+         if (data->font_set) XFreeFontSet( data->display, data->font_set );
+         XCloseDisplay( data->display );
+@@ -701,6 +703,8 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
+     TlsSetValue( thread_data_tls_index, data );
+ 
+     if (use_xim) X11DRV_SetupXIM();
++    if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
++        X11DRV_XInput2_Enable();
+ 
+     return data;
+ }
+-- 
+2.27.0
+
diff --git a/patches/user32-rawinput-mouse/0004-server-Add-send_hardware_message-flags-for-rawinput-.patch b/patches/user32-rawinput-mouse/0004-server-Add-send_hardware_message-flags-for-rawinput-.patch
deleted file mode 100644
index 6770f20a..00000000
--- a/patches/user32-rawinput-mouse/0004-server-Add-send_hardware_message-flags-for-rawinput-.patch
+++ /dev/null
@@ -1,128 +0,0 @@
-From 430580824e975bbda41884affd3e5fbf104ac6fe Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Mon, 26 Aug 2019 14:37:20 +0200
-Subject: [PATCH 04/12] server: Add send_hardware_message flags for rawinput
- translation.
-
----
- dlls/user32/input.c |  6 +++---
- server/protocol.def |  2 ++
- server/queue.c      | 20 ++++++++++++++------
- 3 files changed, 19 insertions(+), 9 deletions(-)
-
-diff --git a/dlls/user32/input.c b/dlls/user32/input.c
-index 340d20e58f9..7d947a98d0f 100644
---- a/dlls/user32/input.c
-+++ b/dlls/user32/input.c
-@@ -124,7 +124,7 @@ BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret )
-  */
- BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input )
- {
--    NTSTATUS status = send_hardware_message( hwnd, input, 0 );
-+    NTSTATUS status = send_hardware_message( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-     if (status) SetLastError( RtlNtStatusToDosError(status) );
-     return !status;
- }
-@@ -192,9 +192,9 @@ UINT WINAPI SendInput( UINT count, LPINPUT inputs, int size )
-             /* we need to update the coordinates to what the server expects */
-             INPUT input = inputs[i];
-             update_mouse_coords( &input );
--            status = send_hardware_message( 0, &input, SEND_HWMSG_INJECTED );
-+            status = send_hardware_message( 0, &input, SEND_HWMSG_INJECTED|SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-         }
--        else status = send_hardware_message( 0, &inputs[i], SEND_HWMSG_INJECTED );
-+        else status = send_hardware_message( 0, &inputs[i], SEND_HWMSG_INJECTED|SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
- 
-         if (status)
-         {
-diff --git a/server/protocol.def b/server/protocol.def
-index ae3702b150f..9f9f9197134 100644
---- a/server/protocol.def
-+++ b/server/protocol.def
-@@ -2370,6 +2370,8 @@ enum message_type
-     VARARG(keystate,bytes);    /* global state array for all the keys */
- @END
- #define SEND_HWMSG_INJECTED    0x01
-+#define SEND_HWMSG_RAWINPUT    0x02
-+#define SEND_HWMSG_WINDOW      0x04
- 
- 
- /* Get a message from the current queue */
-diff --git a/server/queue.c b/server/queue.c
-index af65b5f6b4c..9528453b190 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -1736,7 +1736,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
- 
- /* queue a hardware message for a mouse event */
- static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
--                                unsigned int origin, struct msg_queue *sender )
-+                                unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
- {
-     const struct rawinput_device *device;
-     struct hardware_msg_data *msg_data;
-@@ -1789,7 +1789,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
-         y = desktop->cursor.y;
-     }
- 
--    if ((device = current->process->rawinput_mouse))
-+    if ((device = current->process->rawinput_mouse) &&
-+        (req_flags & SEND_HWMSG_RAWINPUT))
-     {
-         if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
-         msg_data = msg->data;
-@@ -1808,6 +1809,9 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
-         queue_hardware_message( desktop, msg, 0 );
-     }
- 
-+    if (!(req_flags & SEND_HWMSG_WINDOW))
-+        return 0;
-+
-     for (i = 0; i < ARRAY_SIZE( messages ); i++)
-     {
-         if (!messages[i]) continue;
-@@ -1839,7 +1843,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
- 
- /* queue a hardware message for a keyboard event */
- static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
--                                   unsigned int origin, struct msg_queue *sender )
-+                                   unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
- {
-     struct hw_msg_source source = { IMDT_KEYBOARD, origin };
-     const struct rawinput_device *device;
-@@ -1915,7 +1919,8 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
-         break;
-     }
- 
--    if ((device = current->process->rawinput_kbd))
-+    if ((device = current->process->rawinput_kbd) &&
-+        (req_flags & SEND_HWMSG_RAWINPUT))
-     {
-         if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
-         msg_data = msg->data;
-@@ -1933,6 +1938,9 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
-         queue_hardware_message( desktop, msg, 0 );
-     }
- 
-+    if (!(req_flags & SEND_HWMSG_WINDOW))
-+        return 0;
-+
-     if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
-     msg_data = msg->data;
- 
-@@ -2494,10 +2502,10 @@ DECL_HANDLER(send_hardware_message)
-     switch (req->input.type)
-     {
-     case INPUT_MOUSE:
--        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender );
-+        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
-         break;
-     case INPUT_KEYBOARD:
--        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender );
-+        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
-         break;
-     case INPUT_HARDWARE:
-         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-mouse/0005-server-Broadcast-rawinput-message-if-request-flag-is.patch b/patches/user32-rawinput-mouse/0005-server-Broadcast-rawinput-message-if-request-flag-is.patch
deleted file mode 100644
index ad7245b9..00000000
--- a/patches/user32-rawinput-mouse/0005-server-Broadcast-rawinput-message-if-request-flag-is.patch
+++ /dev/null
@@ -1,171 +0,0 @@
-From 38723990a094b598e988408149d1e04dac9b571e Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Tue, 12 Nov 2019 12:41:55 +0100
-Subject: [PATCH] server: Broadcast rawinput message if request flag is
- SEND_HWMSG_RAWINPUT.
-
-If the request flag is equal to SEND_HWMSG_RAWINPUT, we broadcast the
-message to all listening processes -or at least to the foreground
-process until RIDEV_INPUTSINK is supported.
----
- server/queue.c | 101 +++++++++++++++++++++++++++++++++++++++----------
- 1 file changed, 80 insertions(+), 21 deletions(-)
-
-diff --git a/server/queue.c b/server/queue.c
-index 05d7af0206f..e1a01389fcf 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -1596,12 +1596,70 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
-     return 1;
- }
- 
-+struct rawinput_message
-+{
-+    struct desktop           *desktop;
-+    struct hw_msg_source      source;
-+    unsigned int              time;
-+    struct hardware_msg_data  data;
-+};
-+
-+static int queue_rawinput_message( struct process* process, void* user )
-+{
-+    const struct rawinput_message* raw_msg = user;
-+    const struct rawinput_device *device = NULL;
-+    struct desktop *desktop = NULL;
-+    struct thread *thread = NULL, *foreground = NULL;
-+    struct message *msg;
-+
-+    if (raw_msg->data.rawinput.type == RIM_TYPEMOUSE)
-+        device = process->rawinput_mouse;
-+    else if (raw_msg->data.rawinput.type == RIM_TYPEKEYBOARD)
-+        device = process->rawinput_kbd;
-+
-+    if (!device)
-+        goto done;
-+
-+    if (!(desktop = get_desktop_obj( process, process->desktop, 0 )) ||
-+        (raw_msg->desktop && desktop != raw_msg->desktop))
-+        goto done;
-+
-+    if (!device->target && !desktop->foreground_input)
-+        goto done;
-+
-+    if (!(thread = get_window_thread( device->target ? device->target : desktop->foreground_input->active )) ||
-+        process != thread->process)
-+        goto done;
-+
-+    /* FIXME: Implement RIDEV_INPUTSINK */
-+    if (!desktop->foreground_input || !(foreground = get_window_thread( desktop->foreground_input->active )) ||
-+        thread->process != foreground->process)
-+        goto done;
-+
-+    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time )))
-+        goto done;
-+
-+    msg->win    = device->target;
-+    msg->msg    = WM_INPUT;
-+    msg->wparam = RIM_INPUT;
-+    msg->lparam = 0;
-+    memcpy( msg->data, &raw_msg->data, sizeof(raw_msg->data) );
-+
-+    queue_hardware_message( desktop, msg, 0 );
-+
-+done:
-+    if (foreground) release_object( foreground );
-+    if (thread) release_object( thread );
-+    if (desktop) release_object( desktop );
-+    return 0;
-+}
-+
- /* queue a hardware message for a mouse event */
- static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
-                                 unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
- {
--    const struct rawinput_device *device;
-     struct hardware_msg_data *msg_data;
-+    struct rawinput_message raw_msg;
-     struct message *msg;
-     unsigned int i, time, flags;
-     struct hw_msg_source source = { IMDT_MOUSE, origin };
-@@ -1651,24 +1709,24 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
-         y = desktop->cursor.y;
-     }
- 
--    if ((device = current->process->rawinput_mouse) &&
--        (req_flags & SEND_HWMSG_RAWINPUT))
-+    if (req_flags & SEND_HWMSG_RAWINPUT)
-     {
--        if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
--        msg_data = msg->data;
--
--        msg->win       = device->target;
--        msg->msg       = WM_INPUT;
--        msg->wparam    = RIM_INPUT;
--        msg->lparam    = 0;
-+        raw_msg.desktop = desktop;
-+        raw_msg.source  = source;
-+        raw_msg.time    = time;
- 
-+        msg_data = &raw_msg.data;
-+        msg_data->info                = input->mouse.info;
-         msg_data->flags               = flags;
-         msg_data->rawinput.type       = RIM_TYPEMOUSE;
-         msg_data->rawinput.mouse.x    = x - desktop->cursor.x;
-         msg_data->rawinput.mouse.y    = y - desktop->cursor.y;
-         msg_data->rawinput.mouse.data = input->mouse.data;
- 
--        queue_hardware_message( desktop, msg, 0 );
-+        if (req_flags == SEND_HWMSG_RAWINPUT)
-+            enum_processes( queue_rawinput_message, &raw_msg );
-+        else
-+            queue_rawinput_message( current->process, &raw_msg );
-     }
- 
-     if (!(req_flags & SEND_HWMSG_WINDOW))
-@@ -1708,8 +1766,8 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
-                                    unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
- {
-     struct hw_msg_source source = { IMDT_KEYBOARD, origin };
--    const struct rawinput_device *device;
-     struct hardware_msg_data *msg_data;
-+    struct rawinput_message raw_msg;
-     struct message *msg;
-     unsigned char vkey = input->kbd.vkey;
-     unsigned int message_code, time;
-@@ -1781,23 +1839,24 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
-         break;
-     }
- 
--    if ((device = current->process->rawinput_kbd) &&
--        (req_flags & SEND_HWMSG_RAWINPUT))
-+    if (req_flags & SEND_HWMSG_RAWINPUT)
-     {
--        if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
--        msg_data = msg->data;
--
--        msg->win       = device->target;
--        msg->msg       = WM_INPUT;
--        msg->wparam    = RIM_INPUT;
-+        raw_msg.desktop = desktop;
-+        raw_msg.source  = source;
-+        raw_msg.time    = time;
- 
-+        msg_data = &raw_msg.data;
-+        msg_data->info                 = input->kbd.info;
-         msg_data->flags                = input->kbd.flags;
-         msg_data->rawinput.type        = RIM_TYPEKEYBOARD;
-         msg_data->rawinput.kbd.message = message_code;
-         msg_data->rawinput.kbd.vkey    = vkey;
-         msg_data->rawinput.kbd.scan    = input->kbd.scan;
- 
--        queue_hardware_message( desktop, msg, 0 );
-+        if (req_flags == SEND_HWMSG_RAWINPUT)
-+            enum_processes( queue_rawinput_message, &raw_msg );
-+        else
-+            queue_rawinput_message( current->process, &raw_msg );
-     }
- 
-     if (!(req_flags & SEND_HWMSG_WINDOW))
--- 
-2.27.0
-
diff --git a/patches/user32-rawinput-mouse/0006-user32-Add-__wine_send_input-flags-to-hint-raw-input.patch b/patches/user32-rawinput-mouse/0006-user32-Add-__wine_send_input-flags-to-hint-raw-input.patch
deleted file mode 100644
index e276e45e..00000000
--- a/patches/user32-rawinput-mouse/0006-user32-Add-__wine_send_input-flags-to-hint-raw-input.patch
+++ /dev/null
@@ -1,201 +0,0 @@
-From cb1312120a60b6b70ac45197b0c0ac2ed834fbb6 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Mon, 26 Aug 2019 15:20:32 +0200
-Subject: [PATCH] user32: Add __wine_send_input flags to hint raw input
- translation.
-
----
- dlls/user32/input.c             | 4 ++--
- dlls/user32/user32.spec         | 2 +-
- dlls/wineandroid.drv/keyboard.c | 2 +-
- dlls/wineandroid.drv/window.c   | 4 ++--
- dlls/winemac.drv/ime.c          | 5 +++--
- dlls/winemac.drv/keyboard.c     | 2 +-
- dlls/winemac.drv/mouse.c        | 2 +-
- dlls/winex11.drv/keyboard.c     | 2 +-
- dlls/winex11.drv/mouse.c        | 8 ++++----
- include/winuser.h               | 2 +-
- 10 files changed, 17 insertions(+), 16 deletions(-)
-
-diff --git a/dlls/user32/input.c b/dlls/user32/input.c
-index 7d947a98d0f..97a5ada922e 100644
---- a/dlls/user32/input.c
-+++ b/dlls/user32/input.c
-@@ -122,9 +122,9 @@ BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret )
-  *
-  * Internal SendInput function to allow the graphics driver to inject real events.
-  */
--BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input )
-+BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, UINT flags )
- {
--    NTSTATUS status = send_hardware_message( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-+    NTSTATUS status = send_hardware_message( hwnd, input, flags );
-     if (status) SetLastError( RtlNtStatusToDosError(status) );
-     return !status;
- }
-diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
-index c08ad5ff4f9..b59ba381334 100644
---- a/dlls/user32/user32.spec
-+++ b/dlls/user32/user32.spec
-@@ -833,5 +833,5 @@
- # All functions must be prefixed with '__wine_' (for internal functions)
- # or 'wine_' (for user-visible functions) to avoid namespace conflicts.
- #
--@ cdecl __wine_send_input(long ptr)
-+@ cdecl __wine_send_input(long ptr long)
- @ cdecl __wine_set_pixel_format(long long)
-diff --git a/dlls/wineandroid.drv/keyboard.c b/dlls/wineandroid.drv/keyboard.c
-index a0f3257f74b..1af8a98f1f9 100644
---- a/dlls/wineandroid.drv/keyboard.c
-+++ b/dlls/wineandroid.drv/keyboard.c
-@@ -680,7 +680,7 @@ static void send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD flags )
-     input.u.ki.time        = 0;
-     input.u.ki.dwExtraInfo = 0;
- 
--    __wine_send_input( hwnd, &input );
-+    __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
- }
- 
- /***********************************************************************
-diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
-index 2fc258dfd90..d96f001432d 100644
---- a/dlls/wineandroid.drv/window.c
-+++ b/dlls/wineandroid.drv/window.c
-@@ -524,7 +524,7 @@ static int process_events( DWORD mask )
-                     }
-                     SERVER_END_REQ;
-                 }
--                __wine_send_input( capture ? capture : event->data.motion.hwnd, &event->data.motion.input );
-+                __wine_send_input( capture ? capture : event->data.motion.hwnd, &event->data.motion.input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-             }
-             break;
- 
-@@ -538,7 +538,7 @@ static int process_events( DWORD mask )
-                       event->data.kbd.input.u.ki.wVk, event->data.kbd.input.u.ki.wVk,
-                       event->data.kbd.input.u.ki.wScan );
-             update_keyboard_lock_state( event->data.kbd.input.u.ki.wVk, event->data.kbd.lock_state );
--            __wine_send_input( 0, &event->data.kbd.input );
-+            __wine_send_input( 0, &event->data.kbd.input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-             break;
- 
-         default:
-diff --git a/dlls/winemac.drv/ime.c b/dlls/winemac.drv/ime.c
-index dabe6654f98..3593374a613 100644
---- a/dlls/winemac.drv/ime.c
-+++ b/dlls/winemac.drv/ime.c
-@@ -42,6 +42,7 @@
- #include "winuser.h"
- #include "imm.h"
- #include "ddk/imm.h"
-+#include "wine/server.h"
- 
- WINE_DEFAULT_DEBUG_CHANNEL(imm);
- 
-@@ -1427,10 +1428,10 @@ void macdrv_im_set_text(const macdrv_event *event)
-             {
-                 input.ki.wScan      = chars[i];
-                 input.ki.dwFlags    = KEYEVENTF_UNICODE;
--                __wine_send_input(hwnd, &input);
-+                __wine_send_input(hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
- 
-                 input.ki.dwFlags    = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
--                __wine_send_input(hwnd, &input);
-+                __wine_send_input(hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
-             }
-         }
- 
-diff --git a/dlls/winemac.drv/keyboard.c b/dlls/winemac.drv/keyboard.c
-index bb408cb20c5..41919baafc7 100644
---- a/dlls/winemac.drv/keyboard.c
-+++ b/dlls/winemac.drv/keyboard.c
-@@ -929,7 +929,7 @@ static void macdrv_send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD fl
-     input.ki.time           = time;
-     input.ki.dwExtraInfo    = 0;
- 
--    __wine_send_input(hwnd, &input);
-+    __wine_send_input(hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
- }
- 
- 
-diff --git a/dlls/winemac.drv/mouse.c b/dlls/winemac.drv/mouse.c
-index dd6443fe1ba..91cafdf1362 100644
---- a/dlls/winemac.drv/mouse.c
-+++ b/dlls/winemac.drv/mouse.c
-@@ -165,7 +165,7 @@ static void send_mouse_input(HWND hwnd, macdrv_window cocoa_window, UINT flags,
-     input.mi.time           = time;
-     input.mi.dwExtraInfo    = 0;
- 
--    __wine_send_input(top_level_hwnd, &input);
-+    __wine_send_input(top_level_hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW);
- }
- 
- 
-diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
-index 48da12c0292..2a3bed787ab 100644
---- a/dlls/winex11.drv/keyboard.c
-+++ b/dlls/winex11.drv/keyboard.c
-@@ -1148,7 +1148,7 @@ static void X11DRV_send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD f
-     input.u.ki.time        = time;
-     input.u.ki.dwExtraInfo = 0;
- 
--    __wine_send_input( hwnd, &input );
-+    __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
- }
- 
- 
-diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index 8e1eb6d5e0e..96e04509e73 100644
---- a/dlls/winex11.drv/mouse.c
-+++ b/dlls/winex11.drv/mouse.c
-@@ -659,7 +659,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
-         }
-         input->u.mi.dx += clip_rect.left;
-         input->u.mi.dy += clip_rect.top;
--        __wine_send_input( hwnd, input );
-+        __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-         return;
-     }
- 
-@@ -699,7 +699,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
-         SERVER_END_REQ;
-     }
- 
--    __wine_send_input( hwnd, input );
-+    __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
- }
- 
- #ifdef SONAME_LIBXCURSOR
-@@ -1645,7 +1645,7 @@ void move_resize_window( HWND hwnd, int dir )
-             input.u.mi.dwFlags     = button_up_flags[button - 1] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
-             input.u.mi.time        = GetTickCount();
-             input.u.mi.dwExtraInfo = 0;
--            __wine_send_input( hwnd, &input );
-+            __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-         }
- 
-         while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
-@@ -1884,7 +1884,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
- 
-     input.type = INPUT_MOUSE;
--    __wine_send_input( 0, &input );
-+    __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-     return TRUE;
- }
- 
-diff --git a/include/winuser.h b/include/winuser.h
-index 51c73d25c2f..10cebfa97d0 100644
---- a/include/winuser.h
-+++ b/include/winuser.h
-@@ -4389,7 +4389,7 @@ static inline BOOL WINAPI SetRectEmpty(LPRECT rect)
- WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
- 
- #ifdef __WINESRC__
--WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input );
-+WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, UINT flags );
- #endif
- 
- #ifdef __cplusplus
--- 
-2.24.0
-
diff --git a/patches/user32-rawinput-mouse/0007-winex11.drv-Advertise-XInput2-version-2.1-support.patch b/patches/user32-rawinput-mouse/0007-winex11.drv-Advertise-XInput2-version-2.1-support.patch
deleted file mode 100644
index 54b9508d..00000000
--- a/patches/user32-rawinput-mouse/0007-winex11.drv-Advertise-XInput2-version-2.1-support.patch
+++ /dev/null
@@ -1,146 +0,0 @@
-From 9038e4871284e636f277be8fc8a2a901049bcaf6 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Fri, 2 Aug 2019 02:24:32 -0400
-Subject: [PATCH 07/12] winex11.drv: Advertise XInput2 version 2.1 support.
-
-Under XInput2 protocol version < 2.1, RawEvents are not supposed to be
-sent if a pointer grab is active. However slave device events are still
-received regardless of this specification and Wine implemented a
-workaround to receive RawEvents during pointer grabs by listening to
-these slave device events. Then, as soon as a mouse button is pressed
-only the grabbing client will receive the raw motion events.
-
-By advertising the support of XInput2 version >= 2.1, where RawEvents
-are sent even during pointer grabs, we ensure to receive the RawMotion
-events from the desktop window thread, even if a mouse grab is active.
-
-It is now also possible to simplify the code by listening to master
-device events only and get rid of slave device id tracking.
----
- dlls/winex11.drv/mouse.c  | 49 ++++++++-------------------------------
- dlls/winex11.drv/x11drv.h |  3 ---
- 2 files changed, 10 insertions(+), 42 deletions(-)
-
-diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index 96e04509e73..105db08a78a 100644
---- a/dlls/winex11.drv/mouse.c
-+++ b/dlls/winex11.drv/mouse.c
-@@ -304,12 +304,16 @@ static void enable_xinput2(void)
- 
-     if (data->xi2_state == xi_unknown)
-     {
--        int major = 2, minor = 0;
--        if (!pXIQueryVersion( data->display, &major, &minor )) data->xi2_state = xi_disabled;
-+        int major = 2, minor = 1;
-+        if (!pXIQueryVersion( data->display, &major, &minor ) && major == 2 && minor > 0)
-+        {
-+            TRACE( "XInput2 v%d.%d available\n", major, minor );
-+            data->xi2_state = xi_disabled;
-+        }
-         else
-         {
-             data->xi2_state = xi_unavailable;
--            WARN( "X Input 2 not available\n" );
-+            WARN( "XInput v2.1 not available\n" );
-         }
-     }
-     if (data->xi2_state == xi_unavailable) return;
-@@ -317,7 +321,7 @@ static void enable_xinput2(void)
- 
-     mask.mask     = mask_bits;
-     mask.mask_len = sizeof(mask_bits);
--    mask.deviceid = XIAllDevices;
-+    mask.deviceid = XIAllMasterDevices;
-     memset( mask_bits, 0, sizeof(mask_bits) );
-     XISetMask( mask_bits, XI_DeviceChanged );
-     XISetMask( mask_bits, XI_RawMotion );
-@@ -329,16 +333,6 @@ static void enable_xinput2(void)
-     update_relative_valuators( pointer_info->classes, pointer_info->num_classes );
-     pXIFreeDeviceInfo( pointer_info );
- 
--    /* This device info list is only used to find the initial current slave if
--     * no XI_DeviceChanged events happened. If any hierarchy change occurred that
--     * might be relevant here (eg. user switching mice after (un)plugging), a
--     * XI_DeviceChanged event will point us to the right slave. So this list is
--     * safe to be obtained statically at enable_xinput2() time.
--     */
--    if (data->xi2_devices) pXIFreeDeviceInfo( data->xi2_devices );
--    data->xi2_devices = pXIQueryDevice( data->display, XIAllDevices, &data->xi2_device_count );
--    data->xi2_current_slave = 0;
--
-     data->xi2_state = xi_enabled;
- #endif
- }
-@@ -359,15 +353,12 @@ static void disable_xinput2(void)
- 
-     mask.mask = NULL;
-     mask.mask_len = 0;
--    mask.deviceid = XIAllDevices;
-+    mask.deviceid = XIAllMasterDevices;
- 
-     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
--    pXIFreeDeviceInfo( data->xi2_devices );
-     data->x_rel_valuator.number = -1;
-     data->y_rel_valuator.number = -1;
--    data->xi2_devices = NULL;
-     data->xi2_core_pointer = 0;
--    data->xi2_current_slave = 0;
- #endif
- }
- 
-@@ -1801,7 +1792,6 @@ static BOOL X11DRV_DeviceChanged( XGenericEventCookie *xev )
-     if (event->reason != XISlaveSwitch) return FALSE;
- 
-     update_relative_valuators( event->classes, event->num_classes );
--    data->xi2_current_slave = event->sourceid;
-     return TRUE;
- }
- 
-@@ -1822,26 +1812,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     if (thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0) return FALSE;
-     if (!event->valuators.mask_len) return FALSE;
-     if (thread_data->xi2_state != xi_enabled) return FALSE;
--
--    /* If there is no slave currently detected, no previous motion nor device
--     * change events were received. Look it up now on the device list in this
--     * case.
--     */
--    if (!thread_data->xi2_current_slave)
--    {
--        XIDeviceInfo *devices = thread_data->xi2_devices;
--
--        for (i = 0; i < thread_data->xi2_device_count; i++)
--        {
--            if (devices[i].use != XISlavePointer) continue;
--            if (devices[i].deviceid != event->deviceid) continue;
--            if (devices[i].attachment != thread_data->xi2_core_pointer) continue;
--            thread_data->xi2_current_slave = event->deviceid;
--            break;
--        }
--    }
--
--    if (event->deviceid != thread_data->xi2_current_slave) return FALSE;
-+    if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
- 
-     x_rel = &thread_data->x_rel_valuator;
-     y_rel = &thread_data->y_rel_valuator;
-diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
-index cca87433264..432dd5909ca 100644
---- a/dlls/winex11.drv/x11drv.h
-+++ b/dlls/winex11.drv/x11drv.h
-@@ -340,12 +340,9 @@ struct x11drv_thread_data
-     DWORD    clip_reset;           /* time when clipping was last reset */
-     HKL      kbd_layout;           /* active keyboard layout */
-     enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled } xi2_state; /* XInput2 state */
--    void    *xi2_devices;          /* list of XInput2 devices (valid when state is enabled) */
--    int      xi2_device_count;
-     struct x11drv_valuator_data x_rel_valuator;
-     struct x11drv_valuator_data y_rel_valuator;
-     int      xi2_core_pointer;     /* XInput2 core pointer id */
--    int      xi2_current_slave;    /* Current slave driving the Core pointer */
- };
- 
- extern struct x11drv_thread_data *x11drv_init_thread_data(void) DECLSPEC_HIDDEN;
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-mouse/0008-winex11.drv-Keep-track-of-pointer-and-device-button-.patch b/patches/user32-rawinput-mouse/0008-winex11.drv-Keep-track-of-pointer-and-device-button-.patch
deleted file mode 100644
index da90ebd1..00000000
--- a/patches/user32-rawinput-mouse/0008-winex11.drv-Keep-track-of-pointer-and-device-button-.patch
+++ /dev/null
@@ -1,224 +0,0 @@
-From c65d46aba7d72f8bde0d74b110382a4383dde085 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 19 Dec 2019 22:34:44 +0100
-Subject: [PATCH] winex11.drv: Keep track of pointer and device button
- mappings.
-
-We are going to receive raw button events and we will need to apply the
-correct button mappings ourselves.
-
-Original patch by Andrew Eikum <aeikum@codeweavers.com>.
----
- dlls/winex11.drv/keyboard.c    | 23 ++++++---
- dlls/winex11.drv/mouse.c       | 89 +++++++++++++++++++++++++++++++++-
- dlls/winex11.drv/x11drv.h      |  1 +
- dlls/winex11.drv/x11drv_main.c |  1 +
- 4 files changed, 106 insertions(+), 8 deletions(-)
-
-diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
-index 2a3bed787ab..37c96c926f4 100644
---- a/dlls/winex11.drv/keyboard.c
-+++ b/dlls/winex11.drv/keyboard.c
-@@ -1977,13 +1977,24 @@ BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
- {
-     HWND hwnd;
- 
--    XRefreshKeyboardMapping(&event->xmapping);
--    X11DRV_InitKeyboard( event->xmapping.display );
-+    switch (event->xmapping.request)
-+    {
-+    case MappingModifier:
-+    case MappingKeyboard:
-+        XRefreshKeyboardMapping( &event->xmapping );
-+        X11DRV_InitKeyboard( event->xmapping.display );
-+
-+        hwnd = GetFocus();
-+        if (!hwnd) hwnd = GetActiveWindow();
-+        PostMessageW(hwnd, WM_INPUTLANGCHANGEREQUEST,
-+                     0 /*FIXME*/, (LPARAM)X11DRV_GetKeyboardLayout(0));
-+        break;
-+
-+    case MappingPointer:
-+        X11DRV_InitMouse( event->xmapping.display );
-+        break;
-+    }
- 
--    hwnd = GetFocus();
--    if (!hwnd) hwnd = GetActiveWindow();
--    PostMessageW(hwnd, WM_INPUTLANGCHANGEREQUEST,
--                 0 /*FIXME*/, (LPARAM)X11DRV_GetKeyboardLayout(0));
-     return TRUE;
- }
- 
-diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index b420f4bbd4b..8691cc01531 100644
---- a/dlls/winex11.drv/mouse.c
-+++ b/dlls/winex11.drv/mouse.c
-@@ -25,6 +25,9 @@
- #include <X11/Xlib.h>
- #include <X11/cursorfont.h>
- #include <stdarg.h>
-+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-+#include <X11/extensions/XInput.h>
-+#endif
- #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
- #include <X11/extensions/XInput2.h>
- #endif
-@@ -142,6 +145,14 @@ MAKE_FUNCPTR(XISelectEvents);
- #undef MAKE_FUNCPTR
- #endif
- 
-+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-+#define MAKE_FUNCPTR(f) static typeof(f) * p##f
-+MAKE_FUNCPTR(XOpenDevice);
-+MAKE_FUNCPTR(XCloseDevice);
-+MAKE_FUNCPTR(XGetDeviceButtonMapping);
-+#undef MAKE_FUNCPTR
-+#endif
-+
- /***********************************************************************
-  *		X11DRV_Xcursor_Init
-  *
-@@ -247,6 +258,70 @@ void sync_window_cursor( Window window )
-     set_window_cursor( window, cursor );
- }
- 
-+struct mouse_button_mapping
-+{
-+    int deviceid;
-+    unsigned int button_count;
-+    unsigned char buttons[256];
-+};
-+
-+static struct mouse_button_mapping *pointer_mapping;
-+static struct mouse_button_mapping *device_mapping;
-+
-+static void update_pointer_mapping( Display *display )
-+{
-+    struct mouse_button_mapping *tmp;
-+
-+    if (!(tmp = HeapAlloc( GetProcessHeap(), 0, sizeof(*tmp) )))
-+    {
-+        WARN("Unable to allocate device mapping.\n");
-+        return;
-+    }
-+
-+    tmp->button_count = ARRAY_SIZE( tmp->buttons );
-+    tmp->button_count = XGetPointerMapping( display, tmp->buttons, tmp->button_count );
-+
-+    tmp = InterlockedExchangePointer( (void**)&pointer_mapping, tmp );
-+
-+    HeapFree( GetProcessHeap(), 0, tmp );
-+}
-+
-+static void update_device_mapping( Display *display, int deviceid )
-+{
-+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-+    struct mouse_button_mapping *tmp;
-+    XDevice *device;
-+
-+    if (!(device = pXOpenDevice( display, deviceid )))
-+    {
-+        WARN( "Unable to open cursor device %d\n", deviceid );
-+        return;
-+    }
-+
-+    if (!(tmp = HeapAlloc( GetProcessHeap(), 0, sizeof(*tmp) )))
-+    {
-+        WARN( "Unable to allocate device mapping.\n" );
-+        pXCloseDevice( display, device );
-+        return;
-+    }
-+
-+    tmp->deviceid = deviceid;
-+    tmp->button_count = ARRAY_SIZE( tmp->buttons );
-+    tmp->button_count = pXGetDeviceButtonMapping( display, device, tmp->buttons, tmp->button_count );
-+
-+    tmp = InterlockedExchangePointer( (void**)&device_mapping, tmp );
-+
-+    HeapFree( GetProcessHeap(), 0, tmp );
-+
-+    pXCloseDevice( display, device );
-+#endif
-+}
-+
-+void X11DRV_InitMouse( Display *display )
-+{
-+    update_pointer_mapping( display );
-+}
-+
- #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
- /***********************************************************************
-  *              update_relative_valuators
-@@ -1790,6 +1865,8 @@ static BOOL X11DRV_DeviceChanged( XGenericEventCookie *xev )
-     if (event->reason != XISlaveSwitch) return FALSE;
- 
-     update_relative_valuators( event->classes, event->num_classes );
-+    update_device_mapping( event->display, event->sourceid );
-+
-     return TRUE;
- }
- 
-@@ -1859,13 +1936,12 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
- 
- #endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
- 
--
- /***********************************************************************
-  *              X11DRV_XInput2_Init
-  */
- void X11DRV_XInput2_Init(void)
- {
--#if defined(SONAME_LIBXI) && defined(HAVE_X11_EXTENSIONS_XINPUT2_H)
-+#if defined(SONAME_LIBXI)
-     int event, error;
-     void *libxi_handle = dlopen( SONAME_LIBXI, RTLD_NOW );
- 
-@@ -1881,11 +1957,20 @@ void X11DRV_XInput2_Init(void)
-         return; \
-     }
- 
-+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-     LOAD_FUNCPTR(XIGetClientPointer);
-     LOAD_FUNCPTR(XIFreeDeviceInfo);
-     LOAD_FUNCPTR(XIQueryDevice);
-     LOAD_FUNCPTR(XIQueryVersion);
-     LOAD_FUNCPTR(XISelectEvents);
-+#endif
-+
-+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
-+    LOAD_FUNCPTR(XOpenDevice);
-+    LOAD_FUNCPTR(XCloseDevice);
-+    LOAD_FUNCPTR(XGetDeviceButtonMapping);
-+#endif
-+
- #undef LOAD_FUNCPTR
- 
-     xinput2_available = XQueryExtension( gdi_display, "XInputExtension", &xinput2_opcode, &event, &error );
-diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
-index c2c63278a07..01f36c04862 100644
---- a/dlls/winex11.drv/x11drv.h
-+++ b/dlls/winex11.drv/x11drv.h
-@@ -630,6 +630,7 @@ extern void retry_grab_clipping_window(void) DECLSPEC_HIDDEN;
- extern BOOL clip_fullscreen_window( HWND hwnd, BOOL reset ) DECLSPEC_HIDDEN;
- extern void move_resize_window( HWND hwnd, int dir ) DECLSPEC_HIDDEN;
- extern void X11DRV_InitKeyboard( Display *display ) DECLSPEC_HIDDEN;
-+extern void X11DRV_InitMouse( Display *display ) DECLSPEC_HIDDEN;
- extern DWORD CDECL X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles, DWORD timeout,
-                                                        DWORD mask, DWORD flags ) DECLSPEC_HIDDEN;
- 
-diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
-index e6e61e801e1..20e829ba64f 100644
---- a/dlls/winex11.drv/x11drv_main.c
-+++ b/dlls/winex11.drv/x11drv_main.c
-@@ -615,6 +615,7 @@ static BOOL process_attach(void)
-     if (use_xkb) use_xkb = XkbUseExtension( gdi_display, NULL, NULL );
- #endif
-     X11DRV_InitKeyboard( gdi_display );
-+    X11DRV_InitMouse( gdi_display );
-     if (use_xim) use_xim = X11DRV_InitXIM( input_style );
- 
-     X11DRV_DisplayDevices_Init(FALSE);
--- 
-2.25.1
-
diff --git a/patches/user32-rawinput-mouse/0009-winex11.drv-Listen-to-RawMotion-and-RawButton-events.patch b/patches/user32-rawinput-mouse/0009-winex11.drv-Listen-to-RawMotion-and-RawButton-events.patch
deleted file mode 100644
index 5bddd117..00000000
--- a/patches/user32-rawinput-mouse/0009-winex11.drv-Listen-to-RawMotion-and-RawButton-events.patch
+++ /dev/null
@@ -1,282 +0,0 @@
-From d337c8de3de6a0b7ff16cada895d2490d3240b53 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Wed, 11 Sep 2019 10:15:20 +0200
-Subject: [PATCH] winex11.drv: Listen to RawMotion and RawButton* events in the
- desktop thread.
-
-We still need to send "normal" input from the clipping window thread
-to trigger low-level hooks callbacks when clipping cursor. This is for
-instance used in our dinput implementation.
----
- dlls/winex11.drv/event.c       | 10 +++-
- dlls/winex11.drv/mouse.c       | 88 ++++++++++++++++++++++++++++------
- dlls/winex11.drv/x11drv.h      |  3 ++
- dlls/winex11.drv/x11drv_main.c |  4 ++
- 4 files changed, 89 insertions(+), 16 deletions(-)
-
-diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
-index 07f7a1ad502..d722ba9d7cc 100644
---- a/dlls/winex11.drv/event.c
-+++ b/dlls/winex11.drv/event.c
-@@ -321,6 +321,10 @@ static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawE
-  */
- static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
- {
-+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
-+#endif
-+
-     switch (prev->type)
-     {
-     case ConfigureNotify:
-@@ -352,19 +356,21 @@ static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
-         case GenericEvent:
-             if (next->xcookie.extension != xinput2_opcode) break;
-             if (next->xcookie.evtype != XI_RawMotion) break;
--            if (x11drv_thread_data()->warp_serial) break;
-+            if (thread_data->xi2_rawinput_only) break;
-+            if (thread_data->warp_serial) break;
-             return MERGE_KEEP;
-         }
-         break;
-     case GenericEvent:
-         if (prev->xcookie.extension != xinput2_opcode) break;
-         if (prev->xcookie.evtype != XI_RawMotion) break;
-+        if (thread_data->xi2_rawinput_only) break;
-         switch (next->type)
-         {
-         case GenericEvent:
-             if (next->xcookie.extension != xinput2_opcode) break;
-             if (next->xcookie.evtype != XI_RawMotion) break;
--            if (x11drv_thread_data()->warp_serial) break;
-+            if (thread_data->warp_serial) break;
-             return merge_raw_motion_events( prev->xcookie.data, next->xcookie.data );
- #endif
-         }
-diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
-index 26e8b4eea92..ded877a140f 100644
---- a/dlls/winex11.drv/mouse.c
-+++ b/dlls/winex11.drv/mouse.c
-@@ -362,9 +362,9 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
- 
- 
- /***********************************************************************
-- *              enable_xinput2
-+ *              X11DRV_XInput2_Enable
-  */
--static void enable_xinput2(void)
-+void X11DRV_XInput2_Enable(void)
- {
- #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-     struct x11drv_thread_data *data = x11drv_thread_data();
-@@ -396,9 +396,21 @@ static void enable_xinput2(void)
-     mask.mask_len = sizeof(mask_bits);
-     mask.deviceid = XIAllMasterDevices;
-     memset( mask_bits, 0, sizeof(mask_bits) );
-+
-     XISetMask( mask_bits, XI_DeviceChanged );
-     XISetMask( mask_bits, XI_RawMotion );
--    XISetMask( mask_bits, XI_ButtonPress );
-+
-+    if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
-+    {
-+        XISetMask( mask_bits, XI_RawButtonPress );
-+        XISetMask( mask_bits, XI_RawButtonRelease );
-+        data->xi2_rawinput_only = TRUE;
-+    }
-+    else
-+    {
-+        XISetMask( mask_bits, XI_ButtonPress );
-+        data->xi2_rawinput_only = FALSE;
-+    }
- 
-     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
- 
-@@ -411,9 +423,9 @@ static void enable_xinput2(void)
- }
- 
- /***********************************************************************
-- *              disable_xinput2
-+ *              X11DRV_XInput2_Disable
-  */
--static void disable_xinput2(void)
-+void X11DRV_XInput2_Disable(void)
- {
- #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-     struct x11drv_thread_data *data = x11drv_thread_data();
-@@ -473,7 +485,7 @@ static BOOL grab_clipping_window( const RECT *clip )
-     }
- 
-     /* enable XInput2 unless we are already clipping */
--    if (!data->clip_hwnd) enable_xinput2();
-+    if (!data->clip_hwnd) X11DRV_XInput2_Enable();
- 
-     if (data->xi2_state != xi_enabled)
-     {
-@@ -503,7 +515,7 @@ static BOOL grab_clipping_window( const RECT *clip )
- 
-     if (!clipping_cursor)
-     {
--        disable_xinput2();
-+        X11DRV_XInput2_Disable();
-         DestroyWindow( msg_hwnd );
-         return FALSE;
-     }
-@@ -584,7 +596,7 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND prev_clip_hwnd, HWND new_clip_hwnd )
-         TRACE( "clip hwnd reset from %p\n", hwnd );
-         data->clip_hwnd = 0;
-         data->clip_reset = GetTickCount();
--        disable_xinput2();
-+        X11DRV_XInput2_Disable();
-         DestroyWindow( hwnd );
-     }
-     else if (hwnd == GetForegroundWindow())  /* request to clip */
-@@ -723,7 +735,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
-         }
-         input->u.mi.dx += clip_rect.left;
-         input->u.mi.dy += clip_rect.top;
--        __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-+        __wine_send_input( hwnd, input, SEND_HWMSG_WINDOW );
-         return;
-     }
- 
-@@ -763,7 +775,7 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
-         SERVER_END_REQ;
-     }
- 
--    __wine_send_input( hwnd, input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-+    __wine_send_input( hwnd, input, SEND_HWMSG_WINDOW );
- }
- 
- #ifdef SONAME_LIBXCURSOR
-@@ -1709,7 +1721,7 @@ void move_resize_window( HWND hwnd, int dir )
-             input.u.mi.dwFlags     = button_up_flags[button - 1] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
-             input.u.mi.time        = GetTickCount();
-             input.u.mi.dwExtraInfo = 0;
--            __wine_send_input( hwnd, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-+            __wine_send_input( hwnd, &input, SEND_HWMSG_WINDOW );
-         }
- 
-         while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
-@@ -1892,6 +1904,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-     x_rel = &thread_data->x_rel_valuator;
-     y_rel = &thread_data->y_rel_valuator;
- 
-+    input.type             = INPUT_MOUSE;
-     input.u.mi.mouseData   = 0;
-     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
-     input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
-@@ -1927,10 +1940,53 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
-         return FALSE;
-     }
- 
--    TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-+    if (!thread_data->xi2_rawinput_only)
-+    {
-+        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-+        __wine_send_input( 0, &input, SEND_HWMSG_WINDOW );
-+    }
-+    else
-+    {
-+        TRACE( "raw pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-+        __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
-+    }
-+    return TRUE;
-+}
- 
--    input.type = INPUT_MOUSE;
--    __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT|SEND_HWMSG_WINDOW );
-+/***********************************************************************
-+ *           X11DRV_RawButtonEvent
-+ */
-+static BOOL X11DRV_RawButtonEvent( XGenericEventCookie *cookie )
-+{
-+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
-+    XIRawEvent *event = cookie->data;
-+    int button = event->detail - 1;
-+    INPUT input;
-+
-+    if (!device_mapping || device_mapping->deviceid != event->sourceid)
-+        update_device_mapping( event->display, event->sourceid );
-+
-+    if (button >= 0 && device_mapping)
-+        button = device_mapping->buttons[button] - 1;
-+
-+    if (button >= 0 && pointer_mapping)
-+        button = pointer_mapping->buttons[button] - 1;
-+
-+    if (button < 0 || button >= NB_BUTTONS) return FALSE;
-+    if (thread_data->xi2_state != xi_enabled) return FALSE;
-+    if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
-+
-+    TRACE( "raw button %u (raw: %u) %s\n", button, event->detail, event->evtype == XI_RawButtonRelease ? "up" : "down" );
-+
-+    input.type             = INPUT_MOUSE;
-+    input.u.mi.dx          = 0;
-+    input.u.mi.dy          = 0;
-+    input.u.mi.mouseData   = event->evtype == XI_RawButtonRelease ? button_up_data[button] : button_down_data[button];
-+    input.u.mi.dwFlags     = event->evtype == XI_RawButtonRelease ? button_up_flags[button] : button_down_flags[button];
-+    input.u.mi.time        = EVENT_x11_time_to_win32_time(event->time);
-+    input.u.mi.dwExtraInfo = 0;
-+
-+    __wine_send_input( 0, &input, SEND_HWMSG_RAWINPUT );
-     return TRUE;
- }
- 
-@@ -2006,6 +2062,10 @@ BOOL X11DRV_GenericEvent( HWND hwnd, XEvent *xev )
-     case XI_RawMotion:
-         ret = X11DRV_RawMotion( event );
-         break;
-+    case XI_RawButtonPress:
-+    case XI_RawButtonRelease:
-+        ret = X11DRV_RawButtonEvent( event );
-+        break;
- 
-     default:
-         TRACE( "Unhandled event %#x\n", event->evtype );
-diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
-index 73b1e90f12e..6febdc18b0a 100644
---- a/dlls/winex11.drv/x11drv.h
-+++ b/dlls/winex11.drv/x11drv.h
-@@ -196,6 +196,8 @@ extern BOOL CDECL X11DRV_UnrealizePalette( HPALETTE hpal ) DECLSPEC_HIDDEN;
- 
- extern void X11DRV_Xcursor_Init(void) DECLSPEC_HIDDEN;
- extern void X11DRV_XInput2_Init(void) DECLSPEC_HIDDEN;
-+extern void X11DRV_XInput2_Enable(void) DECLSPEC_HIDDEN;
-+extern void X11DRV_XInput2_Disable(void) DECLSPEC_HIDDEN;
- 
- extern DWORD copy_image_bits( BITMAPINFO *info, BOOL is_r8g8b8, XImage *image,
-                               const struct gdi_image_bits *src_bits, struct gdi_image_bits *dst_bits,
-@@ -342,6 +344,7 @@ struct x11drv_thread_data
-     struct x11drv_valuator_data x_rel_valuator;
-     struct x11drv_valuator_data y_rel_valuator;
-     int      xi2_core_pointer;     /* XInput2 core pointer id */
-+    int      xi2_rawinput_only;
- };
- 
- extern struct x11drv_thread_data *x11drv_init_thread_data(void) DECLSPEC_HIDDEN;
-diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
-index 20e829ba64f..4eaedd1c556 100644
---- a/dlls/winex11.drv/x11drv_main.c
-+++ b/dlls/winex11.drv/x11drv_main.c
-@@ -632,6 +632,8 @@ void CDECL X11DRV_ThreadDetach(void)
- 
-     if (data)
-     {
-+        if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
-+            X11DRV_XInput2_Disable();
-         if (data->xim) XCloseIM( data->xim );
-         if (data->font_set) XFreeFontSet( data->display, data->font_set );
-         XCloseDisplay( data->display );
-@@ -701,6 +703,8 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
-     TlsSetValue( thread_data_tls_index, data );
- 
-     if (use_xim) X11DRV_SetupXIM();
-+    if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
-+        X11DRV_XInput2_Enable();
- 
-     return data;
- }
--- 
-2.27.0
-
diff --git a/patches/user32-rawinput-mouse/0010-user32-Implement-GetRegisteredRawInputDevices.patch b/patches/user32-rawinput-mouse/0010-user32-Implement-GetRegisteredRawInputDevices.patch
deleted file mode 100644
index 7e73d134..00000000
--- a/patches/user32-rawinput-mouse/0010-user32-Implement-GetRegisteredRawInputDevices.patch
+++ /dev/null
@@ -1,204 +0,0 @@
-From 668e30532f05ca04015a0f7afd52999cbef9f7f9 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Mon, 26 Aug 2019 16:06:58 +0200
-Subject: [PATCH] user32: Implement GetRegisteredRawInputDevices.
-
----
- dlls/dinput8/tests/device.c | 13 ---------
- dlls/user32/rawinput.c      | 55 +++++++++++++++++++++++++++++++++++--
- server/protocol.def         |  6 ++++
- server/queue.c              | 24 ++++++++++++++++
- 4 files changed, 83 insertions(+), 15 deletions(-)
-
-diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
-index ea5ab751098..24af7399b84 100644
---- a/dlls/dinput8/tests/device.c
-+++ b/dlls/dinput8/tests/device.c
-@@ -602,7 +602,6 @@ static void test_mouse_keyboard(void)
- 
-     raw_devices_count = ARRAY_SIZE(raw_devices);
-     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
--    todo_wine
-     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
- 
-     hr = IDirectInputDevice8_Acquire(di_keyboard);
-@@ -624,7 +623,6 @@ static void test_mouse_keyboard(void)
-     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
-     raw_devices_count = ARRAY_SIZE(raw_devices);
-     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
--    todo_wine
-     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
- 
-     if (raw_devices[0].hwndTarget != NULL)
-@@ -662,7 +660,6 @@ static void test_mouse_keyboard(void)
-     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
-     raw_devices_count = ARRAY_SIZE(raw_devices);
-     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
--    todo_wine
-     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
- 
-     /* expect dinput8 to take over any activated raw input devices */
-@@ -689,26 +686,18 @@ static void test_mouse_keyboard(void)
-     raw_devices_count = ARRAY_SIZE(raw_devices);
-     memset(raw_devices, 0, sizeof(raw_devices));
-     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
--    todo_wine
-     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
--    todo_wine
-     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
--    todo_wine
-     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
-     todo_wine
-     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
-     todo_wine
-     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
--    todo_wine
-     ok(raw_devices[1].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
--    todo_wine
-     ok(raw_devices[1].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
-     ok(raw_devices[1].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
--    todo_wine
-     ok(raw_devices[1].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[1].hwndTarget);
--    todo_wine
-     ok(raw_devices[2].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
--    todo_wine
-     ok(raw_devices[2].usUsage == 6, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
-     todo_wine
-     ok(raw_devices[2].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
-@@ -727,12 +716,10 @@ static void test_mouse_keyboard(void)
-     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-     todo_wine
-     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
--    todo_wine
-     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
-     todo_wine
-     ok(raw_devices[0].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
-     ok(raw_devices[0].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
--    todo_wine
-     ok(raw_devices[0].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
- 
-     IDirectInputDevice8_Release(di_mouse);
-diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
-index 2465262f74e..7d2034e6594 100644
---- a/dlls/user32/rawinput.c
-+++ b/dlls/user32/rawinput.c
-@@ -522,14 +522,65 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT
-     return *data_size;
- }
- 
-+static int compare_raw_input_devices(const void *ap, const void *bp)
-+{
-+    const RAWINPUTDEVICE a = *(const RAWINPUTDEVICE *)ap;
-+    const RAWINPUTDEVICE b = *(const RAWINPUTDEVICE *)bp;
-+
-+    if (a.usUsagePage != b.usUsagePage) return a.usUsagePage - b.usUsagePage;
-+    if (a.usUsage != b.usUsage) return a.usUsage - b.usUsage;
-+    return 0;
-+}
-+
- /***********************************************************************
-  *              GetRegisteredRawInputDevices   (USER32.@)
-  */
- UINT WINAPI DECLSPEC_HOTPATCH GetRegisteredRawInputDevices(RAWINPUTDEVICE *devices, UINT *device_count, UINT size)
- {
--    FIXME("devices %p, device_count %p, size %u stub!\n", devices, device_count, size);
-+    struct rawinput_device *d = NULL;
-+    unsigned int count = ~0U;
- 
--    return 0;
-+    TRACE("devices %p, device_count %p, size %u\n", devices, device_count, size);
-+
-+    if (!device_count)
-+    {
-+        SetLastError(ERROR_INVALID_PARAMETER);
-+        return ~0U;
-+    }
-+
-+    if (devices && !(d = HeapAlloc( GetProcessHeap(), 0, *device_count * sizeof(*d) )))
-+        return ~0U;
-+
-+    SERVER_START_REQ( get_rawinput_devices )
-+    {
-+        if (d)
-+            wine_server_set_reply( req, d, *device_count * sizeof(*d) );
-+
-+        if (wine_server_call( req ))
-+            goto done;
-+
-+        if (!d || reply->device_count > *device_count)
-+        {
-+            *device_count = reply->device_count;
-+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
-+            goto done;
-+        }
-+
-+        for (count = 0; count < reply->device_count; ++count)
-+        {
-+            devices[count].usUsagePage = d[count].usage_page;
-+            devices[count].usUsage = d[count].usage;
-+            devices[count].dwFlags = d[count].flags;
-+            devices[count].hwndTarget = wine_server_ptr_handle(d[count].target);
-+        }
-+    }
-+    SERVER_END_REQ;
-+
-+    qsort(devices, count, sizeof(*devices), compare_raw_input_devices);
-+
-+done:
-+    if (d) HeapFree( GetProcessHeap(), 0, d );
-+    return count;
- }
- 
- 
-diff --git a/server/protocol.def b/server/protocol.def
-index 4ab2392771b..17e676950e8 100644
---- a/server/protocol.def
-+++ b/server/protocol.def
-@@ -3881,6 +3881,12 @@ struct handle_info
- #define SET_CURSOR_CLIP   0x08
- #define SET_CURSOR_NOCLIP 0x10
- 
-+/* Retrieve the list of registered rawinput devices */
-+@REQ(get_rawinput_devices)
-+@REPLY
-+    unsigned int device_count;
-+    VARARG(devices,rawinput_devices);
-+@END
- 
- /* Modify the list of registered rawinput devices */
- @REQ(update_rawinput_devices)
-diff --git a/server/queue.c b/server/queue.c
-index 7c6402012ba..46905f3ce41 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -3193,3 +3193,27 @@ DECL_HANDLER(update_rawinput_devices)
-     e = find_rawinput_device( 1, 6 );
-     current->process->rawinput_kbd   = e ? &e->device : NULL;
- }
-+
-+DECL_HANDLER(get_rawinput_devices)
-+{
-+    unsigned int device_count = list_count(&current->process->rawinput_devices);
-+    struct rawinput_device *devices;
-+    struct rawinput_device_entry *e;
-+    unsigned int i;
-+
-+    reply->device_count = device_count;
-+    if (get_reply_max_size() / sizeof (*devices) < device_count)
-+        return;
-+
-+    if (!(devices = mem_alloc( device_count * sizeof (*devices) )))
-+    {
-+        set_error( STATUS_NO_MEMORY );
-+        return;
-+    }
-+
-+    i = 0;
-+    LIST_FOR_EACH_ENTRY( e, &current->process->rawinput_devices, struct rawinput_device_entry, entry )
-+        devices[i++] = e->device;
-+
-+    set_reply_data_ptr( devices, device_count * sizeof (*devices) );
-+}
--- 
-2.26.0
-
diff --git a/patches/user32-rawinput-mouse/0011-dinput8-Add-support-for-dinput-devices-that-use-raw-.patch b/patches/user32-rawinput-mouse/0011-dinput8-Add-support-for-dinput-devices-that-use-raw-.patch
deleted file mode 100644
index bf50c185..00000000
--- a/patches/user32-rawinput-mouse/0011-dinput8-Add-support-for-dinput-devices-that-use-raw-.patch
+++ /dev/null
@@ -1,191 +0,0 @@
-From 7d1d098c5c456e1791bae10dd27996a62c7d993a Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Mon, 26 Aug 2019 16:06:59 +0200
-Subject: [PATCH] dinput8: Add support for dinput devices that use raw input
- interface.
-
-This adds a global message window that will receive WM_INPUT messages,
-dispatched to every raw input device event_proc.
-
-Devices that use raw input interface will not register low-level hooks
-anymore. They will also conflict with any raw input device registered
-outside of dinput, as exposed by the unit tests.
----
- dlls/dinput/device_private.h |  3 ++
- dlls/dinput/dinput_main.c    | 98 ++++++++++++++++++++++++++++++++++--
- 2 files changed, 97 insertions(+), 4 deletions(-)
-
-diff --git a/dlls/dinput/device_private.h b/dlls/dinput/device_private.h
-index fe5644f21c7..2fac4f0e61e 100644
---- a/dlls/dinput/device_private.h
-+++ b/dlls/dinput/device_private.h
-@@ -69,6 +69,9 @@ struct IDirectInputDeviceImpl
-     HWND                        win;
-     int                         acquired;
- 
-+    BOOL                        use_raw_input; /* use raw input instead of low-level messages */
-+    RAWINPUTDEVICE              raw_device;    /* raw device to (un)register */
-+
-     LPDIDEVICEOBJECTDATA        data_queue;  /* buffer for 'GetDeviceData'.                 */
-     int                         queue_len;   /* valid size of the queue                     */
-     int                         queue_head;  /* position to write new event into queue      */
-diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
-index 2e561502406..f7e30606bf4 100644
---- a/dlls/dinput/dinput_main.c
-+++ b/dlls/dinput/dinput_main.c
-@@ -97,6 +97,10 @@ static const struct dinput_device *dinput_devices[] =
- 
- HINSTANCE DINPUT_instance;
- 
-+static ATOM        di_em_win_class;
-+static const WCHAR di_em_winW[] = {'D','I','E','m','W','i','n',0};
-+static HWND        di_em_win;
-+
- static BOOL check_hook_thread(void);
- static CRITICAL_SECTION dinput_hook_crit;
- static struct list direct_input_list = LIST_INIT( direct_input_list );
-@@ -637,6 +641,61 @@ static HRESULT WINAPI IDirectInputWImpl_QueryInterface(LPDIRECTINPUT7W iface, RE
-     return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
- }
- 
-+static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
-+{
-+    IDirectInputDeviceImpl *dev;
-+    IDirectInputImpl *dinput;
-+
-+    TRACE( "%p %d %lx %lx\n", hwnd, msg, wparam, lparam );
-+
-+    if (msg == WM_INPUT)
-+    {
-+        EnterCriticalSection( &dinput_hook_crit );
-+        LIST_FOR_EACH_ENTRY( dev, &acquired_mouse_list, IDirectInputDeviceImpl, entry )
-+        {
-+            if (dev->use_raw_input)
-+            {
-+                TRACE("calling dinput_mouse_hook (%p %lx %lx)\n", dev, wparam, lparam);
-+                dinput_mouse_hook( &dev->IDirectInputDevice8A_iface, GET_RAWINPUT_CODE_WPARAM(wparam), lparam );
-+            }
-+        }
-+        LIST_FOR_EACH_ENTRY( dev, &acquired_keyboard_list, IDirectInputDeviceImpl, entry )
-+        {
-+            if (dev->use_raw_input)
-+            {
-+                TRACE("calling dinput_keyboard_hook (%p %lx %lx)\n", dev, wparam, lparam);
-+                dinput_keyboard_hook( &dev->IDirectInputDevice8A_iface, GET_RAWINPUT_CODE_WPARAM(wparam), lparam );
-+            }
-+        }
-+        LeaveCriticalSection( &dinput_hook_crit );
-+    }
-+
-+    return DefWindowProcW(hwnd, msg, wparam, lparam);
-+}
-+
-+static void register_di_em_win_class(void)
-+{
-+    static WNDCLASSEXW class;
-+
-+    ZeroMemory(&class, sizeof(class));
-+    class.cbSize = sizeof(class);
-+    class.lpfnWndProc = di_em_win_wndproc;
-+    class.hInstance = DINPUT_instance;
-+    class.lpszClassName = di_em_winW;
-+
-+    if (!(di_em_win_class = RegisterClassExW( &class )))
-+        WARN( "Unable to register message window class\n" );
-+}
-+
-+static void unregister_di_em_win_class(void)
-+{
-+    if (!di_em_win_class)
-+        return;
-+
-+    if (!UnregisterClassW( MAKEINTRESOURCEW( di_em_win_class ), DINPUT_instance ))
-+        WARN( "Unable to unregister message window class\n" );
-+}
-+
- static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion)
- {
-     if (!This->initialized)
-@@ -1668,13 +1727,19 @@ static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
-     EnterCriticalSection( &dinput_hook_crit );
-     LIST_FOR_EACH_ENTRY( dev, &acquired_mouse_list, IDirectInputDeviceImpl, entry )
-     {
--        TRACE("calling dinput_mouse_hook (%p %lx %lx)\n", dev, wparam, lparam);
--        skip |= dinput_mouse_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
-+        if (!dev->use_raw_input)
-+        {
-+            TRACE("calling dinput_mouse_hook (%p %lx %lx)\n", dev, wparam, lparam);
-+            skip |= dinput_mouse_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
-+        }
-     }
-     LIST_FOR_EACH_ENTRY( dev, &acquired_keyboard_list, IDirectInputDeviceImpl, entry )
-     {
--        TRACE("calling dinput_keyboard_hook (%p %lx %lx)\n", dev, wparam, lparam);
--        skip |= dinput_keyboard_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
-+        if (!dev->use_raw_input)
-+        {
-+            TRACE("calling dinput_keyboard_hook (%p %lx %lx)\n", dev, wparam, lparam);
-+            skip |= dinput_keyboard_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
-+        }
-     }
-     LeaveCriticalSection( &dinput_hook_crit );
- 
-@@ -1728,6 +1793,9 @@ static DWORD WINAPI hook_thread_proc(void *param)
-     static HHOOK kbd_hook, mouse_hook;
-     MSG msg;
- 
-+    di_em_win = CreateWindowW( MAKEINTRESOURCEW(di_em_win_class), di_em_winW,
-+                               0, 0, 0, 0, 0, HWND_MESSAGE, 0, DINPUT_instance, NULL );
-+
-     /* Force creation of the message queue */
-     PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE );
-     SetEvent(param);
-@@ -1778,6 +1846,9 @@ static DWORD WINAPI hook_thread_proc(void *param)
-         DispatchMessageW(&msg);
-     }
- 
-+    DestroyWindow( di_em_win );
-+    di_em_win = NULL;
-+
-     FreeLibraryAndExitThread(DINPUT_instance, 0);
- }
- 
-@@ -1860,6 +1931,23 @@ void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
-         hook_thread_event = NULL;
-     }
- 
-+    if (dev->use_raw_input)
-+    {
-+        if (acquired)
-+        {
-+            dev->raw_device.dwFlags = RIDEV_INPUTSINK;
-+            dev->raw_device.hwndTarget = di_em_win;
-+        }
-+        else
-+        {
-+            dev->raw_device.dwFlags = RIDEV_REMOVE;
-+            dev->raw_device.hwndTarget = NULL;
-+        }
-+
-+        if (!RegisterRawInputDevices( &dev->raw_device, 1, sizeof(RAWINPUTDEVICE) ))
-+            WARN( "Unable to (un)register raw device %x:%x\n", dev->raw_device.usUsagePage, dev->raw_device.usUsage );
-+    }
-+
-     if (acquired)
-         hook_change_finished_event = CreateEventW( NULL, FALSE, FALSE, NULL );
-     PostThreadMessageW( hook_thread_id, WM_USER+0x10, 1, (LPARAM)hook_change_finished_event );
-@@ -1894,9 +1982,11 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
-       case DLL_PROCESS_ATTACH:
-         DisableThreadLibraryCalls(inst);
-         DINPUT_instance = inst;
-+        register_di_em_win_class();
-         break;
-       case DLL_PROCESS_DETACH:
-         if (reserved) break;
-+        unregister_di_em_win_class();
-         DeleteCriticalSection(&dinput_hook_crit);
-         break;
-     }
--- 
-2.26.2
-
diff --git a/patches/user32-rawinput-mouse/0012-dinput8-Use-raw-input-interface-for-dinput8-mouse-de.patch b/patches/user32-rawinput-mouse/0012-dinput8-Use-raw-input-interface-for-dinput8-mouse-de.patch
deleted file mode 100644
index 665d31b0..00000000
--- a/patches/user32-rawinput-mouse/0012-dinput8-Use-raw-input-interface-for-dinput8-mouse-de.patch
+++ /dev/null
@@ -1,194 +0,0 @@
-From 75e4a39ac1bad4b2c69e993b7df3f59d9f2a212c Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Mon, 26 Aug 2019 14:08:20 +0200
-Subject: [PATCH] dinput8: Use raw input interface for dinput8 mouse device.
-
----
- dlls/dinput/mouse.c         | 117 +++++++++++++++++++++++++++++++++++-
- dlls/dinput8/tests/device.c |  10 +--
- 2 files changed, 119 insertions(+), 8 deletions(-)
-
-diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
-index 5e6f34f0eca..265a9e0a16a 100644
---- a/dlls/dinput/mouse.c
-+++ b/dlls/dinput/mouse.c
-@@ -239,6 +239,13 @@ static SysMouseImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput)
-     newDevice->base.data_format.wine_df = df;
-     IDirectInput_AddRef(&newDevice->base.dinput->IDirectInput7A_iface);
- 
-+    if (dinput->dwVersion >= 0x0800)
-+    {
-+        newDevice->base.use_raw_input = TRUE;
-+        newDevice->base.raw_device.usUsagePage = 1; /* HID generic device page */
-+        newDevice->base.raw_device.usUsage = 2; /* HID generic mouse */
-+    }
-+
-     return newDevice;
- 
- failed:
-@@ -311,7 +318,115 @@ int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam
- {
-     MSLLHOOKSTRUCT *hook = (MSLLHOOKSTRUCT *)lparam;
-     SysMouseImpl* This = impl_from_IDirectInputDevice8A(iface);
--    int wdata = 0, inst_id = -1, ret = 0;
-+    int wdata = 0, inst_id = -1, ret = 0, i;
-+
-+    if (wparam == RIM_INPUT || wparam == RIM_INPUTSINK)
-+    {
-+        RAWINPUTHEADER raw_header;
-+        RAWINPUT raw_input;
-+        UINT size;
-+        POINT rel, pt;
-+
-+        static const USHORT mouse_button_flags[] =
-+        {
-+            RI_MOUSE_BUTTON_1_DOWN, RI_MOUSE_BUTTON_1_UP,
-+            RI_MOUSE_BUTTON_2_DOWN, RI_MOUSE_BUTTON_2_UP,
-+            RI_MOUSE_BUTTON_3_DOWN, RI_MOUSE_BUTTON_3_UP,
-+            RI_MOUSE_BUTTON_4_DOWN, RI_MOUSE_BUTTON_4_UP,
-+            RI_MOUSE_BUTTON_5_DOWN, RI_MOUSE_BUTTON_5_UP
-+        };
-+
-+        TRACE("(%p) wp %08lx, lp %08lx\n", iface, wparam, lparam);
-+
-+        size = sizeof(raw_header);
-+        if (GetRawInputData( (HRAWINPUT)lparam, RID_HEADER, &raw_header, &size, sizeof(RAWINPUTHEADER) ) != sizeof(raw_header))
-+        {
-+            WARN( "Unable to read raw input data header\n" );
-+            return 0;
-+        }
-+
-+        if (raw_header.dwType != RIM_TYPEMOUSE)
-+            return 0;
-+
-+        if (raw_header.dwSize > sizeof(raw_input))
-+        {
-+            WARN( "Unexpected size for mouse raw input data\n" );
-+            return 0;
-+        }
-+
-+        size = raw_header.dwSize;
-+        if (GetRawInputData( (HRAWINPUT)lparam, RID_INPUT, &raw_input, &size, sizeof(RAWINPUTHEADER) ) != raw_header.dwSize )
-+        {
-+            WARN( "Unable to read raw input data\n" );
-+            return 0;
-+        }
-+
-+        if (raw_input.data.mouse.usFlags & MOUSE_VIRTUAL_DESKTOP)
-+            FIXME( "Unimplemented MOUSE_VIRTUAL_DESKTOP flag\n" );
-+        if (raw_input.data.mouse.usFlags & MOUSE_ATTRIBUTES_CHANGED)
-+            FIXME( "Unimplemented MOUSE_ATTRIBUTES_CHANGED flag\n" );
-+
-+        EnterCriticalSection(&This->base.crit);
-+
-+        rel.x = raw_input.data.mouse.lLastX;
-+        rel.y = raw_input.data.mouse.lLastY;
-+        if (raw_input.data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
-+        {
-+            GetCursorPos(&pt);
-+            rel.x -= pt.x;
-+            rel.y -= pt.y;
-+        }
-+
-+        This->m_state.lX += rel.x;
-+        This->m_state.lY += rel.y;
-+
-+        if (This->base.data_format.user_df->dwFlags & DIDF_ABSAXIS)
-+        {
-+            pt.x = This->m_state.lX;
-+            pt.y = This->m_state.lY;
-+        }
-+        else
-+        {
-+            pt = rel;
-+        }
-+
-+        if (rel.x)
-+            queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS,
-+                        pt.x, GetCurrentTime(), This->base.dinput->evsequence);
-+
-+        if (rel.y)
-+            queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS,
-+                        pt.y, GetCurrentTime(), This->base.dinput->evsequence);
-+
-+        if (rel.x || rel.y)
-+        {
-+            if ((This->warp_override == WARP_FORCE_ON) ||
-+                (This->warp_override != WARP_DISABLE && (This->base.dwCoopLevel & DISCL_EXCLUSIVE)))
-+                This->need_warp = TRUE;
-+        }
-+
-+        if (raw_input.data.mouse.usButtonFlags & RI_MOUSE_WHEEL)
-+        {
-+            This->m_state.lZ += (wdata = (SHORT)raw_input.data.mouse.usButtonData);
-+            queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Z_AXIS_INSTANCE) | DIDFT_RELAXIS,
-+                        wdata, GetCurrentTime(), This->base.dinput->evsequence);
-+            ret = This->clipped;
-+        }
-+
-+        for (i = 0; i < ARRAY_SIZE(mouse_button_flags); ++i)
-+        {
-+            if (raw_input.data.mouse.usButtonFlags & mouse_button_flags[i])
-+            {
-+                This->m_state.rgbButtons[i / 2] = 0x80 - (i % 2) * 0x80;
-+                queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + (i / 2)) | DIDFT_PSHBUTTON,
-+                            This->m_state.rgbButtons[i / 2], GetCurrentTime(), This->base.dinput->evsequence);
-+            }
-+        }
-+
-+        LeaveCriticalSection(&This->base.crit);
-+
-+        return ret;
-+    }
- 
-     TRACE("msg %lx @ (%d %d)\n", wparam, hook->pt.x, hook->pt.y);
- 
-diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
-index 328174e5796..b0a863f69f5 100644
---- a/dlls/dinput8/tests/device.c
-+++ b/dlls/dinput8/tests/device.c
-@@ -646,13 +646,9 @@ static void test_mouse_keyboard(void)
-     raw_devices_count = ARRAY_SIZE(raw_devices);
-     memset(raw_devices, 0, sizeof(raw_devices));
-     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
--    todo_wine
-     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
--    todo_wine
-     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
--    todo_wine
-     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
--    todo_wine
-     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
-     todo_wine
-     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
-@@ -662,6 +658,9 @@ static void test_mouse_keyboard(void)
-     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
- 
-+    if (raw_devices[0].hwndTarget != NULL)
-+        di_hwnd = raw_devices[0].hwndTarget;
-+
-     /* expect dinput8 to take over any activated raw input devices */
-     raw_devices[0].usUsagePage = 0x01;
-     raw_devices[0].usUsage = 0x05;
-@@ -689,9 +688,7 @@ static void test_mouse_keyboard(void)
-     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
-     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
-     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
--    todo_wine
-     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
--    todo_wine
-     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
-     ok(raw_devices[1].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
-     ok(raw_devices[1].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
-@@ -717,7 +714,6 @@ static void test_mouse_keyboard(void)
-     todo_wine
-     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
-     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
--    todo_wine
-     ok(raw_devices[0].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
-     ok(raw_devices[0].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
-     ok(raw_devices[0].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
--- 
-2.26.2
-
diff --git a/patches/user32-rawinput-mouse/0013-dinput-Fix-rawinput-events-sequence-number.patch b/patches/user32-rawinput-mouse/0013-dinput-Fix-rawinput-events-sequence-number.patch
deleted file mode 100644
index 1a28e0ca..00000000
--- a/patches/user32-rawinput-mouse/0013-dinput-Fix-rawinput-events-sequence-number.patch
+++ /dev/null
@@ -1,64 +0,0 @@
-From bc5c3fdd603688460b74c007a1172004a2c8ff30 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Wed, 8 Apr 2020 15:35:32 +0200
-Subject: [PATCH] dinput: Fix rawinput events sequence number.
-
----
- dlls/dinput/mouse.c | 10 ++++++----
- 1 file changed, 6 insertions(+), 4 deletions(-)
-
-diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
-index 5a624949867..6480a5adac6 100644
---- a/dlls/dinput/mouse.c
-+++ b/dlls/dinput/mouse.c
-@@ -333,6 +333,7 @@ static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM
-         RAWINPUT raw_input;
-         UINT size;
-         POINT rel, pt;
-+        DWORD seq;
- 
-         static const USHORT mouse_button_flags[] =
-         {
-@@ -374,6 +375,7 @@ static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM
-             FIXME( "Unimplemented MOUSE_ATTRIBUTES_CHANGED flag\n" );
- 
-         EnterCriticalSection(&This->base.crit);
-+        seq = This->base.dinput->evsequence++;
- 
-         rel.x = raw_input.data.mouse.lLastX;
-         rel.y = raw_input.data.mouse.lLastY;
-@@ -399,11 +401,11 @@ static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM
- 
-         if (rel.x)
-             queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS,
--                        pt.x, GetCurrentTime(), This->base.dinput->evsequence);
-+                        pt.x, GetCurrentTime(), seq);
- 
-         if (rel.y)
-             queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS,
--                        pt.y, GetCurrentTime(), This->base.dinput->evsequence);
-+                        pt.y, GetCurrentTime(), seq);
- 
-         if (rel.x || rel.y)
-         {
-@@ -416,7 +418,7 @@ static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM
-         {
-             This->m_state.lZ += (wdata = (SHORT)raw_input.data.mouse.usButtonData);
-             queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Z_AXIS_INSTANCE) | DIDFT_RELAXIS,
--                        wdata, GetCurrentTime(), This->base.dinput->evsequence);
-+                        wdata, GetCurrentTime(), seq);
-             ret = This->clipped;
-         }
- 
-@@ -426,7 +428,7 @@ static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM
-             {
-                 This->m_state.rgbButtons[i / 2] = 0x80 - (i % 2) * 0x80;
-                 queue_event(iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + (i / 2)) | DIDFT_PSHBUTTON,
--                            This->m_state.rgbButtons[i / 2], GetCurrentTime(), This->base.dinput->evsequence);
-+                            This->m_state.rgbButtons[i / 2], GetCurrentTime(), seq);
-             }
-         }
- 
--- 
-2.26.0
-
diff --git a/patches/user32-rawinput-mouse/definition b/patches/user32-rawinput-mouse/definition
index 79daf190..da00de38 100644
--- a/patches/user32-rawinput-mouse/definition
+++ b/patches/user32-rawinput-mouse/definition
@@ -2,4 +2,4 @@ Fixes: [42631] Mouse drift, jump or don't react to small slow movements in Unity
 Fixes: [42675] Overwatch: Phantom mouse input / view pulled up to ceiling
 Depends: winex11.drv-mouse-coorrds
 Depends: loader-KeyboardLayouts
-Disabled: True
+Disabled: false
diff --git a/patches/user32-rawinput-nolegacy/0001-dinput8-tests-Add-test-for-DISCL_EXCLUSIVE-flag-inte.patch b/patches/user32-rawinput-nolegacy/0001-dinput8-tests-Add-test-for-DISCL_EXCLUSIVE-flag-inte.patch
deleted file mode 100644
index 0f0dc233..00000000
--- a/patches/user32-rawinput-nolegacy/0001-dinput8-tests-Add-test-for-DISCL_EXCLUSIVE-flag-inte.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From a4256a564e309ad44a8aa8e8571c69444de20bf9 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 19 Dec 2019 19:00:21 +0100
-Subject: [PATCH 1/4] dinput8/tests: Add test for DISCL_EXCLUSIVE flag
- interaction with rawinput.
-
----
- dlls/dinput8/tests/device.c | 20 ++++++++++++++++++++
- 1 file changed, 20 insertions(+)
-
-diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
-index 42ba78707c6..845146af023 100644
---- a/dlls/dinput8/tests/device.c
-+++ b/dlls/dinput8/tests/device.c
-@@ -759,6 +759,26 @@ static void test_mouse_keyboard(void)
-     todo_wine
-     ok(raw_devices_count == 1, "Unexpected raw devices registered: %d\n", raw_devices_count);
- 
-+    IDirectInputDevice8_SetCooperativeLevel(di_mouse, hwnd, DISCL_FOREGROUND|DISCL_EXCLUSIVE);
-+    IDirectInputDevice8_SetCooperativeLevel(di_keyboard, hwnd, DISCL_FOREGROUND|DISCL_EXCLUSIVE);
-+
-+    hr = IDirectInputDevice8_Acquire(di_keyboard);
-+    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
-+    hr = IDirectInputDevice8_Acquire(di_mouse);
-+    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
-+    raw_devices_count = ARRAY_SIZE(raw_devices);
-+    memset(raw_devices, 0, sizeof(raw_devices));
-+    hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-+    ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
-+    todo_wine
-+    ok(raw_devices[0].dwFlags == (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
-+    todo_wine
-+    ok(raw_devices[2].dwFlags == (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
-+    hr = IDirectInputDevice8_Unacquire(di_keyboard);
-+    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
-+    hr = IDirectInputDevice8_Unacquire(di_mouse);
-+    ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
-+
-     raw_devices_count = ARRAY_SIZE(raw_devices);
-     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-     todo_wine
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-nolegacy/0002-user32-Add-support-for-RIDEV_NOLEGACY-flag-in-Regist.patch b/patches/user32-rawinput-nolegacy/0002-user32-Add-support-for-RIDEV_NOLEGACY-flag-in-Regist.patch
deleted file mode 100644
index eb60f08b..00000000
--- a/patches/user32-rawinput-nolegacy/0002-user32-Add-support-for-RIDEV_NOLEGACY-flag-in-Regist.patch
+++ /dev/null
@@ -1,75 +0,0 @@
-From c39bb27347442d2d229d6e851c17094c086411d6 Mon Sep 17 00:00:00 2001
-From: Derek Lesho <dereklesho52@Gmail.com>
-Date: Tue, 25 Jun 2019 16:23:02 -0400
-Subject: [PATCH 2/4] user32: Add support for RIDEV_NOLEGACY flag in
- RegisterRawInputDevices.
-
----
- dlls/user32/rawinput.c | 2 +-
- server/queue.c         | 9 +++++++++
- 2 files changed, 10 insertions(+), 1 deletion(-)
-
-diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
-index 3792360b057..8cf9f8ebf62 100644
---- a/dlls/user32/rawinput.c
-+++ b/dlls/user32/rawinput.c
-@@ -283,7 +283,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
-         TRACE("device %u: page %#x, usage %#x, flags %#x, target %p.\n",
-                 i, devices[i].usUsagePage, devices[i].usUsage,
-                 devices[i].dwFlags, devices[i].hwndTarget);
--        if (devices[i].dwFlags & ~RIDEV_REMOVE)
-+        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY))
-             FIXME("Unhandled flags %#x for device %u.\n", devices[i].dwFlags, i);
- 
-         d[i].usage_page = devices[i].usUsagePage;
-diff --git a/server/queue.c b/server/queue.c
-index 8a1bbfff5aa..f5dc06100d1 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -427,6 +427,9 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
-     static const struct hw_msg_source source = { IMDT_UNAVAILABLE, IMO_SYSTEM };
-     struct message *msg;
- 
-+    if (current->process->rawinput_mouse &&
-+        current->process->rawinput_mouse->flags & RIDEV_NOLEGACY) return;
-+
-     if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
- 
-     msg->msg = WM_MOUSEMOVE;
-@@ -1793,6 +1796,7 @@ done:
- static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
-                                 unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
- {
-+    const struct rawinput_device *device;
-     struct hardware_msg_data *msg_data;
-     struct rawinput_message raw_msg;
-     struct message *msg;
-@@ -1866,6 +1870,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
- 
-     if (!(req_flags & SEND_HWMSG_WINDOW))
-         return 0;
-+    if ((device = current->process->rawinput_mouse) && (device->flags & RIDEV_NOLEGACY))
-+        return 0;
- 
-     for (i = 0; i < ARRAY_SIZE( messages ); i++)
-     {
-@@ -1901,6 +1907,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
-                                    unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
- {
-     struct hw_msg_source source = { IMDT_KEYBOARD, origin };
-+    const struct rawinput_device *device;
-     struct hardware_msg_data *msg_data;
-     struct rawinput_message raw_msg;
-     struct message *msg;
-@@ -1996,6 +2003,8 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
- 
-     if (!(req_flags & SEND_HWMSG_WINDOW))
-         return 0;
-+    if ((device = current->process->rawinput_kbd) && (device->flags & RIDEV_NOLEGACY))
-+        return 0;
- 
-     if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
-     msg_data = msg->data;
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-nolegacy/0003-dinput-Set-RIDEV_INPUTSINK-flag-only-when-DISCL_BACK.patch b/patches/user32-rawinput-nolegacy/0003-dinput-Set-RIDEV_INPUTSINK-flag-only-when-DISCL_BACK.patch
deleted file mode 100644
index f842e575..00000000
--- a/patches/user32-rawinput-nolegacy/0003-dinput-Set-RIDEV_INPUTSINK-flag-only-when-DISCL_BACK.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From 1372e0e8582eeb423aa65deab17c52f4f5e153d0 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 19 Dec 2019 19:00:50 +0100
-Subject: [PATCH 3/4] dinput: Set RIDEV_INPUTSINK flag only when
- DISCL_BACKGROUND is requested.
-
----
- dlls/dinput/dinput_main.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
-index 9e3b9f48250..ef92a7d7c50 100644
---- a/dlls/dinput/dinput_main.c
-+++ b/dlls/dinput/dinput_main.c
-@@ -1960,7 +1960,9 @@ void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
-     {
-         if (acquired)
-         {
--            dev->raw_device.dwFlags = RIDEV_INPUTSINK;
-+            dev->raw_device.dwFlags = 0;
-+            if (dev->dwCoopLevel & DISCL_BACKGROUND)
-+                dev->raw_device.dwFlags |= RIDEV_INPUTSINK;
-             dev->raw_device.hwndTarget = di_em_win;
-         }
-         else
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-nolegacy/0004-dinput-Set-correct-rawinput-flags-for-DISCL_EXCLUSIV.patch b/patches/user32-rawinput-nolegacy/0004-dinput-Set-correct-rawinput-flags-for-DISCL_EXCLUSIV.patch
deleted file mode 100644
index fcd8a948..00000000
--- a/patches/user32-rawinput-nolegacy/0004-dinput-Set-correct-rawinput-flags-for-DISCL_EXCLUSIV.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From 68898282e49228e9a26328373b4cd661a86d7672 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 19 Dec 2019 19:30:49 +0100
-Subject: [PATCH 4/4] dinput: Set correct rawinput flags for DISCL_EXCLUSIVE.
-
----
- dlls/dinput/dinput_main.c   | 4 ++++
- dlls/dinput8/tests/device.c | 1 -
- 2 files changed, 4 insertions(+), 1 deletion(-)
-
-diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
-index ef92a7d7c50..6a74b6da500 100644
---- a/dlls/dinput/dinput_main.c
-+++ b/dlls/dinput/dinput_main.c
-@@ -1963,6 +1963,10 @@ void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
-             dev->raw_device.dwFlags = 0;
-             if (dev->dwCoopLevel & DISCL_BACKGROUND)
-                 dev->raw_device.dwFlags |= RIDEV_INPUTSINK;
-+            if ((dev->dwCoopLevel & DISCL_EXCLUSIVE) && dev->raw_device.usUsage == 2)
-+                dev->raw_device.dwFlags |= (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY);
-+            if ((dev->dwCoopLevel & DISCL_EXCLUSIVE) && dev->raw_device.usUsage == 6)
-+                dev->raw_device.dwFlags |= (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY);
-             dev->raw_device.hwndTarget = di_em_win;
-         }
-         else
-diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
-index 845146af023..31220db220a 100644
---- a/dlls/dinput8/tests/device.c
-+++ b/dlls/dinput8/tests/device.c
-@@ -770,7 +770,6 @@ static void test_mouse_keyboard(void)
-     memset(raw_devices, 0, sizeof(raw_devices));
-     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
--    todo_wine
-     ok(raw_devices[0].dwFlags == (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
-     todo_wine
-     ok(raw_devices[2].dwFlags == (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
--- 
-2.24.1
-
diff --git a/patches/user32-rawinput-nolegacy/0005-server-Update-desktop-cursor-pos-even-if-RIDEV_NOLEG.patch b/patches/user32-rawinput-nolegacy/0005-server-Update-desktop-cursor-pos-even-if-RIDEV_NOLEG.patch
deleted file mode 100644
index 91679553..00000000
--- a/patches/user32-rawinput-nolegacy/0005-server-Update-desktop-cursor-pos-even-if-RIDEV_NOLEG.patch
+++ /dev/null
@@ -1,76 +0,0 @@
-From a09689c9022603d7c7d41e6095a400fbf7841869 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Thu, 9 Jan 2020 17:50:32 +0100
-Subject: [PATCH] server: Update desktop cursor pos even if RIDEV_NOLEGACY flag
- is set.
-
----
- server/queue.c | 30 +++++++++++++++++++++++-------
- 1 file changed, 23 insertions(+), 7 deletions(-)
-
-diff --git a/server/queue.c b/server/queue.c
-index f5dc06100d1..4b2fef8a20a 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -421,6 +421,20 @@ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_sour
-     return msg;
- }
- 
-+static int update_desktop_cursor_pos( struct desktop *desktop, int x, int y )
-+{
-+    int updated;
-+
-+    x = max( min( x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
-+    y = max( min( y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
-+    updated = (desktop->cursor.x != x || desktop->cursor.y != y);
-+    desktop->cursor.x = x;
-+    desktop->cursor.y = y;
-+    desktop->cursor.last_change = get_tick_count();
-+
-+    return updated;
-+}
-+
- /* set the cursor position and queue the corresponding mouse message */
- static void set_cursor_pos( struct desktop *desktop, int x, int y )
- {
-@@ -428,7 +442,11 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
-     struct message *msg;
- 
-     if (current->process->rawinput_mouse &&
--        current->process->rawinput_mouse->flags & RIDEV_NOLEGACY) return;
-+        current->process->rawinput_mouse->flags & RIDEV_NOLEGACY)
-+    {
-+        update_desktop_cursor_pos( desktop, x, y );
-+        return;
-+    }
- 
-     if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
- 
-@@ -1634,12 +1652,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
-     {
-         if (msg->msg == WM_MOUSEMOVE)
-         {
--            int x = max( min( msg->x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
--            int y = max( min( msg->y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
--            if (desktop->cursor.x != x || desktop->cursor.y != y) always_queue = 1;
--            desktop->cursor.x = x;
--            desktop->cursor.y = y;
--            desktop->cursor.last_change = get_tick_count();
-+            if (update_desktop_cursor_pos( desktop, msg->x, msg->y )) always_queue = 1;
-         }
-         if (desktop->keystate[VK_LBUTTON] & 0x80)  msg->wparam |= MK_LBUTTON;
-         if (desktop->keystate[VK_MBUTTON] & 0x80)  msg->wparam |= MK_MBUTTON;
-@@ -1871,7 +1884,10 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
-     if (!(req_flags & SEND_HWMSG_WINDOW))
-         return 0;
-     if ((device = current->process->rawinput_mouse) && (device->flags & RIDEV_NOLEGACY))
-+    {
-+        if (flags & MOUSEEVENTF_MOVE) update_desktop_cursor_pos( desktop, x, y );
-         return 0;
-+    }
- 
-     for (i = 0; i < ARRAY_SIZE( messages ); i++)
-     {
--- 
-2.25.0.rc1
-
diff --git a/patches/user32-rawinput-nolegacy/0006-server-Also-update-the-key-state-if-RIDEV_NOLEGACY-i.patch b/patches/user32-rawinput-nolegacy/0006-server-Also-update-the-key-state-if-RIDEV_NOLEGACY-i.patch
deleted file mode 100644
index 04483542..00000000
--- a/patches/user32-rawinput-nolegacy/0006-server-Also-update-the-key-state-if-RIDEV_NOLEGACY-i.patch
+++ /dev/null
@@ -1,106 +0,0 @@
-From 5406b7b15cae43cbe023492f518436c6990871f5 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
-Date: Fri, 27 Mar 2020 16:25:14 +0100
-Subject: [PATCH] server: Also update the key state if RIDEV_NOLEGACY is used.
-
----
- server/queue.c | 40 ++++++++++++++++++++++++++++++++--------
- 1 file changed, 32 insertions(+), 8 deletions(-)
-
-diff --git a/server/queue.c b/server/queue.c
-index 7262d6201f4..5621e393dd8 100644
---- a/server/queue.c
-+++ b/server/queue.c
-@@ -1310,12 +1310,12 @@ static void set_input_key_state( unsigned char *keystate, unsigned char key, int
- 
- /* update the key state for a keyboard message */
- static void update_key_state( struct desktop *desktop, unsigned char *keystate,
--                              const struct message *msg )
-+                              unsigned int msg, lparam_t wparam )
- {
-     unsigned char key;
-     int down = 0;
- 
--    switch (msg->msg)
-+    switch (msg)
-     {
-     case WM_LBUTTONDOWN:
-         down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
-@@ -1339,8 +1339,8 @@ static void update_key_state( struct desktop *desktop, unsigned char *keystate,
-         down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
-         /* fall through */
-     case WM_XBUTTONUP:
--        if (msg->wparam >> 16 == XBUTTON1) set_input_key_state( keystate, VK_XBUTTON1, down );
--        else if (msg->wparam >> 16 == XBUTTON2) set_input_key_state( keystate, VK_XBUTTON2, down );
-+        if (wparam >> 16 == XBUTTON1) set_input_key_state( keystate, VK_XBUTTON1, down );
-+        else if (wparam >> 16 == XBUTTON2) set_input_key_state( keystate, VK_XBUTTON2, down );
-         break;
-     case WM_KEYDOWN:
-     case WM_SYSKEYDOWN:
-@@ -1348,7 +1348,7 @@ static void update_key_state( struct desktop *desktop, unsigned char *keystate,
-         /* fall through */
-     case WM_KEYUP:
-     case WM_SYSKEYUP:
--        key = (unsigned char)msg->wparam;
-+        key = (unsigned char)wparam;
-         set_input_key_state( keystate, key, down );
-         switch(key)
-         {
-@@ -1392,11 +1392,35 @@ static void synchronize_input_key_state( struct thread_input *input )
-     }
- }
- 
-+/* update the desktop key state according to a mouse message flags */
-+static void update_desktop_mouse_state( struct desktop *desktop, unsigned int flags,
-+                                        int x, int y, lparam_t wparam )
-+{
-+    if (flags & MOUSEEVENTF_MOVE)
-+        update_desktop_cursor_pos( desktop, x, y );
-+    if (flags & MOUSEEVENTF_LEFTDOWN)
-+        update_key_state( desktop, desktop->keystate, WM_LBUTTONDOWN, wparam );
-+    if (flags & MOUSEEVENTF_LEFTUP)
-+        update_key_state( desktop, desktop->keystate, WM_LBUTTONUP, wparam );
-+    if (flags & MOUSEEVENTF_RIGHTDOWN)
-+        update_key_state( desktop, desktop->keystate, WM_RBUTTONDOWN, wparam );
-+    if (flags & MOUSEEVENTF_RIGHTUP)
-+        update_key_state( desktop, desktop->keystate, WM_RBUTTONUP, wparam );
-+    if (flags & MOUSEEVENTF_MIDDLEDOWN)
-+        update_key_state( desktop, desktop->keystate, WM_MBUTTONDOWN, wparam );
-+    if (flags & MOUSEEVENTF_MIDDLEUP)
-+        update_key_state( desktop, desktop->keystate, WM_MBUTTONUP, wparam );
-+    if (flags & MOUSEEVENTF_XDOWN)
-+        update_key_state( desktop, desktop->keystate, WM_XBUTTONDOWN, wparam );
-+    if (flags & MOUSEEVENTF_XUP)
-+        update_key_state( desktop, desktop->keystate, WM_XBUTTONUP, wparam );
-+}
-+
- /* update the thread input key state for a keyboard message */
- static void update_input_key_state( struct thread_input *input, const struct message *msg )
- {
-     synchronize_input_key_state( input );
--    update_key_state( input->desktop, input->keystate, msg );
-+    update_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
- }
- 
- /* release the hardware message currently being processed by the given thread */
-@@ -1548,7 +1572,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
-     struct thread_input *input;
-     unsigned int msg_code;
- 
--    update_key_state( desktop, desktop->keystate, msg );
-+    update_key_state( desktop, desktop->keystate, msg->msg, msg->wparam );
-     last_input_time = get_tick_count();
-     if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
- 
-@@ -1796,7 +1820,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
-         return 0;
-     if ((device = current->process->rawinput_mouse) && (device->flags & RIDEV_NOLEGACY))
-     {
--        if (flags & MOUSEEVENTF_MOVE) update_desktop_cursor_pos( desktop, x, y );
-+        update_desktop_mouse_state( desktop, flags, x, y, input->mouse.data << 16 );
-         return 0;
-     }
- 
--- 
-2.26.0
-
diff --git a/patches/user32-rawinput-nolegacy/definition b/patches/user32-rawinput-nolegacy/definition
deleted file mode 100644
index a596cd9c..00000000
--- a/patches/user32-rawinput-nolegacy/definition
+++ /dev/null
@@ -1,2 +0,0 @@
-Depends: user32-rawinput-mouse
-Disabled: True
-- 
2.26.2

